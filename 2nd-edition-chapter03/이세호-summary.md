# 2판 Chapter 3 중 추가된 내용만 정리

## GraphQL

### 1. 정의 및 목적 (Definition & Purpose)

- **개념**: 다른 쿼리 언어(SQL, Cypher 등)보다 의도적으로 **더 제한적(restrictive)**으로 설계된 쿼리 언어입니다.
- **주 목적**: 모바일 앱이나 웹 앱 같은 **클라이언트 소프트웨어**가 UI 렌더링에 필요한 필드만 포함된 특정 구조의 **JSON 문서**를 요청하기 위해 사용됩니다.
- **핵심 장점**: 클라이언트가 서버 측 API를 수정하지 않고도 필요한 데이터를 자유롭게 변경하여 요청할 수 있어, 개발 속도를 높여줍니다.
- **용도**: 주로 **OLTP(Online Transaction Processing)** 쿼리에 적합합니다.

### 2. 장단점 및 트레이드오프 (Trade-offs)

- **유연성의 비용**:
  - GraphQL 쿼리를 내부 서비스(주로 REST나 gRPC) 요청으로 변환해주는 별도의 도구(Tooling)가 필요한 경우가 많습니다.
  - **운영 이슈**: 권한 부여(Authorization), 속도 제한(Rate limiting), 성능 최적화 등이 추가적인 과제가 됩니다.
- **보안 및 제한**:
  - 신뢰할 수 없는 소스(클라이언트)로부터 쿼리를 받기 때문에, 서버 과부하(DoS 공격)를 방지하기 위해 **실행 비용이 비싼 작업은 허용하지 않습니다.**
  - **제약 사항**: SQL이나 그래프 쿼리 언어(Cypher, SPARQL)와 달리 **재귀 쿼리(recursive queries)**를 지원하지 않으며, 서비스 소유자가 명시적으로 제공하지 않는 한 임의의 검색 조건(예: "미국 출생, 현재 유럽 거주")을 사용할 수 없습니다.

### 3. 데이터 구조 및 응답 방식 (Data Structure & Response)

- **쿼리와 응답의 일치**:
  - 응답(JSON)은 요청한 쿼리의 구조를 그대로 따릅니다.
  - 클라이언트는 필요한 속성만 정확히 명시하므로, 서버는 클라이언트의 UI가 어떤 데이터를 필요로 하는지 알 필요가 없습니다.

### 4. 데이터 중복과 설계 철학 (Data Duplication & Design Choice)

- **중복 허용**: 응답 데이터 크기가 커지더라도 **클라이언트의 렌더링 편의성**을 우선합니다.
  - 예: 한 사용자가 여러 메시지를 보냈을 때, 각 메시지 객체마다 작성자 정보(이름, 이미지)가 중복되어 포함됩니다.
  - 예: 답장(`replyTo`)의 경우, 원본 메시지의 ID만 주는 대신 원본 내용과 작성자를 중복해서 포함시켜 클라이언트가 추가 요청을 보낼 필요 없게 만듭니다.
- **정규화 vs 비정규화**:
  - **서버/DB**: 데이터를 정규화된 형태로 저장하고 조인(Join)을 통해 쿼리를 처리할 수 있습니다 ㅍ.
  - **클라이언트**: GraphQL 스키마에 명시된 관계(Join)만 요청할 수 있으며, 응답은 사용하기 편한 비정규화된(중복이 포함된) 트리 구조로 받습니다.

### 5. 구현 유연성 (Implementation)

- 이름에 "Graph"가 들어가고 응답 형태가 문서(Document)와 비슷하지만, 실제 백엔드 데이터베이스는 **관계형(Relational), 문서형(Document), 그래프(Graph) 등 어떤 종류의 DB 위에서도 구현 가능**합니다.

## Event Sourcing and CQRS

### 1. 배경 및 개념

- **문제 인식**: 복잡한 애플리케이션에서 단일 데이터 모델이 쓰기와 읽기(다양한 쿼리 요구사항) 모두를 만족시키기 어려움.
- **해결책**: 쓰기 최적화 모델과 읽기 최적화 모델을 분리.
  - **이벤트 소싱(Event Sourcing)**: 모든 상태 변경을 '이벤트'라는 불변(immutable)의 로그로 저장하여 '진실의 원천(Source of Truth)'으로 삼는 방식. (예: "좌석 예약됨", "예약 취소됨")
  - **CQRS (Command Query Responsibility Segregation)**: 명령(Command/Write)과 조회(Query/Read)의 책임을 분리. 쓰기 전용의 이벤트 로그로부터 읽기 전용의 '구체화된 뷰(Materialized View)'를 파생시켜 사용.

### 2. 작동 방식

- **쓰기 (Command)**: 사용자 요청(Command)이 유효한지 검증 후, 실행되면 불변의 '이벤트'로 로그에 추가(Append-only). 이벤트는 과거형으로 명명(예: `SeatsBooked`).
- **읽기 (Query)**: 이벤트 로그를 구독하여 필요한 형태(차트, 상태 조회 등)로 가공된 뷰(View)를 업데이트. 뷰는 언제든지 이벤트 로그를 통해 재생성 가능.

### 3. 장점

- **비즈니스 의도 파악**: 데이터베이스의 단순 상태 변경(Update/Delete)보다 "왜" 변경되었는지(이벤트 내용) 명확히 알 수 있음.
- **재생산성 및 디버깅**: 뷰 생성 로직에 버그가 있어도 로직 수정 후 이벤트를 처음부터 다시 처리(Replay)하여 뷰를 복구할 수 있음.
- **유연성**: 동일한 이벤트 로그로 다양한 목적의 뷰(읽기 모델)를 만들 수 있으며, 새로운 기능 추가 시 과거 데이터에도 소급 적용 가능.
- **감사(Audit) 및 이력**: 모든 변경 내역이 로그에 남으므로 감사 추적에 용이.
- **쓰기 성능**: Append-only 방식이므로 쓰기 처리량이 높음.

### 4. 단점 및 주의사항

- **비동기성 및 결과적 일관성**: 읽기 뷰가 이벤트 로그보다 시점상 뒤처질 수 있음.
- **외부 부작용(Side-effects)**: 이벤트를 재처리(Replay)할 때 이메일 발송 등 외부 시스템 호출이 중복되지 않도록 주의 필요.
- **개인정보 삭제(GDPR)**: 데이터가 불변이므로 특정 사용자의 데이터를 완전히 삭제하기 어려움(암호화 키 폐기 방식(Crypto-shredding) 등 사용).
- **외부 데이터 의존**: 이벤트 처리 시 환율 등 변동되는 외부 데이터가 필요한 경우, 해당 시점의 값을 이벤트에 포함시키거나 이력을 관리해야 함.

## DataFrames, Matrices, and Arrays (데이터프레임, 행렬, 배열)

### 1. 개요

- **용도**: 주로 분석(Analytics), 통계, 머신러닝(ML), 과학 계산 분야에서 사용. OLTP보다는 데이터 탐색 및 가공("Wrangling")에 최적화.
- **주요 도구**: R, Python Pandas, Apache Spark, NumPy 등.

### 2. 데이터프레임 (DataFrame)

- **특징**: 관계형 테이블과 유사(행과 열)하지만, 선언적 SQL 대신 연산 함수(Filter, GroupBy, Join/Merge 등)를 연쇄적으로 적용하여 데이터를 변환.
- **작업 흐름**: 데이터 과학자가 로컬에서 데이터를 단계적으로 정제하고 변형하는 과정에 적합.

### 3. 행렬(Matrix) 변환

- **ML과의 연계**: 많은 머신러닝 알고리즘은 입력을 숫자 행렬(Matrix) 형태(예: 희소 행렬)로 요구.
- **변환 기법**:
  - **원-핫 인코딩(One-hot encoding)**: 범주형 데이터(예: 영화 장르)를 0과 1의 컬럼으로 변환.
  - 데이터프레임은 관계형 데이터를 행렬 형태로 변환하는 가교 역할을 수행.

### 4. 배열 데이터베이스 (Array Databases)

- **특징**: 다차원 배열(Multidimensional Arrays) 저장에 특화.
- **활용**: 과학(천문학, 의료 영상), 지리 정보(GIS), 금융 시계열 데이터 등 대규모 수치 데이터 처리. (예: TileDB)
