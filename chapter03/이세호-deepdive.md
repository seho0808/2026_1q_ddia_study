# 🔖 LSM Tree 손구현 핵심 요소 - BloomFilter (손구현은 - /2026-1d-ddia-study/chapter03/이세호-poc-lsm-tree)

**블룸 필터(Bloom Filter)**는 한마디로 **"없는 데이터를 찾느라 헛고생하는 것을 막아주는 문지기"**입니다.

데이터베이스(특히 LSM Tree)에서 **읽기 성능을 획기적으로 높여주는 핵심 부품**입니다.

### 1. 역할: "디스크 I/O 낭비 방지"

LSM Tree는 데이터를 찾을 때 `MemTable` → `SSTable 1` → `SSTable 2` ... 순서로 뒤집니다. 만약 찾는 키가 **DB에 아예 없다면**, 가장 오래된 파일까지 전부 뒤져봐야 "없다"는 걸 알게 됩니다. 이는 엄청난 낭비입니다.

블룸 필터는 **"그 키는 여기 절대 없어. 파일 열어볼 필요도 없어."** 라고 말해주는 역할을 합니다.

---

### 2. 작동 원리

블룸 필터는 **비트 배열(0과 1의 방)**과 **여러 개의 해시 함수**를 사용합니다.

#### (1) 등록할 때 (`add`)

데이터가 들어오면 여러 해시 함수를 돌려서 나온 위치의 비트를 모두 `1`로 켭니다. (마치 여러 손가락으로 지문을 찍는 것과 같습니다.)

```ts
// BloomFilter.ts
// 코드 예시: 3개의 해시 함수를 쓴다고 가정
add(key: string): void {
  this.hashFunctions.forEach((hashFn) => {
    const index = hashFn(key) % this.size;
    // 해당 위치의 비트를 1로 켭니다. (비트 연산)
    // this.bitArray[...] |= 1 << ...
  });
}
```

#### (2) 확인할 때 (`mightContain`)

어떤 키가 있는지 확인할 때도 똑같은 해시 함수를 돌려봅니다.

- 나온 위치의 비트가 **단 하나라도 `0`이라면?** → **"절대 없음"** (지문이 안 찍혀 있으니까요). **→ 파일 열지 말고 패스!**
- 나온 위치의 비트가 **모두 `1`이라면?** → **"있을 수도 있음"** (누군가 찍은 지문과 우연히 겹칠 수 있음). **→ 파일을 열어서 진짜 있는지 확인.**

```ts
// BloomFilter.ts
mightContain(key: string): boolean {
  return this.hashFunctions.every((hashFn) => {
    // 하나라도 0이면 false 리턴 (즉, 절대 없음)
    // 모든 비트가 1이어야 true 리턴 (있을 지도 모름)
  });
}
```

블룸 필터의 핵심은 **"정보를 뭉개서(압축해서) 저장한다"**는 점에 있습니다. 정확한 값을 저장하는 대신, 값의 **흔적(지문)**만 남기기 때문입니다.

쉬운 비유로 설명해 드릴게요.

### 비유: 3개의 스위치와 여러 사람

상황: 100개의 스위치가 있는 큰 전광판이 있습니다. 모든 스위치는 처음에 꺼져 있습니다(0).

#### 1. 등록 과정 (`add`)

- **철수**가 들어옵니다. 철수의 이름을 해시 함수에 넣었더니 `1번`, `5번`, `10번` 스위치를 켜라고 합니다. 철수는 이 세 개의 스위치를 켭니다(1).
- **영희**가 들어옵니다. 영희의 이름은 `5번`, `20번`, `30번` 스위치를 켜라고 합니다. 영희는 이 세 개를 켭니다. (`5번`은 철수가 이미 켰지만 그냥 켜진 상태로 둡니다.)

#### 2. 확인 과정 (`mightContain`)

**Q1: "철수 있어?"**

- 철수의 해시값인 `1번`, `5번`, `10번` 스위치를 봅니다.
- 셋 다 켜져 있죠?
- 판단: "어? 셋 다 켜져 있네? 철수가 켰을 수도 있고, 다른 사람들이 우연히 섞여서 켰을 수도 있지만, 일단 **있을 가능성이 높아.**" (→ 그래서 진짜 명부를 확인해봐야 함)

**Q2: "민수 있어?"**

- 민수의 이름을 돌렸더니 `1번`, `5번`, `99번`을 확인하라고 나왔습니다.
- `1번`, `5번`은 켜져 있습니다. (철수랑 영희가 켰으니까요)
- 그런데 **`99번` 스위치가 꺼져 있습니다.**
- 판단: "만약 민수가 왔었다면 `99번`을 무조건 켰을 텐데, 꺼져 있네? **민수는 절대 안 왔어.**" (→ **절대 없음**)

### 즉, "꺼진 불" 하나가 강력한 증거입니다

- **모두 켜져 있다(1)**: 내가 켠 건지, 남이 켠 건지 구분할 수 없습니다. (정보가 뭉개졌으니까요). 그래서 "있을 수도 있음(False Positive)"입니다.
- **하나라도 꺼져 있다(0)**: 내가 왔었다면 켰을 그 자리가 꺼져 있다는 건, **나는 절대 오지 않았다**는 확실한 증거가 됩니다. (정보 손실이 있어도, 0은 0이니까요).

이 원리 덕분에 **"없는 것"**은 100% 확신을 가지고 걸러낼 수 있습니다.

---

### 3. 코드에서의 활용 (`SSTable.ts`)

작성하신 `SSTable.ts`를 보면 이 원리가 그대로 적용되어 있습니다. 디스크(`fs.openSync`)를 열기 전에 블룸 필터에게 먼저 물어봅니다.

```ts
// SSTable.ts
get(key: string): string | undefined {
  // 0. Check Bloom Filter first (Optimization)
  // 문지기에게 물어봄: "이거 있어?"
  // 문지기: "아니, 절대 없어." -> 바로 리턴 (디스크 접근 0회)
  if (this.bloomFilter && !this.bloomFilter.mightContain(key)) {
    return undefined;
  }

  // 문지기: "있을 수도 있어." -> 그제서야 인덱스 뒤지고 디스크 염
  // ... (Sparse Index 확인 및 디스크 Read) ...
}
```

### 요약

- **False Negative (거짓 부정) 없음**: "없다"고 하면 100% 없는 것입니다. (신뢰성 보장)
- **False Positive (거짓 긍정) 있음**: "있다"고 해도 실제로는 없을 수 있습니다. (그래서 파일을 열어보긴 해야 함)
- **결론**: 약간의 메모리(비트 배열)를 써서 값비싼 디스크 I/O를 획기적으로 줄이는 **가성비 최고의 확률적 자료구조**입니다.

# 🔖 컬럼 저장소는 언제 빠른가

| 상황      | Column-oriented가 빠름      | Row-oriented가 빠름     |
| --------- | --------------------------- | ----------------------- |
| 조회 패턴 | 특정 컬럼만 조회            | 한 행 전체 조회         |
| 연산 종류 | 집계(SUM, AVG, COUNT), 스캔 | 트랜잭션, 포인트 조회   |
| 데이터 양 | 대용량(OLAP)                | 소량·빈번한(OLTP)       |
| 쓰기 패턴 | 배치 쓰기                   | 잦은 단건 INSERT/UPDATE |
| 압축/캐시 | 매우 유리                   | 상대적으로 불리         |

- 직관적인 비유 🗂️
  - Row-oriented: “한 사람의 모든 정보가 한 파일에 묶여 있음” → 빠른 개인 조회
  - Column-oriented: “전 국민의 나이만 모아둔 파일, 소득만 모아둔 파일” → 통계 계산 초고속

# 🔖 Star Schema와 Columnar Storage의 연결고리

"Star Table"이라 하셨는데, 보통 **Star Schema(스타 스키마)**를 의미하시는 것 같습니다. 이 둘은 **"논리적 설계(Star Schema)"**와 **"물리적 구현(Columnar Storage)"**의 찰떡궁합 관계입니다.

### 1. Star Schema란? (논리적 설계)

데이터 분석(OLAP)을 위해 테이블을 두 종류로 찢어놓은 구조입니다.

- **Fact Table (사실 테이블)**: 사건의 기록 (예: 주문 내역, 클릭 로그). 엄청나게 깁니다(수억 건). 대신 컬럼은 ID들과 수치값 위주입니다.
- **Dimension Table (차원 테이블)**: `Fact Table`의 ID가 가리키는 상세 정보 (예: 상품명, 고객 주소). 상대적으로 작습니다.

가운데 Fact Table이 있고, 주변에 Dimension Table들이 별(Star)처럼 붙어 있다고 해서 Star Schema입니다.

### 2. 왜 둘이 찰떡궁합인가?

**Fact Table은 "아주 넓고(컬럼 많음), 아주 깁니다(행 많음)."**
보통 분석 쿼리는 이런 식입니다:

> "작년(Date) 1월에 판매된(Fact) 상품별(Product) 총 매출액(Sales Amount)은?"

이때 **Columnar Storage**가 빛을 발합니다.

1.  **필요한 컬럼만 로딩**:

    - Star Schema의 Fact Table에는 `date_id`, `product_id`, `store_id`, `customer_id`, `quantity`, `amount` 등 컬럼이 100개 있을 수 있습니다.
    - 하지만 위 질문에 답하려면 `date_id`, `product_id`, `amount` **딱 3개 컬럼만** 읽으면 됩니다.
    - **Row-oriented**라면 100개 컬럼을 다 읽어서 메모리에 올려야 하지만, **Columnar**는 3개만 쏙 뽑아옵니다. (IO 대폭 감소)

2.  **압축 효율 (비트맵 인덱스 등)**:
    - Fact Table의 `store_id` 컬럼을 보면, 같은 매장 ID가 수천 번 반복해서 나옵니다.
    - Columnar Storage는 같은 값이 연속될 때 압축하기가 매우 좋습니다 (Run-length encoding 등).
    - Star Schema의 외래 키(FK) 컬럼들은 중복이 많아 압축률이 비약적으로 높습니다.

### 3. 요약

- **Star Schema**: "분석하기 좋게 데이터를 쪼개놓자!" (설계도)
- **Columnar Storage**: "쪼개놓은 거 빠르게 읽으려면 세로로 저장하자!" (건축법)
- **결과**: Star Schema로 모델링된 데이터 웨어하우스에서 Columnar Storage를 쓰면, 수억 건 데이터 집계가 순식간에 끝납니다.
