# 📘 데이터 중심 애플리케이션 설계

## Chapter 3. 저장소와 검색 

---

## 1. 이 장에서 다루는 핵심 질문

- 데이터베이스는 데이터를 **어떻게 저장하는가**
- 요청이 왔을 때 데이터를 **어떻게 빠르게 찾는가**
- 그리고 개발자가 **왜 저장소 엔진의 내부를 이해해야 하는가**

개발자는 저장소 엔진을 직접 구현하지 않지만,  
애플리케이션의 **워크로드 특성(읽기/쓰기 비율, 범위 질의, 분석 여부)** 에 따라  
적절한 저장소 엔진을 선택하고 조정해야 한다.  
이를 위해 저장과 검색의 내부 원리에 대한 개념적 이해가 필요하다.

---

## 2. 저장과 검색의 기본 구조

### 로그 기반 저장 (Append-only Log)

- 많은 데이터베이스는 데이터를 **기존 데이터를 수정하지 않고 파일 끝에 추가**하는 로그 구조를 사용한다.
- 장점: 순차 쓰기 기반으로 **쓰기 성능이 매우 좋다**.
- 문제점: 데이터가 많아질수록 특정 값을 찾기 위해 **전체 로그를 스캔해야 하므로 읽기 성능이 급격히 저하**된다.

→ 이 문제를 해결하기 위해 **색인(Index)** 이 필요하다.

---

## 3. 색인(Index)의 본질

- 색인은 데이터 자체가 아니라 **데이터 위치를 가리키는 메타데이터 구조**다.
- 목적은 전체 데이터를 읽지 않고도 원하는 데이터를 빠르게 찾는 것이다.

### 색인의 트레이드오프
- 읽기 성능은 향상된다.
- 쓰기 시마다 색인도 함께 갱신해야 하므로 쓰기 성능은 저하된다.

→ 따라서 모든 데이터를 자동으로 색인하지 않고, 애플리케이션에 중요한 접근 패턴만 색인한다.

---

## 4. 해시 색인 (Hash Index)

### 핵심 아이디어
- `Key → 데이터가 저장된 파일의 위치(Offset)` 를  
  **인메모리 해시 맵**에 저장한다.

### 특징
- 키를 알고 있다면 디스크 접근 한 번으로 데이터 조회 가능
- 읽기와 쓰기가 매우 빠름 (예: Bitcask)

### 한계
- 모든 키를 메모리에 유지해야 함 → 키가 많으면 사용 불가
- 범위 질의 불가능 (`100 ~ 200` 같은 검색 불가)

→ **고유 키 수는 적고, 값 갱신이 잦은 워크로드**에 적합하다.

---

## 5. SS테이블과 LSM 트리

### SS테이블 (Sorted String Table)

- 키 기준으로 **정렬된 상태로 저장된 로그 파일**
- 장점
    - 모든 키를 메모리에 유지할 필요 없음
    - 범위 질의 가능
    - 압축 효율이 좋음

### LSM 트리 (Log-Structured Merge Tree)

- 구조
    - 쓰기: 인메모리 정렬 구조(MemTable)에 먼저 기록
    - 일정 크기 도달 시 디스크의 SS테이블로 flush
    - 백그라운드에서 지속적인 병합(compaction) 수행

- 특징
    - 쓰기 처리량이 매우 높음
    - 데이터가 메모리보다 훨씬 커도 처리 가능

- 단점
    - 읽기 시 여러 SS테이블을 확인해야 함
    - 컴팩션이 읽기/쓰기 지연을 유발할 수 있음

---

## 6. B-트리 (B-Tree)

- 가장 오래되고 가장 널리 사용되는 색인 구조
- 대부분의 관계형 데이터베이스의 기본 색인

### 특징
- 고정 크기 페이지 단위로 데이터 관리
- 제자리 갱신(update-in-place) 방식
- 키 검색과 범위 질의 모두 효율적
- 성능이 안정적이고 예측 가능함

### 단점
- 랜덤 쓰기 비용이 큼
- 페이지 분할 시 동시성 제어와 복구가 복잡함
- 쓰기 성능은 LSM 트리보다 불리한 경우가 많음

---

## 7. LSM 트리 vs B-트리 요약 비교

| 구분 | LSM 트리 | B-트리 |
|---|---|---|
| 쓰기 성능 | 매우 좋음 | 보통 |
| 읽기 성능 | 느릴 수 있음 | 빠르고 안정적 |
| 범위 질의 | 가능 | 가능 |
| 구조 | 로그 기반, 병합 중심 | 페이지 기반, 제자리 갱신 |
| 대표 사용처 | NoSQL, 대용량 쓰기 | RDBMS, 트랜잭션 중심 |


---

## 8. OLTP vs OLAP

### OLTP (온라인 트랜잭션 처리)
- 소수의 레코드를 빠르게 읽고 씀
- 사용자 대면 서비스
- 색인 중심 접근
- 병목: 디스크 탐색(latency)

### OLAP (온라인 분석 처리)
- 대량의 레코드를 스캔
- 집계·통계 중심
- 병목: 디스크 대역폭

---

## 9. 칼럼 지향 저장소 (Column-Oriented Storage)

### 핵심 아이디어
- 로우 단위가 아니라 **칼럼 단위로 저장**
- 질의에 필요한 칼럼만 디스크에서 읽음

### 장점
- 디스크 I/O 감소
- 압축 효율이 매우 높음
- 대규모 분석 질의에 최적

### 단점
- 쓰기·갱신 비용이 큼
- OLTP에는 부적합

→ 데이터 웨어하우스에서 표준적으로 사용된다.

---

## 10. 한 줄 정리

이 장은 데이터베이스 저장소 엔진을 **쓰기 최적화(로그 구조)** 와 **읽기 최적화(색인 구조)**,  
그리고 **트랜잭션 처리(OLTP)** 와 **분석 처리(OLAP)** 라는 큰 관점에서 이해하도록 돕는 장이다.
