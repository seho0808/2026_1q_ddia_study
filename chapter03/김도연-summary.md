# 데이터베이스를 강력하게 만드는 데이터 구조

데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요하다.

바로 **색인**이다. 색인은 기본 데이터에서 파생된 **추가적인** 구조다.

어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만든다. 이는 데이터를 쓸 때마다 매번 색인도 갱신해야 하기 때문이다. 필요 이상으로 오버헤드를 발생시키지 않으면서 애플리케이션에 가장 큰 이익을 안겨주는 색인을 선택해야 한다.

### 해시 색인

- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다.
- 해시 테이블은 범위 질의(range query)에 효율적이지 않다.

### SS테이블과 LSM트리

- SS테이블: 세그먼트 파일 내부가 키로 정렬된 형식
    - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다.
- LSM트리: 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것이다.

### SS테이블 생성과 유지

- 쓰기가 들어오면 인메모리 균형 트리 데이터 구조에 추가한다. 이 인메모리 트리는 **멤테이블**이라고도 한다.

만약 데이터베이스가 고장나면 아직 디스크로 기록되지 않고 멤테이블에 있는 가장 최신 쓰기는 손실된다.

이런 문제를 피하기 위해서는 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야 한다. 이 로그는 손상 후 멤테이블을 복원할 때만 필요하기 때문에 순서가 정렬되지 않아도 문제되지 않는다.

### SS테이블에서 LSM트리 만들기

### 성능 최적화

- 레벨 컴팩션 - LevelDB, RocksDB
- 크기 계층 컴팩션 - HBase

### B트리

B트리는 SS테이블과 같이 키로 정렬된 키-값 쌍을 유지하기 때문에 키-값 검색과 범위 질의에 효율적이다.

로그 구조화 색인은 데이터베이스를 일반적으로 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록한다. 반면 B 트리는 전통적으로 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다.

### 신뢰할 수 있는 B트리 만들기

- WAL(write-ahead log/쓰기 전 로그): 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경사항을 기록하는 추가 전용 파일이다. 이 로그는 데이터베이스가 고장 이후 복구될 때 일관성 있는 상태로 B트리를 다시 복원하는 데 사용된다.
- 동시성 제어는 보통 latch로 트리의 데이터 구조를 보호한다.

### B트리 최적화

- WAL 대신 쓰기 시 복사방식(copy-on-write scheme)
- 페이지 하나에 키를 더 많이 채우면 트리는 더 높은 분기 계수를 얻는다. 그러면 트리 깊이 수준을 낮출 수 있다.
- 트리에 포인터를 추가
    - 질의가 정렬된 순서로 키 범위의 상당 부분을 스캔해야 한다면 모든 페이지에 대해 디스크 찾기가 필요하기 때문에 페이지 단위 배치는 비효율적이다(random IO). 따라서 많은 B 트리 구현에서 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도한다. 하지만 트리가 커지면 순서를 유지하기 어렵다. 반대로 LSM 트리는 병합하는 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기가 더 쉽다.
- 프랙탈 트리(fractal tree)

### B트리와 LSM트리 비교

LSM트리는 보통 쓰기에서 더 빠른 반면 B트리는 읽기에서 더 빠르다. 읽기가 보통 LSM트리에서 더 느린 이유는 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS테이블을 확인해야 하기 때문이다.

### LSM트리의 장점

- 보통 B 트리보다 쓰기 처리량을 높게 유지할 수 있다.
- LSM트리는 압축률이 더 좋다. (leveled compaction)

→ 낮은 쓰기 증폭과 파편화 감소

### LSM트리의 단점

- 컴팩션 과정이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다.
- 쓰기 처리량이 높음에도 컴팩션 설정을 주의 깊게 하지 않으면 컴팩션이 유입 쓰기 속도를 따라갈 수 없다.

### 기타 색인 구조

- 보조 색인

### 색인 안에 값 저장하기

- 클러스터드 색인
- 커버링 색인

### 다중 칼럼 색인

- 결합 색인

### 전문 검색와 퍼지 색인

- 루씬에서 인메모리 색인은 여러 키 내 문자에 대한 유한 상태 오토마톤으로 트라이(trie)와 유사하다.

### 모든 것을 메모리에 보관

- 지속성을 목표로 하는 인메모리 데이터베이스
    - 디스크에 변경 사항의 로그를 기록
    - 디스크에 주기적인 스냅샷을 기록
    - 다른 장비에 인메모리 상태를 복제
    

# 트랜잭션 처리나 분석

- 데이터 웨어하우스: 분석 목적으로 사용하는 개별 데이터베이스.

OLTP 시스템은 대개 사업 운영에 대단히 중요하기 때문에 일반적으로 높은 가용성과 낮은 지연 시간의 트랜잭션 처리를 기대한다. 

분석 질의는 데이터셋의 많은 부분을 스캔해 이와 동시에 실행되는 트랜잭션의 성능을 저하시킬 가능성이 있다.

OLTP 들 → 데이터 웨어하우스(OLAP) (ETL)

### 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마

- 사실 테이블
- 차원 테이블

> 사실 테이블의 각 로우는 이벤트를 나타내고 차원은 이벤트의 속성인 누가, 언제, 어디서, 무엇을, 어떻게, 왜를 나타낸다.
> 
- 눈꽃송이 모양 스키마: 별 모양 스키마가 더욱 세분화 된것. (정규화)

# 칼럼 지향 저장소

> 모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼 별로 모든 값을 함께 저장한다.
> 

대부분의 OLTP 데이터베이스에서 저장소는 로우 지향 방식으로 데이터를 배치한다. 하지만 데이터 웨어하우스의 질의는 수많은 칼럼 중 일부 칼럼에만 접근하는 경우가 많다.

### 칼럼 압축

- 비트맵 부호화

### 메모리 대역폭과 벡터화 처리

분석용 데이터베이스 개발자는 메인 메모리에서 CPU 캐시로 가는 대역폭을 효율적으로 사용하고 CPU 명령 처리 파이프라인에서 분기 예측 실패와 버블을 피하며 최신 CPU에서 단일 명령 다중 데이터 명령을 사용하게끔 신경 써야 한다.

디스크로부터 적재할 데이터 양 줄이기 외에도 컬럼 저장소 배치는 CPU 주기를 효율적으로 사용하기 적합하다. 예를 들어 질의 엔진은 압축된 칼럼 데이터를 CPU의 L1 캐시에 딱 맞게 덩어리로 나누어 가져오고 이 작업을 (함수 호출이 없는) 타이트 루프에서 반복한다. CPU는 함수 호출이 많이 필요한 코드나 각 레코드 처리를 위해 분기가 필요한 코드보다 타이트 루프를 훨씬 빨리 실행할 수 있다.

### 컬럼 저장소 (OLAP 스타일)

```
salary: [100, 120, 90, 110, ...]

```

- 필요한 컬럼만 읽음
- 메모리에 **연속된 배열**
- CPU가 좋아하는 구조 그 자체

---

**“압축된 컬럼 데이터를 L1 캐시에 딱 맞게”의 의미**

> 압축된 칼럼 데이터를 CPU의 L1 캐시에 딱 맞게 덩어리로 나눈다
> 
- L1 캐시: 보통 **32KB~64KB**
- 컬럼 데이터 압축:
    - int → dictionary encoding
    - RLE, bit-packing 등
- 결과:
    - **수천~수만 개 값이 L1 캐시에 들어감**

CPU는:

1. L1 캐시에서 데이터 읽고
2. tight loop로
3. SIMD 연산으로
4. 분기 없이 계산

→ **CPU 사용률 거의 100%**

### 칼럼 저장소의 순서 정렬

### 칼럼 지향 저장소에 쓰기

# 정리

- OLTP 시스템은 보통 사용자 대면이기 때문에 대량의 요청을 받을 수 있다. 부하를 처리하기 위해 보통 애플리케이션이 각 질의마다 적은 수의 레코드만 다룬다. 애플리케이션은 키의 일부만 사용하는 레코드를 요청하고 저장소 엔진은 요청한 키의 데이터를 찾기위해 색인을 사용한다. 이 경우는 대개 디스크 탐색이 병목이다.
    - 로그 구조화 관점에서 파일에 추가와 오래된 파일의 삭제만 허용하고 한 번 쓰인 파일은 절대 갱신하지 않는다. 비트캐스크, SS 테이블, 레벨DB, 카산드라, HBase, 루씬 등이 이 그룹에 속한다.
    - 제자리 갱신 관점에서 덮어쓰기 할 수 있는 고정 크기 페이지의 셋으로 디스크를 다룬다. 이 관점에서 가장 큰 예가 B 트리다. B 트리는 모든 주요 관계형 데이터베이스와 많은 비정형 데이터베이스에서도 사용한다.
- 데이터 웨어하우스와 유사한 분석 시스템은 최종 사용자가 아닌 비즈니스 분석가가 주로 사용하기 때문에 덜 알려져 있다. OLTP시스템보다 훨씬 적은 수의 질의를 다루지만 각 질의는 대개 매우 다루기 어렵고 짧은 시간에 수백만 개의 레코드를 스캔해야 한다. 이 경우는 일반적으로 디스크 대역폭이 병목이다. 칼럼 지향 저장소는 이런 종류의 작업 부하를 처리할 때 사용 가능한 날로 인기가 높아지고 있는 솔루션이다.
