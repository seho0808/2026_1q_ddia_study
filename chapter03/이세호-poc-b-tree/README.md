## btree는 lsmtree보다 원래 압도적으로 간단한가? 엄청 간단해보이네 손구현해보니까

**"구현의 깊이(Depth)"에 따라 체감이 완전히 달라지는 대표적인 케이스**입니다.

결론부터 말씀드리면, **PoC 수준에서는 B-Tree가 더 간단하게 느껴질 수 있지만, 상용 수준(Production Level)으로 가면 B-Tree가 훨씬 어렵습니다.**

작성하신 코드가 간단해 보이는 이유는 **"가장 어렵고 까다로운 부분들"을 생략**했기 때문입니다. 반면 LSM-Tree는 기본 구조를 잡는 데 필요한 부품(MemTable, SSTable, WAL, Compaction)이 많아서 초기 진입 장벽이 높아 보였을 것입니다.

왜 B-Tree가 실제로는 "악마의 구현"이라고 불리는지, PoC와 실제 구현의 차이를 비교해 드릴게요.

### 1. B-Tree 구현이 "간단해 보이는" 착시의 이유

작성하신 PoC에서 빠진(혹은 간소화된) 핵심 난제들입니다.

#### A. 삭제(Deletion)와 재균형(Rebalancing) - **최고 난이도**

- **PoC:** 삭제 기능이 없습니다. (삽입만 구현함)
- **실제:** B-Tree의 진정한 공포는 **삭제**에서 옵니다.
  - 노드에서 키를 지웠을 때 `최소 키 개수(Underflow)`보다 적어지면?
  - 옆 형제 노드에서 키를 빌려와야 합니다 (**Rotation**).
  - 형제도 부족하면 두 노드를 합쳐야 합니다 (**Merge**).
  - 합치면 부모 노드의 키 하나가 내려와야 하고, 그럼 부모도 Underflow가 발생할 수 있어서 **연쇄적으로 트리를 타고 올라가며 수선**해야 합니다.
  - 이 로직을 버그 없이 짜는 게 정말 어렵습니다.

#### B. 가변 길이 데이터 (Variable Length)

- **PoC:** `KEY_SIZE = 16`, `VALUE_SIZE = 64`로 고정했습니다. 오프셋 계산이 너무 쉽습니다.
- **실제:** 실제 DB는 문자열 길이가 제각각입니다.
  - 페이지 내에서 빈 공간을 관리하기 위해 **Slotted Page** 구조를 써야 합니다.
  - 데이터를 지우면 페이지 중간에 구멍(Fragmentation)이 생기는데, 이걸 메꾸는 **Defragmentation** 로직도 필요합니다.

#### C. 동시성 제어 (Concurrency Control)

- **PoC:** 싱글 스레드입니다.
- **실제:** 멀티 스레드 환경에서 B-Tree를 쓴다면?
  - Root부터 타고 내려오면서 **Latch(Lock)**를 걸어야 합니다.
  - 부모 노드에 Read Lock을 걸고 자식으로 갔는데, 자식이 꽉 차서 분할(Split)해야 한다면? 다시 부모의 Write Lock이 필요합니다. (**Latch Crabbing** 문제)
  - 이 과정에서 Deadlock이 발생하기 쉽습니다.

#### D. WAL (Write Ahead Log) 및 복구

- **PoC:** `Pager`가 파일에 직접 씁니다. 쓰다가 전원이 나가면 페이지가 깨질 수 있습니다. (Partial Page Write)
- **실제:** B-Tree는 랜덤 쓰기가 발생하므로, 안전성을 위해 변경 사항을 WAL에 먼저 적고, 체크포인트를 관리해야 합니다. (LSM-Tree PoC에서는 WAL을 구현하셨었죠!)

---

### 2. LSM-Tree vs B-Tree 복잡도 비교

| 특성          | B-Tree (Update-in-place)                       | LSM-Tree (Log-structured)                                 |
| :------------ | :--------------------------------------------- | :-------------------------------------------------------- |
| **핵심 철학** | "질서 정연하게 제자리에 정리해두자"            | "일단 쓰고 나중에 정리하자"                               |
| **초기 구현** | 쉬움 (삽입만 한다면)                           | **어려움** (MemTable, SSTable, Compaction 등 부품이 많음) |
| **심화 구현** | **매우 어려움** (삭제, 페이지 관리, 락킹)      | 상대적으로 쉬움 (불변 파일 관리, 병합 정렬)               |
| **쓰기 패턴** | **Random Write** (느림, 디스크 헤드 이동 많음) | **Sequential Write** (빠름, Append only)                  |
| **동시성**    | 복잡함 (노드 단위 락 관리)                     | 단순함 (MemTable만 락 걸고 SSTable은 불변이라 락 불필요)  |

### 3. 요약

> **"LSM-Tree는 부품이 많아서 조립하기 귀찮은 레고 세트라면, B-Tree는 깎아야 할 게 많은 조각상입니다."**

- **LSM-Tree**: 구조적으로 챙길 컴포넌트(MemTable, BloomFilter, Compaction 등)가 많아서 **초반 코드량이 많습니다.** 하지만 각 컴포넌트의 로직(단순 추가, 정렬된 리스트 병합) 자체는 단순합니다.
- **B-Tree**: 노드와 포인터라는 하나의 자료구조만 다루면 되어서 **간단해 보입니다.** 하지만 그 안에서 일어나는 상태 변화(Split, Merge, Rotate)의 **알고리즘적 복잡도(Edge Case)**가 훨씬 높습니다.

만약 `delete` 함수를 구현하기 시작하신다면 "아, B-Tree가 쉬운 게 아니었구나"라고 바로 느끼실 겁니다... 😅

## 그래도 딱 트리하나에만 매달린다는점에서는 간단해보이긴하네

정확한 통찰이십니다! **"구조적(Architectural) 관점"**에서는 B-Tree가 LSM-Tree보다 훨씬 깔끔하고 심플합니다.

이 차이를 **"도서관 정리"**에 비유하면 느낌이 확 옵니다.

### 1. B-Tree: "강박적인 사서" (하나의 거대한 트리)

- **방식:** 책이 반납되면, **즉시** 서가로 달려가서 가나다순에 딱 맞는 위치에 꽂아 넣습니다.
- **장점 (구조적 단순함):**
  - **Single Source of Truth:** 데이터는 오직 저 서가(Tree) 한 곳에만 있습니다.
  - **예측 가능성:** 책을 찾을 때 어디를 봐야 할지 명확합니다. 여기 없으면 없는 겁니다.
  - **관리 포인트:** "서가" 하나만 잘 관리하면 됩니다. (LSM처럼 MemTable, SSTable, Compaction... 이런 거 신경 안 써도 됨)
- **단점:**
  - 책 한 권 꽂으려고 거대한 서가의 책들을 옆으로 밀어내야 합니다(Random I/O, Node Split).
  - 여러 사서가 동시에 한 서가에 달려들면 서로 비켜달라고 싸움이 납니다(Lock Contention).

### 2. LSM-Tree: "일단 쌓아두는 사서" (여러 개의 파편화된 파일)

- **방식:** 책이 반납되면 일단 **책상 위(MemTable)**에 쌓아둡니다. 책상이 꽉 차면 **박스(SSTable)**에 담아 창고에 던져둡니다. 나중에 시간 날 때 박스들을 정리(Compaction)합니다.
- **장점:**
  - 반납 처리가 엄청 빠릅니다. (Write Optimized)
  - 박스는 테이프로 밀봉(Immutable)했으니 건드릴 일이 없어 락(Lock) 걱정이 덜합니다.
- **단점 (구조적 복잡함):**
  - 책을 찾으려면 책상(MemTable)도 보고, 최근 박스(L0), 옛날 박스(L1)... 다 뒤져야 합니다.
  - 백그라운드에서 계속 박스 정리(Compaction)를 해줘야 해서 시스템이 복잡해집니다.

---

### 결론: "한 놈만 팬다" vs "나눠서 팬다"

님 말씀대로 **B-Tree는 "하나의 완벽한 구조체"**를 유지하는 철학이라, 시스템 전체 아키텍처를 그릴 때는 화살표가 단순합니다.
(App -> **B-Tree** -> Disk)

반면 **LSM-Tree**는 아키텍처 그림을 그리면 복잡해지죠.
(App -> **WAL** -> **MemTable** -> Flush -> **SSTable L0** -> Compaction -> **SSTable L1**...)

그래서 **"읽기 성능이 중요하고, 구조를 단순하게 가져가고 싶다"**면 B-Tree가 여전히 최고의 선택입니다. (PostgreSQL, MySQL, Oracle이 B-Tree를 놓지 못하는 이유입니다.)
