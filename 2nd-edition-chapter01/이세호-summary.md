# 2판 chapter 1 요약

## 1. 데이터 중심 애플리케이션이란?

- **정의:** CPU 연산 능력보다 **데이터의 양, 복잡성, 변화 속도**가 주요 과제인 애플리케이션을 의미합니다.
- **특징:** 단순히 데이터를 저장하는 것을 넘어, 대규모 데이터를 처리하고 정합성을 유지하며, 장애 상황에서도 지속적인 서비스를 제공해야 합니다.

## 2. 주요 구성 요소 (빌딩 블록)

데이터 중심 애플리케이션은 보통 다음 기능을 조합하여 구축합니다.

- **데이터베이스:** 데이터 저장 및 검색
- **캐시:** 읽기 속도 향상을 위한 결과 저장 (값 비싼 연산 결과 등)
- **검색 색인:** 키워드 검색 및 필터링
- **스트림 처리:** 실시간 데이터 처리 (비동기 처리)
- **배치 처리:** 대량의 누적 데이터 주기적 처리

## 3. 핵심 과제와 이 책의 목표

- **어려움:** 수많은 데이터 시스템(DB, 큐 등) 중 어떤 것을 선택하고 어떻게 조합할지 결정하는 것은 복잡하며, 모든 상황에 맞는 "만능 솔루션"은 없습니다.
- **목표:** 각 기술의 **장단점(Trade-off)**을 이해하고, 애플리케이션 요구사항에 가장 적합한 아키텍처를 결정할 수 있도록 돕는 가이드입니다.

## 4. 이 장에서 다룰 주요 논의

- 운영(Operational) 시스템 vs 분석(Analytical) 시스템
- 클라우드 vs 자체 호스팅
- 단일 노드 vs 분산 시스템
- 비즈니스 요구 vs 사용자 권리 및 법적 문제
- **초점:** 주로 **백엔드(Backend)** 데이터 인프라의 아키텍처와 원리를 다룹니다.

## 5. 운영 시스템 vs 분석 시스템 (Operational Versus Analytical Systems)

- **시스템의 이원화:**
  - **운영 시스템 (Operational):** 외부 사용자 트래픽 처리, 데이터 생성/수정 (백엔드 엔지니어 영역).
  - **분석 시스템 (Analytical):** 운영 데이터의 읽기 전용 복제본, 비즈니스 의사결정 및 인사이트 도출 (데이터 분석가/과학자 영역).
- **데이터 엔지니어링:** 이 두 시스템을 연결하고 통합하는 역할(Data Engineer, Analytics Engineer)이 중요해짐.

## 6. 트랜잭션 처리(OLTP)와 분석 처리(OLAP)의 특성

- **OLTP (Online Transaction Processing):**
  - **목적:** 사용자 대면 서비스의 대화형(Interactive) 처리.
  - **패턴:** 키를 통한 소량 데이터 조회(Point Query) 및 수정.
  - **데이터:** 현재 시점의 최신 상태, GB~TB 단위.
- **OLAP (Online Analytic Processing):**
  - **목적:** 비즈니스 인텔리전스(BI), 의사결정 지원.
  - **패턴:** 대량의 레코드를 스캔하여 통계(합계, 평균 등) 집계.
  - **데이터:** 과거 이력 포함, TB~PB 단위.
- **실시간 분석 (Real-time Analytics / Product Analytics):**
  - **특징:** 분석적 쿼리(집계)를 수행하지만, 사용자 대면 제품에 포함되어 **낮은 지연 시간(Low-latency)**이 요구됨.
  - **도구:** Pinot, Druid, ClickHouse 등.

## 7. 데이터 웨어하우징 (Data Warehousing)

- **배경 및 필요성:**
  - 초기에는 OLTP 시스템에서 분석도 수행했으나, 1980년대 후반부터 분석 전용 데이터베이스인 **데이터 웨어하우스**를 분리하여 사용하기 시작함.
  - **분리 이유:**
    1. **데이터 사일로(Data Silos):** 관심 데이터가 여러 OLTP 시스템에 분산되어 있어 통합 쿼리가 어려움.
    2. **스키마 차이:** OLTP에 최적화된 스키마는 분석에 적합하지 않음.
    3. **성능 영향:** 분석 쿼리는 비용이 높아 OLTP 서비스 성능 저하를 유발함.
    4. **보안/접근 제어:** 보안상의 이유로 분석가에게 OLTP 시스템 직접 접근 권한을 주지 않음.
- **ETL (Extract-Transform-Load):**
  - OLTP 시스템(또는 SaaS API)에서 데이터를 추출(Extract)하고, 분석에 적합한 스키마로 변환/정제(Transform)하여, 데이터 웨어하우스에 적재(Load)하는 과정.
  - 변환을 적재 후에 수행하는 **ELT** 방식도 존재.
  - SaaS API(CRM 등) 데이터 통합을 위해 Fivetran, AirByte 같은 전문 도구 사용.
- **HTAP (Hybrid Transactional/Analytic Processing):**
  - OLTP와 분석을 단일 시스템에서 처리하려는 시도.
  - 하지만 여전히 시스템 내부적으로는 분리되어 있거나, 기업 전체 통합 분석(웨어하우스)과는 별개로 특정 앱의 실시간 분석 요구사항(예: 사기 탐지)에 주로 사용됨.

## 8. 데이터 레이크 (Data Lake)

- **등장 배경:**
  - 데이터 웨어하우스(SQL 기반 관계형 모델)는 비즈니스 분석가에게는 좋지만, 데이터 과학자에게는 제한적임.
  - 데이터 과학자는 머신러닝을 위한 피처 엔지니어링, 비정형 데이터(텍스트, 이미지 등) 처리, Python/R 기반 분석 등을 선호함.
- **정의 및 특징:**
  - **정의:** 특정 형식이나 스키마를 강제하지 않고 모든 데이터를 파일 형태로 저장하는 중앙 저장소.
  - **데이터 유형:** 구조화된 DB 레코드뿐만 아니라 텍스트, 이미지, 센서 데이터 등 모든 형태 수용 가능.
  - **장점:** 유연성이 높고, 저렴한 객체 스토리지(Object Store) 활용 가능.
  - **스시 원칙(Sushi Principle):** "Raw data is better" - 각 소비자가 자신의 필요에 맞게 원시 데이터를 가공해서 사용.

## 9. 데이터 레이크 그 이후 (Beyond the Data Lake)

- **DataOps 및 거버넌스:** 데이터 파이프라인 관리, 운영, 개인정보 보호(GDPR/CCPA) 준수의 중요성 증대.
- **스트림 처리:** 파일 기반 배치 처리(일 단위)를 넘어, 이벤트 스트림을 통해 실시간(초 단위)으로 데이터 변화에 대응 (예: 실시간 사기 탐지).
- **Reverse ETL:** 분석 시스템의 결과(예: ML 추천 모델 등)를 다시 운영 시스템으로 보내 사용자 서비스에 활용.

## 10. 레코드 시스템과 파생 데이터 (Systems of Record and Derived Data)

- **시스템의 구분:** 데이터 흐름을 명확히 하기 위해 두 가지로 구분합니다.
  - **레코드 시스템 (System of Record, Source of Truth):**
    - **정의:** 데이터의 **권위 있는(authoritative) 정본**을 보유한 시스템.
    - **특징:** 새로운 데이터가 가장 먼저 기록되며, 일반적으로 정규화되어 각 사실(fact)을 한 번만 표현함. 다른 시스템과 불일치 시 이곳의 데이터가 정답.
  - **파생 데이터 시스템 (Derived Data Systems):**
    - **정의:** 다른 시스템의 데이터를 변환하거나 처리한 결과를 저장하는 시스템.
    - **특징:** 원본 데이터가 있다면 언제든 다시 생성 가능. (예: 캐시, 검색 색인, 구체화된 뷰, 머신러닝 모델 등)
    - **목적:** 읽기 성능 향상 및 다양한 관점에서의 데이터 조회를 위해 필수적 (기술적으로는 중복 데이터).
- **관계 및 아키텍처:**
  - **운영 시스템:** 레코드 시스템(기본 DB)과 파생 데이터 시스템(캐시, 색인)이 혼재됨.
  - **분석 시스템:** 대부분 다른 곳에서 생성된 데이터를 소비하므로 파생 데이터 시스템에 속함.
  - **중요성:** 어떤 데이터가 어디서 파생되었는지 명확히 하는 것이 복잡한 아키텍처를 이해하는 열쇠임. 원본 데이터 변경 시 파생 데이터를 업데이트하는 동기화 과정(데이터 파이프라인)이 필요함.

## 11. 클라우드 vs 자체 호스팅 (Cloud Versus Self-Hosting)

- **의사결정 기준:** "직접 구축(Build)할 것인가, 구매(Buy)할 것인가?"는 비즈니스 우선순위 문제.
  - **핵심 역량(Core Competency):** 조직의 경쟁 우위가 되는 부분은 **직접(In-house)** 수행.
  - **비핵심/일상적 업무:** 외부 벤더에 위임 (SaaS 등).
- **소프트웨어 운영 스펙트럼:**
  1. **자체 개발 (Bespoke):** 직접 작성하고 운영.
  2. **자체 호스팅 (Self-Hosted):** 상용/오픈소스 소프트웨어(MySQL 등)를 직접 설치하여 운영 (온프레미스 또는 클라우드 VM).
  3. **SaaS/클라우드 서비스:** 외부 벤더가 구현 및 운영하며 API로만 접근.
- **클라우드 서비스의 장단점:**
  - **장점:**
    - 구축 속도가 빠르고 초기 설정이 간편함.
    - 전문 운영 인력 비용 절감 및 운영 부담 감소.
    - **가변적인 부하(Variable Load)** 대응에 유리 (사용량에 따른 탄력적 스케일링으로 비용 절감).
    - 대규모 데이터 분석 등 일시적으로 많은 자원이 필요한 경우 효율적.
  - **단점:**
    - **통제권 부재:** 필요한 기능 추가 요청만 가능, 장애 시 복구 대기.
    - **블랙박스:** 내부 동작 확인이 어려워 버그나 성능 문제 진단이 힘듦.
    - **벤더 종속 (Vendor Lock-in):** 서비스 중단, 가격 인상, 변경 등에 취약하며 이전 비용이 큼.
    - **보안/규정 준수:** 데이터 보안 및 프라이버시 규정 준수 절차가 복잡해질 수 있음.
  - **비용:** 기술력이 있고 부하가 예측 가능한 경우(Predictable Load)에는 자체 호스팅이 더 저렴할 수 있음.

## 12. 클라우드 네이티브 시스템 아키텍처 (Cloud-Native System Architecture)

- **정의:** 클라우드 서비스의 이점(탄력성, 확장성 등)을 최대한 활용하도록 처음부터 설계된 아키텍처.
- **자체 호스팅 vs 클라우드 네이티브 비교:**
  - **자체 호스팅 시스템:** 일반적인 OS(파일시스템, TCP/IP 등) 위에서 실행되도록 설계됨. 클라우드 VM에서도 실행 가능하지만 관리 책임은 사용자에게 있음.
  - **클라우드 네이티브 시스템:** 하위 레벨의 클라우드 서비스(객체 스토리지 등)를 적극 활용하여 상위 레벨 서비스를 구축. (예: Snowflake는 S3를 저장소로 사용).
- **주요 특징:**
  1. **저장소와 연산의 분리 (Separation of Storage and Compute):**
     - 전통적 시스템은 동일 머신에 디스크와 CPU가 결합됨.
     - 클라우드 네이티브는 로컬 디스크를 임시 캐시로 취급하고, 데이터는 S3 같은 별도 저장소 서비스에 보관.
     - 데이터 저장은 객체 스토리지(S3 등)가 담당하고, 연산은 별도 인스턴스에서 수행하여 각각 독립적으로 확장 가능.
  2. **가상 디스크 대신 객체 스토리지 활용:**
     - 가상 디스크(EBS 등)는 네트워크 오버헤드가 있고 인스턴스 종속적임.
     - 클라우드 네이티브 DB는 대규모 데이터를 객체 스토리지에 저장하고, 메타데이터나 소규모 값만 별도 관리하여 효율성 증대.
  3. **멀티 테넌시 (Multitenancy):** 공유 하드웨어에서 여러 고객의 데이터와 연산을 처리하여 자원 효율성 및 관리 용이성 확보 (단, 성능/보안 격리 필요).

## 13. 클라우드 시대의 운영 (Operations in the Cloud Era)

- **운영 역할의 변화:**
  - 과거: DBA, 시스템 관리자가 개별 머신의 용량 계획, 패치, 설치 담당.
  - 현재: DevOps, SRE(Site Reliability Engineering) 철학 확산.
  - **변화:** 개별 머신 관리 -> **서비스 안정성 및 자동화**로 초점 이동.
- **클라우드 환경에서의 운영:**
  - **인프라 기업(클라우드 벤더):** 대규모 하드웨어 및 서비스 신뢰성 관리에 집중.
  - **고객(사용자):** 인프라 관리 부담은 줄었으나, **적절한 서비스 선택, 통합, 비용 최적화(FinOps)**가 새로운 운영 과제가 됨.
  - **자동화 강조:** 수동 작업 대신 반복 가능한 프로세스, 코드 기반 인프라 관리 선호.
  - **여전한 필요성:** 보안 유지, 서비스 간 통합, 성능 모니터링, 장애 원인 파악 등은 여전히 고객의 운영 팀이 수행해야 할 몫임.

## 14. 분산 시스템 vs 단일 노드 (Distributed Versus Single-Node Systems)

- **분산 시스템의 필요성 (왜 사용하는가?):**
  - **본질적 분산:** 여러 사용자가 각자의 기기로 상호작용하는 경우.
  - **클라우드 서비스 요청:** 데이터 저장소와 처리 서비스가 분리된 경우 (네트워크 통신 필수).
  - **결함 내성(Fault Tolerance)/고가용성:** 일부 노드/센터 장애 시에도 서비스 지속 (이중화).
  - **확장성(Scalability):** 단일 기기 용량을 초과하는 데이터/연산 처리.
  - **지연 시간(Latency):** 사용자와 지리적으로 가까운 곳에 서버 배치.
  - **탄력성(Elasticity):** 부하 변동에 맞춰 리소스를 유연하게 조절 (클라우드).
  - **특수 하드웨어 활용:** 작업별 최적 하드웨어 사용 (예: ML은 GPU, 분석은 고메모리).
  - **법적 준수(Legal Compliance):** 데이터 거주 요건(Data Residency)에 따라 특정 국가 내 데이터 저장.
  - **지속 가능성(Sustainability):** 재생 에너지 가용 시간/장소에 맞춰 작업 실행.
- **분산 시스템의 문제점:**
  - **네트워크 실패:** 요청 유실, 타임아웃 등 불확실성 처리 필요 (9장).
  - **성능:** 네트워크 호출은 메모리 함수 호출보다 훨씬 느림. 데이터 이동보다 연산을 데이터가 있는 곳으로 이동시키는 것이 효율적일 수 있음.
  - **복잡성:** 문제 진단 및 트러블슈팅이 어려움 (관측 가능성(Observability), 분산 추적(Distributed Tracing) 도구 필요).
  - **데이터 일관성:** 서비스별 데이터베이스 분리 시, 데이터 간 일관성 유지가 애플리케이션의 책임이 됨 (분산 트랜잭션의 어려움).
- **결론:** 단일 노드로 충분하다면 단일 노드가 훨씬 단순하고 저렴함. 최신 하드웨어(CPU, RAM) 발전과 단일 노드 DB(DuckDB 등) 덕분에 많은 워크로드가 단일 노드로 처리가 가능해짐.

## 15. 마이크로서비스와 서버리스 (Microservices and Serverless)

- **마이크로서비스 (Microservices):**
  - **개념:** 애플리케이션을 잘 정의된 단일 목적을 가진 작은 서비스들로 분해하고, API로 통신하는 아키텍처 (SOA의 발전된 형태).
  - **장점:** 독립적 배포/업데이트, 각 서비스에 맞는 하드웨어 할당, 구현 은닉(API 뒤에 숨김), 조직 확장성(팀 간 독립성).
  - **데이터 저장:** 서비스 간 결합도를 낮추기 위해 **각 서비스가 자체 데이터베이스를 가짐** (DB 공유 지양).
  - **단점:** 인프라/배포/모니터링 복잡성 증가, 서비스 간 통합 테스트 어려움, API 변경 관리 문제(하위 호환성).
  - **본질:** 기술적 솔루션이라기보다 **조직 문제(팀 간 독립성)** 해결책에 가까움. 소규모 팀에는 과도한 오버헤드일 수 있음.
- **서버리스 (Serverless / FaaS):**
  - **개념:** 인프라 관리를 클라우드 벤더에 위임하고, 코드 실행 시간만큼만 비용을 지불하는 모델.
  - **특징:** 자동 스케일링, 사용량 기반 과금(Metered Billing).
  - **제약:** 실행 시간 제한, 런타임 환경 제한, 콜드 스타트(Cold Start) 지연 등.

## 16. 클라우드 컴퓨팅 vs 슈퍼컴퓨팅 (Cloud Computing Versus Supercomputing)

- **슈퍼컴퓨팅 (HPC):**
  - **용도:** 기상 예측, 분자 역학 등 계산 집약적 과학 연산.
  - **특징:**
    - 노드 장애 시 전체 작업을 중단하고 체크포인트부터 재시작.
    - 노드 간 신뢰 기반의 고속 통신(RDMA, 공유 메모리) 사용.
    - 특수 네트워크 토폴로지 사용, 지리적으로 근접한 노드 구성.
- **클라우드 컴퓨팅:**
  - **용도:** 온라인 서비스, 비즈니스 데이터 시스템 (고가용성 필수).
  - **특징:**
    - 장애 시에도 서비스 중단 없이 지속되어야 함 (전체 중단 불가).
    - 멀티 테넌시 환경으로 격리/보안/인증이 중요 (IP/Ethernet 기반).
    - 지리적으로 분산 가능.

## 17. 데이터 시스템, 법, 사회 (Data Systems, Law, and Society)

- **인식의 변화:** 데이터 시스템 엔지니어는 단순히 비즈니스 요구사항만 충족시키는 것을 넘어, **사회적 책임**을 자각해야 함.
- **개인정보 보호 규제:**
  - **GDPR (EU), CCPA (캘리포니아) 등:** 개인 데이터에 대한 통제권과 권리 강화.
  - **잊혀질 권리:** 사용자 요청 시 데이터 삭제 의무화. 이는 '불변 로그' 기반 시스템이나 머신러닝 모델 학습 데이터 삭제에 기술적 난제를 제시함.
  - **AI 규제 (EU AI Act 등):** 개인 데이터 사용에 대한 추가 제한.
- **자동화된 결정의 영향:** 대출, 채용, 범죄 수사 등에서 알고리즘의 결정이 개인에게 심각한 영향을 미칠 수 있으며, 편향과 차별 문제를 고려해야 함.
- **데이터 저장의 비용과 위험:**
  - 단순 저장 비용 외에 유출 시 배상 책임, 평판 하락, 벌금 등 리스크 비용 고려 필요.
  - **데이터 최소화 (Data Minimization):** 불필요한 데이터 수집을 지양하고 목적 달성 후 삭제해야 함 (빅데이터 철학과의 대립).
- **보안 표준:** PCI (결제), SOC 2 등 제3자 감사를 통한 규정 준수 검증이 중요.

## 18. 챕터 1 요약 (Summary)

이 장의 핵심 주제는 **트레이드오프(Trade-offs)의 이해**입니다. 정답은 없으며, 상황에 따라 장단점을 따져 최선의 접근 방식을 선택해야 합니다.

1. **운영(OLTP) vs 분석(OLAP):** 서로 다른 접근 패턴과 사용자를 가지며, 데이터 웨어하우스/레이크를 통해 연결됨.
2. **클라우드 vs 자체 호스팅:** 상황에 따라 비용 효율성이 다르며, 클라우드 네이티브 아키텍처(저장소와 연산 분리)가 부상함.
3. **분산 시스템 vs 단일 노드:** 분산 시스템은 불가피할 때만 사용하고, 가능하면 단일 머신이 더 단순하고 효율적임.
4. **법과 윤리:** 기술적 목표뿐만 아니라 개인정보 보호와 사회적 책임을 고려한 설계가 필요함.
