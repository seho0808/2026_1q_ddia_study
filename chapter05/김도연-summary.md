## 리더와 팔로워

데이터베이스의 복사본을 저장하는 각 노드를 복제 서버(replica)라고 한다.

모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할까?

- 리더 기반 복제
    - 쓰기는 리더에게만 허용
    - 리더가 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송

## 동기식 대 비동기식 복제

- 동기식
    - 팔로워가 장애를 복구 중이거나 시스템이 최대 가용량 부근에서 동작하거나 노드 간 네트워크 문제가 있어서 지연되는 경우 쓰기가 지연됨
    - 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
- 비동기식
    - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있음
    - 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다. 이것은 쓰기가 클라이언트에게 확인된 경우에도 지속성을 보장하지 않는다는 의미다.

> 반동기식: 최소한 한 대의 팔로워라도 데이터를 확실히 가졌을 때 클라이언트에게 응답하는 방식. 동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다. 이것은 적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장한다.
> 

## 새로운 팔로워 설정

새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까?

팔로워 설정은 대개 중단시간 없이 수행할 수 있다.

1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져온다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말한다. 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

## 노드 중단 처리

개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것이 목표다.

리더 기반 복제에서 고가용성은 어떻게 달성할 수 있을까?

### 팔로워 장애: 따라잡기 복구

보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다. 그리고 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.

### 리더 장애: 장애 복구

리더의 장애를 처리하는 일은 까다롭다.

1. 리더가 장애인지 판단한다.
2. 새로운 리더를 선택한다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다. 시스템은 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있게끔 해야 한다.
- 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다.
- 스플릿 브레인 → 데이터 유실/오염
- 타임아웃 설정에 따른 불필요한 장애 복구 → 상황을 더 악화

→ 분산 시스템에서 발생하는 근본적인 문제들

## 복제 로그 구현

### 구문 기반 복제

- 예상치 못한 부수 효과로 인해 복제가 깨질 수 있음

### 쓰기 전 로그 배송

- 복제가 저장소 엔진과 밀접하게 엮임(호환 안됨)

### 논리적(로우 기반) 로그 복제

- 하위호환성을 더 쉽게 유지
- 외부 애플리케이션이 파싱하기 더 쉬움(CDC)

### 트리거 기반 복제

- 다른 복제 방식보다 많은 오버헤드가 있다. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생한다. 그럼에도 트리거 기반 복제는 유연성 때문에 매우 유용하다.

## 복제 지연 문제

### 자신이 쓴 내용 읽기

사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.

- 항상 사용자 소유의 프로필은 리더에서 읽고 다른 사용자의 프로필은 팔로워에서 읽는 간단한 규칙을 사용한다.

동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생한다. 이 경우에는 디바이스 간 쓰기 후 읽기 일관성이 제공돼야 한다.

- 복제 서버가 여러 데이터센터 간에 분산돼 있다면 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다. 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다.

### 단조 읽기

- 시간이 거꾸로 흐르는 현상이 발생하지 않음을 보장한다. → 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.
- 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것

### 일관된 순서로 읽기

- 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징적인 문제
- 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰인 내용을 보게 됨을 보장한다.
- 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법도 있다.

### 복제 지연을 위한 해결책

복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것이 문제 해결 방안이다.

> **트랜잭션**은 애플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법이다.
> 

오랫동안 단일 노드 트랜잭션은 존재했다. 하지만 분산(복제되고 파티셔닝된) 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다.

# 다중 리더 복제

## 다중 리더 복제의 사용 사례

### 다중 데이터센터 운영

각 데이터센터 내에는 보통 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.

- 네트워크 문제 내성
    - 데이터센터 간 트래픽은 보통 공개 인터넷을 통해 처리한다. 그래서 데이터센터 내의 로컬 네트워크보다 안정성이 떨어진다. 단일 리더 설정에서는 데이터센터 내 연결의 쓰기는 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감하다. 비동기 복제를 사용하는 다중 리더 설정에서는 네트워크 문제에 보다 잘 견딘다. 일시적인 네트워크 중단에도 쓰기 처리는 진행되기 때문이다.
- 쓰기 충돌
    - 동일한 데이터를 두 리더가 동시에 변경하는 경우. 반드시 해소해야할 문제이고, 까다롭다.

### 오프라인 작업을 하는 클라이언트

인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야하는 경우

### 협업 편집

## 쓰기 충돌 다루기

### 동기 대 비동기 충돌 감지

이론적으로 충돌 감지는 동기식으로 만들 수 있다. → 각 복제 서버가 독립적으로 쓰기를 허용한다는 장점을 잃음

### 충돌 회피

특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다.

### 일관된 상태 수렴

다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다.

데이터베이스는 수렴 방식으로 충돌을 해소

### 사용자 정의 충돌 해소 로직

애플리케이션 코드를 사용해 충돌 해소 로직을 작성

### 충돌은 무엇인가?

감지하기 어려운 충돌도 있다

### 다중 리더 복제 토폴로지

> 복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명한다.
> 
- 전체 연결 토폴로지
    - 메시지 추월 문제
- 별, 원형 토폴로지
    - 단일 장애점 문제

많은 다중 리더 복제 시스템에서 충돌 감지 기법은 제대로 구현되지 않았다.

다중 리더 복제 시스템을 사용하려면 이런 문제를 인지하고 문서를 주의 깊게 읽은 다음 데이터베이스를 철저하게 테스트해 실제로 믿을 만한 보장을 제공하는지 확인하는 편이 좋다.

# 리더 없는 복제

일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다. → Dynamo style

## 노드가 다운됐을 때 데이터베이스에 쓰기

클라이언트가 쓰기를 세 개의 모든 복제 서버에 병렬로 전송한다. 사용 불가능한 복제 서버 하나가 쓰기를 놓친 경우 무시한다.

### 읽기 복구와 안티 엔트로피

- 읽기 복구
    - 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.
    - 값을 자주 읽는 상황에 적합하다.
- 안티 엔트로피 처리
    - 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된  데이터를 하나의 복제 서버에서 다른 서버로 복사한다.
    - 상당한 지연이 있을 수 있다.

### 읽기와 쓰기를 위한 정족수

n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정되고 모든 읽기는 최소한 r개의 노드에 질의해야 한다. w + r > n 이면 읽을 때 최신 값을 얻을 것으로 기대한다.

### 정족수 일관성의 한계

w + r > n인 경우에도 오래된 값을 반환하는 에지 케이스가 있다.

- 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다.
- 쓰기가 읽기와 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다.
- 새 값을 전달하는 노드가 고장나면 정족수 조건이 깨진다.
- 성공한 복제 서버에서는 이를 롤백하지 않는다. → 일부 성공/ 일부 실패의 경우

<aside>
🔑

견고한 보장을 위해 일반적으로 트랜잭션이나 합의가 필요하다.

</aside>

### 최신성 모니터링

운영 관점에서 볼 때 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링하는 일은 중요하다.

리더 기반 복제에서는 리더의 현재 위치에서 팔로워의 현재 위치를 빼면 복제 지연량을 측정할 수 있다.

하지만 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 조금 더 어렵다.

### 느슨한 정족수와 암시된 핸드오프

노드가 n개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 일부 데이터베이스 노드(특정 값을 위한 정족수 구성에 들어가지 않는 노드)에 연결될 가능성이 있다.

- 오류 반환?
- 느슨한 정족수&암시된 핸드오프?(n개 노드에 속하지는 않지만 연결할 수 있는 다른 노드에 저장해두고 나중에 옮김)
    - 쓰기 가용성을 높이는데는 유용
    - 암시된 핸드오프가 완료되기까지 w + r > n인 경우에도 최신값을 읽을 수 있다는 보장이 없어진다.

### 다중 데이터센터 운영

리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기 때문에 다중 데이터센터 운영에 적합하다.

데이터베이스 클러스터들의 데이터센터 간 복제는 백그라운드에서 비동기로 일어나며 방식은 다중 리더 복제와 유사하다.

## 동시 쓰기 감지

다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌이 발생한다.

### 최종 쓰기 승리(동시 쓰기 버리기)

- 최종 쓰기 승리(LWW)
    - 쓰기에 타임스탬프를 붙여 가장 최신이라는 의미로 제일 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시한다.
    - 최종적 수렴 달성이 목표지만 지속성을 희생한다. 손실 데이터를 허용하지 않는다면 LWW가 충돌 해소에 적합하지 않다.

LWW로 데이터베이스를 안전하게 사용하는 유일한 방법은 키를 한번만 쓰고 이후에는 불변 값으로 다루는 것이다. 이 방법은 같은 키를 동시에 갱신하는 상황을 방지한다.
