## 복제의 각 방식의 장단점이 뭐지..? 유스케이스가 많이 갈릴 것 같은데..

| 방식          | 쓰기 흐름                      | 장점                              | 단점                                 |
| :------------ | :----------------------------- | :-------------------------------- | :----------------------------------- |
| **단일 리더** | 모든 쓰기는 하나의 리더로 전송 | 이해하기 쉽고 일관성 보장이 강함  | 리더 장애 시 쓰기 불가 (단일 장애점) |
| **다중 리더** | 여러 리더가 쓰기 수락          | 지리적 분산, 오프라인 작업에 강함 | 쓰기 충돌 해결 필요, 약한 일관성     |
| **리더 없는** | 여러 노드에 병렬로 쓰기/읽기   | 결함 내성 및 가용성이 매우 높음   | 복잡한 충돌 감지 및 해결 로직 필요   |

```mermaid
flowchart TD
    Start(["프로젝트 시작: 복제 전략 선택"]) --> Q1{"오프라인 모드 지원이나<br>실시간 협업이 필수인가?<br>(예: 캘린더, 구글 닥스)"}

    Q1 -- "Yes" --> MultiLeader["**다중 리더 (Multi-Leader)**<br>- 로컬에서 쓰고 나중에 동기화<br>- 충돌 해결(CRDT/OT) 구현 필요"]

    Q1 -- "No" --> Q2{"글로벌 유저 대상이며<br>지역별 쓰기 속도가<br>매우 중요한가?"}

    Q2 -- "Yes" --> MultiLeader

    Q2 -- "No" --> Q3{"단 1초의 쓰기 중단도<br>허용할 수 없는<br>초고가용성 서비스인가?<br>(예: 아마존 장바구니)"}

    Q3 -- "Yes" --> Leaderless["**리더 없는 복제 (Leaderless)**<br>- DynamoDB, Cassandra 스타일<br>- 정족수(Quorum) 설정으로 조절<br>- 충돌 해결 로직 필요"]

    Q3 -- "No" --> Q4{"데이터의 엄격한 순서와<br>일관성이 중요한가?<br>(예: 금융 원장, 재고 관리)"}

    Q4 -- "Yes" --> SingleLeader["**단일 리더 (Single Leader)**<br>- 가장 안전하고 일반적인 선택<br>- RDB(MySQL, PG)의 기본값"]

    Q4 -- "No" --> Default["**단일 리더 (Single Leader)**<br>대부분의 경우 이것으로 충분함"]

    style SingleLeader fill:#b3e0fc,stroke:#01579b,stroke-width:2px,color:#212121
    style MultiLeader fill:#ffd8b2,stroke:#e65100,stroke-width:2px,color:#212121
    style Leaderless fill:#f8bbd0,stroke:#880e4f,stroke-width:2px,color:#212121
```

## 스타트업은 어느 시점부터 DB 복제를 고려해야하는가? 몇 TPS + 작업로드?

스타트업에서 DB 복제(Replication)를 도입하는 시점을 결정할 때, 많은 엔지니어들이 **"TPS가 몇이 되면 도입해야 하나요?"** 라고 묻습니다.

하지만 정답은 **"TPS(성능) 때문이 아니라, 죽으면 안 되기 때문에(가용성) 도입한다"** 가 맞습니다.

스타트업의 성장 단계별로 복제를 고려해야 하는 **명확한 기준(Trigger)**을 정리해 드립니다.

---

### 1. 결론부터: TPS는 숫자에 불과하다

최신 클라우드 환경(AWS RDS, Aurora 등)에서 잘 튜닝된 **단일(Single) DB 인스턴스**는 생각보다 엄청난 부하를 견딥니다.

- **단일 노드 성능**: 적절한 인덱싱과 스펙 업(Vertical Scaling)만으로도 **Read 20,000~50,000 TPS / Write 5,000+ TPS**를 충분히 감당합니다.
- **현실**: 대부분의 초기~중기 스타트업은 단일 DB의 한계 성능에 도달해서 복제를 하는 게 아니라, **DB가 죽었을 때 서비스 전체가 멈추는 공포** 때문에 복제를 시작합니다.

---

### 2. 복제 도입을 결정하는 3가지 트리거

TPS 수치보다 아래 3가지 상황이 닥쳤을 때가 진짜 타이밍입니다.

#### ① RPO/RTO 요구사항 (생존의 문제)

- **상황**: "DB 서버가 물리적으로 고장 나거나 AZ(가용 영역) 장애가 발생했을 때, 복구하는 데 1시간 이상 걸려도 되는가?"
- **판단 기준**:
  - 다운타임 1시간 비용 > Replica 서버 한 달 유지비
  - **Action**: TPS가 10이어도, 비즈니스 신뢰도가 중요하다면 **Multi-AZ(Standby)** 복제를 즉시 도입해야 합니다. (성능 향상 목적이 아닌 보험용)

#### ② 분석 쿼리의 간섭 (격리의 문제)

- **상황**: 운영팀이나 CEO가 "지난달 매출 통계 뽑아줘"라고 해서 쿼리를 날렸더니, **서비스 API 응답 속도가 느려지거나 타임아웃**이 발생함.
- **판단 기준**:
  - OLTP(실서비스 트랜잭션)와 OLAP(분석용 쿼리)가 하나의 CPU/Memory를 두고 싸우기 시작할 때.
  - **Action**: **읽기 전용 복제본(Read Replica)**을 하나 만들고, 무거운 분석 쿼리는 전부 거기로 보냅니다.

#### ③ CPU/Memory 병목 (진짜 성능 문제)

- **상황**: 캐시(Redis)를 도입했는데도 불구하고 DB CPU가 상시 **70~80%**를 찍고 있음.
- **판단 기준**:
  - 스케일 업(더 좋은 장비로 교체) 비용이 스케일 아웃(복제본 추가) 비용보다 비효율적일 때.
  - 전체 트래픽 중 **읽기(Read) 비중이 80% 이상**일 때.
  - **Action**: Read Replica를 추가하고 로드밸런싱 합니다.

---

### 3. 스타트업 DB 아키텍처 진화 단계

#### 1단계: MVP ~ 초기 (TPS < 500)

- **구성**: 단일 DB (Single AZ) + 주기적 스냅샷 백업
- **특징**: 돈 아끼는 게 최우선. DB 죽으면 새벽에 개발자가 일어나서 백업본으로 복구함. (복구 시간 1~2시간 소요 허용)

#### 2단계: PMF 달성 후 성장기 (TPS 500 ~ 2,000)

- **구성**: **Primary (Active)** + **Standby (Passive)**
- **목적**: **고가용성(HA)**.
- **특징**: 성능 확장이 아님. Primary가 죽으면 Standby가 즉시 승계(Failover)하여 다운타임을 1분 이내로 줄임. AWS RDS의 "Multi-AZ" 옵션이 이것입니다.

#### 3단계: 트래픽 폭증기 (TPS 2,000 ~ 10,000+)

- **구성**: Primary + Standby + **Read Replica 1~N**
- **목적**: **부하 분산**.
- **특징**: `SELECT` 쿼리는 Read Replica로, `INSERT/UPDATE`는 Primary로 보냄. 애플리케이션 레벨에서 쿼리 라우팅 설정이 필요해짐.
  - _주의: 이때부터 '복제 지연(Replication Lag)' 문제를 고민해야 함._

#### 4단계: 유니콘/대규모 (TPS 10,000++ ~)

- **구성**: 샤딩(Sharding) 또는 NewSQL(TiDB, CockroachDB) 고려
- **목적**: **쓰기 성능 한계 돌파**.
- **특징**: 복제만으로는 리더(Primary) 한 대에 쏟아지는 쓰기 트래픽을 감당할 수 없음. 데이터를 쪼개서 저장해야 함.

---

### 4. 요약: 이것부터 체크하세요

지금 복제를 고민 중이라면 다음 순서대로 자가 진단을 해보세요.

1.  **캐시(Redis/Memcached)는 쓰고 있는가?**
    - 단순 읽기 부하라면 복제본 만드는 것보다 캐싱이 훨씬 싸고 빠르고 효과적입니다.
2.  **인덱스는 잘 걸려 있는가?**
    - TPS 1,000에서 DB가 힘들어한다면, 십중팔구 복제 문제가 아니라 `Slow Query` 문제입니다.
3.  **돈으로 해결(Scale-up)해 보았는가?**
    - 복제 시스템(Scale-out)은 관리 포인트와 복잡도가 급격히 늘어납니다. 월 $200 더 내고 CPU 2배 좋은 거 쓰는 게 스타트업에겐 훨씬 이득입니다.

**결론**:

- **HA(생존)** 목적이라면: TPS 상관없이 **지금 당장** (Standby).
- **성능** 목적이라면: 인덱스 튜닝 -> 캐시 도입 -> 스케일 업(장비 교체) -> 그 다음이 **Read Replica**입니다.

## CAP Theorem

- C: Consistency (일관성)
  - 쉽게 외우기: Copy (복사본)
  - 의미: 여러 서버에 있는 데이터 복사본들이 "언제 어디서 봐도 똑같아야 함" (A 서버에서 1억 입금하면, B 서버에서도 즉시 1억으로 보여야 함).
- A: Availability (가용성)
  - 쉽게 외우기: Anytime (언제든지) / Always (항상)
  - 의미: 서버 하나가 죽거나 문제가 생겨도 사용자의 요청에 "무조건 응답을 해줘야 함" (데이터가 좀 옛날 것일지라도 일단 대답은 해줌).
- P: Partition Tolerance (단절 내성)
  - 쉽게 외우기: Part (부분) / Phone line (통신선)
  - 의미: 서버들이 서로 "나뉘어(Part) 있어도" 혹은 통신선이 끊겨도 시스템이 "버텨야 함(Tolerance)". 분산 시스템이라면 이건 선택이 아니라 필수 조건입니다.
  - 헷갈리는 지점(매우 중요): 파티셔닝이 아니라 완전 다른 개념임. 장애가 생겼을 때를 의미하는 파티션입니다. "네트워크가 단절되었을 때"를 의미합니다.
- 세 줄 요약 암기법 (한 문장 정리)
  - 분산 시스템에서 네트워크가 끊기는 상황(P)이 오면, 우리는 선택해야 합니다.
  - CP: "데이터가 꼬이면 안 돼! 다 맞춰질 때까지 응답하지 마!" (일관성 중시)
  - AP: "일단 서비스는 돌아가야지! 좀 틀린 데이터라도 보여줘!" (가용성 중시)
  - CA: (이건 네트워크가 절대 안 끊기는 완벽한 세상에서만 가능하므로 실제 분산 환경에선 불가능에 가깝습니다.)

우리가 흔히 "MySQL, PostgreSQL은 CA 지향이야"라고 말하는 건, 그 DB들이 **"태생적으로 단일 서버에서 완벽하게 동작하도록(ACID) 설계되었기 때문"**입니다.

이걸 억지로 여러 대의 서버로 늘려서 쓰려고 하니(Replication), "어? 네트워크 끊기면 어떡하지?"라는 CAP의 고민이 뒤늦게 시작되는 것이죠. 그래서 전통적인 RDBMS를 분산 구성하면 보통 다음 둘 중 하나가 됩니다.

- CP에 가깝게 운영: 복제본에 데이터가 다 써질 때까지 기다림. (하나라도 응답 없으면 서비스 멈춤)
- AP에 가깝게 운영: 복제본은 나중에 업데이트되든 말든 일단 응답함. (데이터가 꼬일 수 있음)

- 요즘은 PACELC를 본다고함.

> PACELC란? P(네트워크 파티션) 상황일 때 A(가용성)와 C(일관성) 중 무엇을 택할 것인가? E(그 외 평상시) 상황일 때 L(지연 시간, Latency)과 C(일관성) 중 무엇을 택할 것인가?

```mermaid
flowchart TD
    Start([PACELC 이론 기반 DB 선택]) --> P_Step{"Step 1: 네트워크 단절(P) 시<br>가장 중요한 것은?"}

    P_Step -- "“틀린 답이라도<br>무조건 응답해야 한다”<br>(Availability)" --> PA_Group["**PA 계열**<br>가용성 우선"]
    P_Step -- "“데이터가 틀릴 바엔<br>차라리 멈추겠다”<br>(Consistency)" --> PC_Group["**PC 계열**<br>일관성 우선"]

    PA_Group --> E_Step_PA{"Step 2: 평상시(E)에<br>가장 중요한 것은?"}
    PC_Group --> E_Step_PC{"Step 2: 평상시(E)에<br>가장 중요한 것은?"}

    E_Step_PA -- "“데이터 동기화보다<br>응답 속도가 생명이다”<br>(Latency)" --> PAEL["**PA / EL**<br>DynamoDB, Cassandra, Riak<br>(속도와 생존력 끝판왕)"]

    E_Step_PA -- "“평소에는 데이터가<br>정확해야 한다”<br>(Consistency)" --> PAEC["**PA / EC**<br>(이론적으로 존재하나<br>구현이 매우 어려움)"]

    E_Step_PC -- "“데이터 동기화보다<br>응답 속도가 생명이다”<br>(Latency)" --> PCEL["**PC / EL**<br>PNUTS, Yahoo Sherpa<br>(특수한 케이스)"]

    E_Step_PC -- "“평소에는 데이터가<br>정확해야 한다”<br>(Consistency)" --> PCEC["**PC / EC**<br>BigTable, HBase, MongoDB<br>MySQL Cluster, VoltDB<br>(데이터 정합성 최우선)"]

    style PAEL fill:#ffcdd2,stroke:#b71c1c,stroke-width:4px,color:#212121
    style PCEC fill:#bbdefb,stroke:#0d47a1,stroke-width:4px,color:#212121
    style PAEC fill:#e0e0e0,stroke:#616161,stroke-dasharray: 5 5,color:#212121
    style PCEL fill:#e0e0e0,stroke:#616161,stroke-dasharray: 5 5,color:#212121
```

## 정족수 이슈

정족수 이론의 핵심 공식인 w+r>n은 어렵게 보이지만, 사실 **"읽는 사람과 쓰는 사람이 반드시 한 명은 겹치게 하라"**는 뜻입니다.

항상 읽기 그룹과 쓰기 그룹이 교집합을 가지도록 숫자를 설정하는 것이 정족수 이론의 전부입니다.
