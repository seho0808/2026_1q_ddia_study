## 5장 : 복제 (Replication)

## 1. 복제란 무엇인가?

### 복제의 정의
- 여러 머신에 **동일한 데이터의 복사본**을 유지하는 것
- 네트워크로 연결된 여러 노드에 데이터 사본을 저장

### 복제를 사용하는 이유

**지연 시간 감소**
- 지리적으로 사용자와 가까운 곳에 데이터 배치
- 글로벌 서비스에서 필수적

**가용성 향상**
- 일부 구성 요소 장애 발생 시에도 시스템 동작 지속
- 장애 허용(fault tolerance) 달성

**읽기 처리량 증가**
- 읽기 요청을 처리하는 머신 수 확장
- 읽기 집약적 워크로드 처리

---

## 2. 리더 기반 복제

### 동작 방식

```
클라이언트 → [리더] → 로컬 저장소 저장
              ↓
        복제 로그 전송
              ↓
     [팔로워1] [팔로워2] [팔로워3]
```

1. **쓰기**: 클라이언트가 리더에게만 요청
2. **복제**: 리더가 변경사항을 팔로워에게 전송
3. **읽기**: 리더 또는 팔로워 중 아무 곳에서나 가능

### 동기식 vs 비동기식 복제

**동기식 복제**
- 리더가 팔로워의 확인을 기다림
- 장점: 팔로워가 리더와 일관된 최신 데이터 보장
- 단점: 팔로워 응답 없으면 쓰기 처리 불가

**비동기식 복제**
- 리더가 팔로워의 확인을 기다리지 않음
- 장점: 빠른 쓰기 처리, 높은 가용성
- 단점: 데이터 손실 가능성

**반동기식 (실무에서 주로 사용)**
- 하나의 팔로워는 동기식, 나머지는 비동기식
- 균형잡힌 접근 방식

### 새로운 팔로워 설정

1. 리더의 데이터베이스 **스냅샷** 생성
2. 스냅샷을 새로운 팔로워 노드에 복사
3. 팔로워가 리더에 연결하여 스냅샷 이후의 변경사항 요청
4. 팔로워가 스냅샷 이후의 변경사항 모두 처리 (따라잡기, catch up)

### 장애 처리

**팔로워 장애: 따라잡기 복구**
- 팔로워가 재시작 시 로컬 로그에서 마지막 처리 트랜잭션 확인
- 해당 지점 이후의 변경사항을 리더에게 요청

**리더 장애: 장애 복구(Failover)**
1. 리더 장애 감지 (타임아웃 사용)
2. 새로운 리더 선출 (일반적으로 최신 데이터를 가진 팔로워)
3. 시스템이 새로운 리더를 사용하도록 재설정

**장애 복구 시 문제점**
- 비동기식 복제에서 새 리더가 이전 리더의 모든 쓰기를 받지 못했을 수 있음
- Split brain 문제: 두 노드가 모두 리더라고 믿는 상황
- 적절한 타임아웃 설정의 어려움

---

## 3. 복제 지연 문제

### 최종적 일관성 (Eventual Consistency)

비동기식 팔로워는 리더보다 뒤처짐 → **복제 지연** 발생
- 정상 상황: 몇 초 이내
- 시스템 부하: 몇 분 이상도 가능

### 문제 1: 쓰기 후 읽기 일관성

**문제 상황**
```
사용자 → [리더] 데이터 쓰기
          ↓ (복제 중...)
사용자 → [팔로워] 데이터 읽기 → 이전 데이터 보임!
```

**해결 방법**
- 사용자가 수정한 데이터를 읽을 때는 리더에서 읽기
- 마지막 갱신 시각 추적, 1분 이내면 리더에서 읽기
- 클라이언트가 마지막 쓰기 타임스탬프 기억, 충분히 최신인 복제 서버에서 읽기

### 문제 2: 단조 읽기 (Monotonic Reads)

**문제 상황**
```
시간순 →
사용자 → [팔로워A] 최신 데이터 읽기
사용자 → [팔로워B] 이전 데이터 읽기 (시간이 거꾸로!)
```

**해결 방법**
- 각 사용자가 항상 같은 복제 서버에서 읽도록 보장
- 사용자 ID 기반 해시로 복제 서버 선택

### 문제 3: 일관된 순서로 읽기 (Consistent Prefix Reads)

**문제 상황 (인과성 위반)**
```
질문: "사랑해?" → [복제 서버1]
답변: "뭘?" → [복제 서버2]

관찰자가 복제 서버2 먼저 보면: 답변 → 질문 순서로 보임!
```

**해결 방법**
- 인과성 있는 쓰기는 같은 파티션에 기록
- 인과성 추적 알고리즘 사용

---

## 4. 다중 리더 복제

### 개념

- 쓰기를 허용하는 노드가 **둘 이상**
- 각 리더는 동시에 다른 리더의 팔로워 역할 수행

```
[데이터센터 A]          [데이터센터 B]
  리더 A  ←----------→   리더 B
    ↓                      ↓
팔로워들                 팔로워들
```

### 사용 사례

**1. 다중 데이터센터 운영**
- 각 데이터센터에 리더 배치
- 데이터센터 내부: 일반적인 리더-팔로워 복제
- 데이터센터 간: 각 리더가 다른 데이터센터 리더에게 변경사항 복제

**장점**
- 성능: 지리적으로 가까운 데이터센터에 쓰기
- 데이터센터 장애 허용
- 네트워크 문제 허용

**2. 오프라인 작업 클라이언트**
- 모바일 앱, 노트북 등
- 네트워크 연결 없이도 동작
- 온라인 시 변경사항 동기화

**3. 협업 편집**
- Google Docs, 실시간 공동 편집
- 각 사용자가 로컬 복제본 수정
- 변경사항을 서버 및 다른 사용자에게 비동기 복제

### 쓰기 충돌 문제

**충돌 발생 시나리오**
```
시간 →
리더1: 제목을 "A"로 변경
리더2: 제목을 "B"로 변경 (동시에)
→ 충돌 발생!
```

### 충돌 해결 방법

**1. 충돌 회피**
- 특정 레코드의 모든 쓰기를 같은 리더로 라우팅
- 예: 사용자 ID 기반 리더 할당

**2. 일관된 상태로 수렴**
- 마지막 쓰기 승리 (LWW, Last Write Wins): 타임스탬프 사용
- 복제 서버 ID가 높은 쓰기 선택
- 값 병합 (예: B/A를 알파벳순으로 정렬)
- 충돌 정보를 보존하고 사용자에게 해결 요청

**3. 사용자 정의 충돌 해소 로직**
- 쓰기 수행 중: 충돌 감지 즉시 충돌 핸들러 호출
- 읽기 수행 중: 충돌 버전 모두 저장, 읽을 때 반환하여 사용자에게 해결 요청

### 다중 리더 복제 토폴로지

**원형 토폴로지**
```
리더1 → 리더2 → 리더3 → 리더1
```

**별 모양 토폴로지**
```
    리더2
    ↗  ↖
리더1 ← 리더3 → 리더4
```

**전체 연결 토폴로지**
```
리더1 ⟷ 리더2
 ↕  ⨯  ↕
리더3 ⟷ 리더4
```

**문제점**
- 일부 네트워크 링크가 다른 것보다 빠를 수 있음
- 쓰기가 다른 쓰기를 추월할 수 있음 (인과성 위반)
- 버전 벡터 사용으로 해결 가능

---

## 5. 리더 없는 복제

### 개념

- 리더 개념이 없음 (Dynamo, Riak, Cassandra, Voldemort)
- 클라이언트가 여러 복제 서버에 직접 쓰기 전송
- 또는 코디네이터 노드가 대신 수행 (리더와 달리 쓰기 순서 강제하지 않음)

```
         클라이언트
        /    |    \
       ↓     ↓     ↓
   복제1  복제2  복제3
```

### 정족수 읽기와 쓰기

**설정**
- n개의 복제 서버
- 쓰기: w개 노드에서 성공 확인 필요
- 읽기: 최소 r개 노드에 질의

**정족수 조건**
```
w + r > n
```
이 조건이면 읽을 때 최신 값을 얻을 것으로 예상

**일반적인 선택**
- n = 3, w = 2, r = 2
- n = 5, w = 3, r = 3

### 노드 장애 처리

**읽기 복구 (Read Repair)**
```
클라이언트 → 복제1, 복제2, 복제3에서 읽기
복제1: 버전 6
복제2: 버전 7 (최신)
복제3: 버전 6

→ 클라이언트가 복제1, 복제3에 버전 7 쓰기
```

**안티 엔트로피 프로세스**
- 백그라운드 프로세스
- 복제 서버 간 데이터 차이 지속적으로 탐색
- 누락된 데이터를 한 복제 서버에서 다른 복제 서버로 복사

### 정족수 일관성의 한계

**w + r > n이어도 오래된 값을 읽을 수 있는 경우**

1. **느슨한 정족수 사용 시**
   - 지정된 n개 노드가 아닌 다른 노드에 쓰기

2. **동시 쓰기 발생**
   - 타임스탬프 기반 병합 필요

3. **쓰기와 읽기가 동시 발생**
   - 쓰기가 일부 복제 서버에만 반영된 상태

4. **쓰기가 일부만 성공**
   - w개 미만 복제 서버에 쓰기 성공
   - 롤백되지 않아 후속 읽기에서 오래된 값 반환 가능

5. **최신 값을 가진 노드 장애**
   - 복구 전에 읽기 발생

### 느슨한 정족수와 암시된 핸드오프

**느슨한 정족수 (Sloppy Quorum)**
- n개의 지정된 노드 중 w 또는 r개에 도달 불가 시
- 도달 가능한 다른 노드에 쓰기 허용
- 가용성 향상

**암시된 핸드오프 (Hinted Handoff)**
```
정상: [노드1] [노드2] [노드3]
장애: [노드1]   X     [노드3] [임시노드]

네트워크 복구 후:
임시노드 → 노드2로 데이터 전송
```

### 동시 쓰기 감지

**문제**
```
클라이언트A: 장바구니에 우유 추가
클라이언트B: 장바구니에 계란 추가 (동시에)

결과는?
```

**해결 방법**

**1. 마지막 쓰기 승리 (LWW)**
- 타임스탬프가 가장 늦은 쓰기만 유지
- 단점: 데이터 손실 발생

**2. "이전 발생" 관계와 동시성**
- 작업 A가 B 이전에 발생: B가 A를 알고 있음
- 작업이 동시적: 서로를 모름

**3. 버전 벡터**
```
[서버1: v1, 서버2: v2, 서버3: v3]
```
- 각 복제 서버와 키마다 버전 번호 사용
- 어떤 값이 최신인지, 동시 쓰기인지 판단 가능

---

## 6. 정리 및 결론

### 복제 방식 비교

| 특성 | 리더 기반 | 다중 리더 | 리더 없는 |
|------|-----------|-----------|-----------|
| 쓰기 가능 노드 | 1개 | 여러 개 | 모든 노드 |
| 일관성 | 상대적으로 단순 | 충돌 해결 필요 | 정족수 기반 |
| 가용성 | 보통 | 높음 | 매우 높음 |
| 복잡도 | 낮음 | 높음 | 중간 |
| 사용 사례 | 대부분의 RDBMS | 다중 데이터센터, 오프라인 | 높은 가용성 요구 |

### 핵심 개념 요약

**복제의 목적**
- 지연 시간 감소
- 가용성 향상  
- 읽기 처리량 증가

**복제 지연으로 인한 문제**
- 쓰기 후 읽기 일관성
- 단조 읽기
- 일관된 순서로 읽기

**충돌 해결**
- 마지막 쓰기 승리
- 버전 벡터
- 사용자 정의 로직

### 실무 고려사항

1. **요구사항 파악**
   - 일관성 vs 가용성 트레이드오프
   - 읽기/쓰기 비율
   - 지리적 분산 필요성

2. **적절한 복제 방식 선택**
   - 단순한 워크로드: 리더 기반
   - 다중 데이터센터: 다중 리더
   - 높은 가용성: 리더 없는

3. **모니터링**
   - 복제 지연 측정
   - 충돌 발생 빈도 추적
   - 장애 복구 시간 모니터링

---
