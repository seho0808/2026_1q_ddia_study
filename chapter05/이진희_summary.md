# 데이터 중심 어플리케이션 설계 5장: 복제(Replication) 요약

## 개요

**복제**란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것을 의미한다.

### 복제가 필요한 이유
- **지연 시간 감소**: 지리적으로 사용자와 가깝게 데이터를 유지
- **가용성 향상**: 시스템 일부에 장애가 발생해도 지속적으로 동작
- **읽기 처리량 확장**: 읽기 질의를 제공하는 장비 수를 확장

---

## 1. 리더 기반 복제 (Leader-based Replication)

### 기본 개념
- **리더(Leader)**: 마스터/프라이머리라고도 함. 클라이언트의 쓰기 요청을 처리
- **팔로워(Follower)**: 읽기 복제 서버, 슬레이브라고도 함. 리더의 복제 로그를 받아 복사본 갱신
- 클라이언트는 읽기를 리더 또는 팔로워에게, 쓰기는 리더에게만 요청

### 동기식 vs 비동기식 복제

| 구분 | 동기식 | 비동기식 |
|---|---|---|
| 장점 | 팔로워가 리더와 일관성 있는 최신 데이터 보장 | 리더가 쓰기 처리를 계속할 수 있음 |
| 단점 | 팔로워 응답 대기로 쓰기 차단 가능 | 리더 장애 시 데이터 유실 가능 |

- **반동기식(Semi-synchronous)**: 하나의 팔로워는 동기식, 나머지는 비동기식으로 설정

### 새로운 팔로워 설정 과정
1. 리더의 데이터베이스 스냅숏을 특정 시점에 가져옴
2. 스냅숏을 새 팔로워 노드에 복사
3. 팔로워가 리더에 연결해 스냅숏 이후 데이터 변경 요청
4. 미처리분(backlog)을 모두 처리하면 따라잡기 완료

### 노드 중단 처리

**팔로워 장애: 따라잡기 복구**
- 로컬 디스크에 보관된 데이터 변경 로그로 복구
- 마지막 처리 트랜잭션 이후 변경 사항을 리더에게 요청

**리더 장애: 장애 복구(Failover)**
1. 리더가 장애인지 판단 (타임아웃 사용)
2. 새로운 리더 선출 (선출 과정 또는 제어 노드에 의해)
3. 새로운 리더 사용을 위한 시스템 재설정

**장애 복구의 위험성**
- 비동기식 복제 시 이전 리더의 쓰기 유실 가능
- 스플릿 브레인(Split Brain): 두 노드가 모두 자신이 리더라고 믿는 상황
- 적절한 타임아웃 설정의 어려움

---

## 2. 복제 로그 구현 방식

### 구문 기반 복제 (Statement-based)
- 모든 쓰기 요청(SQL 구문)을 팔로워에게 전송
- 문제점: NOW(), RAND() 같은 비결정적 함수, 자동증가 칼럼, 부수 효과

### 쓰기 전 로그 배송 (Write-Ahead Log, WAL)
- 저장소 엔진의 로그를 팔로워에게 전송
- 단점: 저장소 엔진과 밀접하게 연결되어 버전 호환성 문제

### 논리적(로우 기반) 로그 복제
- 저장소 엔진과 분리된 로그 형식 사용
- 하위 호환성 유지 용이, 외부 시스템으로 전송 유용
- **변경 데이터 캡처(Change Data Capture)** 기술에 활용

### 트리거 기반 복제
- 애플리케이션 코드로 데이터 변경 시 복제
- 유연성 높지만 오버헤드와 버그 가능성 존재

---

## 3. 복제 지연 문제

비동기식 복제에서 팔로워가 뒤처지면 **복제 지연**이 발생하여 일관성 문제가 생길 수 있다.

### 최종적 일관성 (Eventual Consistency)
- 데이터베이스에 쓰기를 멈추고 기다리면 팔로워가 결국 리더와 일치
- "최종적"이란 용어는 의도적으로 모호함

### 일관성 모델

**1. 자신이 쓴 내용 읽기 (Read-after-write Consistency)**
- 사용자가 제출한 데이터를 항상 볼 수 있어야 함
- 구현 방법:
  - 수정한 내용은 리더에서 읽고, 그 외는 팔로워에서 읽기
  - 마지막 갱신 시각 기준으로 리더에서 읽을지 결정
  - 클라이언트가 최근 쓰기의 타임스탬프를 기억

**2. 단조 읽기 (Monotonic Reads)**
- 시간이 거꾸로 흐르는 현상 방지
- 한 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 함

**3. 일관된 순서로 읽기 (Consistent Prefix Reads)**
- 인과성이 있는 쓰기는 같은 순서로 읽힘을 보장
- 파티셔닝된 데이터베이스에서 특히 중요

---

## 4. 다중 리더 복제 (Multi-Leader Replication)

### 사용 사례

**다중 데이터센터 운영**
- 각 데이터센터마다 리더가 있음
- 장점: 성능 향상, 데이터센터 중단 내성, 네트워크 문제 내성

**오프라인 작업을 하는 클라이언트**
- 각 디바이스가 로컬 데이터베이스(리더)를 가짐
- 예: 캘린더 앱의 오프라인 동기화

**협업 편집**
- 여러 사용자가 동시에 문서 편집
- 예: 이더패드, 구글 독스

### 쓰기 충돌 다루기

**충돌 회피**
- 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 보장

**일관된 상태 수렴**
- **최종 쓰기 승리(LWW)**: 타임스탬프 기반으로 가장 높은 ID를 가진 쓰기 선택
- 값 병합: 사전 순으로 정렬 후 연결
- 명시적 충돌 기록: 나중에 애플리케이션이 해소

**자동 충돌 해소**
- **CRDT(Conflict-free Replicated Datatype)**: 셋, 맵, 정렬 목록 등
- **병합 가능한 영속 데이터 구조**: Git과 유사한 삼중 병합 함수
- **운영 변환(Operational Transformation)**: 구글 독스 등 협업 편집용

### 다중 리더 복제 토폴로지
- **원형 토폴로지**: 각 노드가 하나의 노드로부터 쓰기를 받음
- **별 모양 토폴로지**: 루트 노드가 다른 모든 노드에 쓰기 전달
- **전체 연결 토폴로지**: 모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송

---

## 5. 리더 없는 복제 (Leaderless Replication)

### 다이나모 스타일 데이터스토어
- 아마존의 내부 다이나모(Dynamo) 시스템에서 유래
- 리악, 카산드라, 볼드모트 등이 영감을 받음
- 클라이언트가 여러 복제 서버에 직접 쓰기를 전송

### 읽기와 쓰기를 위한 정족수

**정족수 조건**: `w + r > n`
- `n`: 복제 서버 수
- `w`: 쓰기가 성공해야 하는 노드 수
- `r`: 읽기가 질의해야 하는 노드 수

**일반적 설정**: n을 홀수로 하고 `w = r = (n + 1) / 2`

### 복제본 따라잡기 메커니즘

**읽기 복구 (Read Repair)**
- 클라이언트가 병렬 읽기 시 오래된 응답을 감지하면 새로운 값을 다시 기록

**안티 엔트로피 처리**
- 백그라운드 프로세스가 복제 서버 간 데이터 차이를 찾아 복사

### 정족수 일관성의 한계
- 느슨한 정족수 사용 시 `r`개와 `w`개의 노드가 겹치지 않을 수 있음
- 동시 쓰기 발생 시 안전한 해결책은 충돌 합치기뿐
- 쓰기와 읽기가 동시에 발생하면 최신 값 반환 여부 불명확

### 느슨한 정족수와 암시된 핸드오프
- "홈" 노드에 연결할 수 없으면 다른 노드에 임시로 쓰기
- 네트워크 장애 해제 후 해당 "홈" 노드로 쓰기 전송

---

## 6. 동시 쓰기 감지

### 최종 쓰기 승리 (Last Write Wins, LWW)
- 타임스탬프 기반으로 가장 "최신" 값으로 수렴
- 단점: 지속성 희생, 데이터 손실 가능
- 안전한 사용법: 키를 한번만 쓰고 이후에는 불변 값으로 다루기

### "이전 발생(Happens-before)" 관계와 동시성

**세 가지 가능성**
1. A가 B 이전에 발생
2. B가 A 이전에 발생
3. A와 B가 동시에 발생 (서로 인과성 없음)

**동시성 정의**: 두 작업이 서로 알지 못하면 동시에 수행됐다고 말함

### 이전 발생 관계 파악 알고리즘
- 서버가 모든 키에 대한 버전 번호를 유지
- 클라이언트가 키를 읽을 때 최신 버전뿐 아니라 덮어쓰지 않은 모든 값 반환
- 클라이언트가 기록 시 이전 읽기의 버전 번호와 모든 값을 함께 합침
- 서버가 특정 버전 번호를 받으면 해당 버전 이하 모든 값을 덮어씀

### 버전 벡터 (Version Vector)
- 다중 복제본에서는 키당 버전 번호뿐 아니라 복제본당 버전 번호도 필요
- 모든 복제본의 버전 번호 모음을 **버전 벡터**라고 함
- 리악 2.0에서는 **도티드 버전 벡터(Dotted Version Vector)** 사용
- 덮어쓰기와 동시 쓰기를 구분할 수 있음

---

## 정리

### 복제의 용도
| 용도 | 설명 |
|---|---|
| 고가용성 | 장비/데이터센터가 다운되어도 시스템 계속 동작 |
| 연결이 끊긴 작업 | 네트워크 중단 시에도 애플리케이션 동작 |
| 지연 시간 | 사용자에게 지리적으로 가까이 데이터 배치 |
| 확장성 | 복제본에서 읽기 수행으로 읽기 처리량 확장 |

### 세 가지 주요 복제 방식

| 방식 | 설명 | 장점 | 단점 |
|---|---|---|---|
| **단일 리더** | 쓰기를 단일 노드로 전송, 이벤트 스트림을 팔로워에 전송 | 이해하기 쉽고 충돌 해소 불필요 | 팔로워에서 오래된 값 읽기 가능 |
| **다중 리더** | 여러 리더 노드 중 하나에 쓰기 전송, 리더 간 변경 이벤트 교환 | 결함 노드, 네트워크 중단에 견고 | 설명하기 어렵고 일관성 거의 미보장 |
| **리더 없는** | 여러 노드로 쓰기 전송, 병렬 읽기로 오래된 데이터 감지 및 보정 | 결함 노드, 네트워크 중단에 견고 | 설명하기 어렵고 일관성 거의 미보장 |

### 일관성 모델 요약
| 모델 | 보장 내용 |
|---|---|
| 쓰기 후 읽기 일관성 | 사용자가 자신이 제출한 데이터를 항상 볼 수 있음 |
| 단조 읽기 | 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터를 볼 수 없음 |
| 일관된 순서로 읽기 | 인과성이 있는 상태의 데이터를 봐야 함 (질문과 답을 순서에 맞게) |
