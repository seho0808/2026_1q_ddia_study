# DDIA 5장: 복제 (Replication)

복제는 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것을 의미합니다.

## 1. 리더와 팔로워 (Leaders and Followers)
*   **리더(Leader)**: 모든 쓰기 요청을 처리하며, 데이터 변경 사항을 팔로워에게 전달합니다. (마스터, 프라이머리)
*   **팔로워(Follower)**: 리더로부터 변경 사항을 받아 자신의 복사본을 갱신합니다. 읽기 요청만 처리할 수 있습니다. (슬레이브, 세컨더리, 핫 스탠바이)

## 2. 동기식 vs 비동기식 복제
*   **동기식 복제 (Synchronous)**: 리더가 팔로워의 확인 응답을 받을 때까지 기다립니다.
    *   장점: 최신 데이터 보장 (팔로워가 리더와 일치).
    *   단점: 팔로워 장애 시 전체 시스템의 쓰기 작업이 차단됨.
*   **비동기식 복제 (Asynchronous)**: 리더가 팔로워의 확인을 기다리지 않고 즉시 응답합니다.
    *   장점: 성능이 빠르고 가용성이 높음.
    *   단점: 리더 장애 시 데이터 유실 가능성이 있음.

## 3. 반동기식 복제 (Semi-synchronous)
*   팔로워 중 하나는 동기식으로, 나머지는 비동기식으로 설정하는 방식입니다.
*   적어도 하나 이상의 팔로워에는 데이터가 확실히 복제됨을 보장하면서도, 모든 팔로워의 응답을 기다리는 부하를 줄입니다.

## 4. 리더 장애 복구 (Failover)
장애 복구 과정은 보통 **장애 감지 -> 새로운 리더 선출 -> 시스템 재구성**의 단계를 거칩니다.

### GitHub MySQL 장애 사례 (유효하지 않은 팔로워의 리더 승격)
*   **사례**: 과거 깃허브에서 발생했던 문제로, 최신 데이터를 모두 가지지 못한(비동기 복제 지연이 있던) 팔로워가 리더로 승격되었습니다.
*   **결과**: 기존 리더에 남아있던 데이터가 유실되거나, 충돌이 발생하여 데이터 무결성이 깨지는 문제가 발생했습니다.
*   **교훈**: 비동기 복제 환경에서의 자동 장애 복구는 매우 위험하며, 데이터 유실 가능성을 항상 염두에 두어야 합니다.

### 스플릿 브레인 (Split Brain)
*   두 개 이상의 노드가 동시에 자신이 리더(Leader)라고 믿는 현상입니다.
*   두 리더가 동시에 쓰기를 수락하면 데이터 충돌과 손실이 발생합니다.
*   **해결책**: 보통 펜싱(Fencing) 메커니즘이나 정족수(Quorum) 기반의 선출 방식을 사용하여 한 명의 리더만 존재하도록 보장합니다.

## 5. 자신이 쓴 내용 읽기 (쓰기 후 읽기 일관성)
*   사용자가 데이터를 수정하자마자 조회했을 때, 아직 복제가 안 된 팔로워에서 읽게 되면 이전 데이터가 보이는 현상을 방지해야 합니다.
*   **해결 전략**:
    *   사용자가 수정한 데이터는 리더에서 읽기.
    *   마지막 업데이트 이후 특정 시간 동안은 리더에서 읽기.
    *   클라이언트 타임스탬프를 활용해 특정 시점 이후의 데이터를 가진 팔로워만 선택.

## 6. 단일 리더 복제 (Single-Leader Replication)
*   모든 쓰기가 단일 리더를 거치는 가장 일반적인 방식입니다.
*   복제 지연(Replication Lag)으로 인해 발생하는 문제들을 해결하기 위해 다음과 같은 **일관성 보장(Guarantees)**이 필요합니다:
    *   **쓰기 후 읽기 일관성 (Read-After-Write Consistency)**: 사용자가 수정한 데이터를 다시 읽었을 때 항상 최신임을 보장 (자신이 쓴 내용 읽기).
    *   **단조 읽기 (Monotonic Reads)**: 사용자가 여러 번 읽을 때 데이터가 과거로 되돌아가는 현상을 방지.
    *   **일관된 접두사 읽기 (Consistent Prefix Reads)**: 일련의 쓰기가 순서대로 나타나서 인과성이 깨지지 않도록 보장.

## 7. 다중 리더 및 리더 없는 복제

### 다중 리더 복제 (Multi-Leader Replication)
*   여러 데이터 센터에 각각 리더를 두는 방식입니다.
*   **장점**: 성능 개선, 데이터 센터 장애 대응, 오프라인 작업 지원.
*   **충돌 관리**: 여러 리더에서 동시에 같은 데이터를 수정할 때 충돌이 발생하므로, **충돌 회피**, **LWW(Last Write Wins)**, **충돌 해소 로직** 등이 필요합니다.

### 리더 없는 복제 (Leaderless Replication)
*   리더의 개념 없이 모든 노드가 쓰기와 읽기를 수락합니다. (예: Cassandra, Riak)
*   **엄격한 정족수 (Strict Quorum)**: $w + r > n$ (쓰기 노드 수 + 읽기 노드 수 > 전체 노드 수)을 만족하면 최신 데이터를 읽을 수 있음을 보장합니다.
*   **느슨한 정족수 (Sloppy Quorum)**: 네트워크 장애 시 지정된 $n$개의 노드가 아닌 다른 가용한 노드에 쓰기를 수행하여 가용성을 높입니다. 이후 장애 복구 시 **힌티드 핸드오프(Hinted Handoff)**를 통해 데이터를 원래 노드로 전달합니다.


