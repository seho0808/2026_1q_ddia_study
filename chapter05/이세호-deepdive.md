## **운영 변환(Operational Transformation, OT)**

### 1. 핵심 아이디어: "상대적인 위치의 변화"

OT의 핵심은 **"내가 편집을 시작했을 때의 위치(인덱스)가, 남의 편집 때문에 바뀔 수 있다"**는 점을 인정하고, 그 차이만큼 **작업 내용을 수정(변환)**하는 것입니다.

### 2. 쉬운 예시 (Google Docs 상황)

두 사람이 동시에 **"ice"**라는 단어를 편집한다고 가정해 봅시다.

- **기본 상태**: `[i, c, e]` (인덱스: 0, 1, 2)
- **사용자 A의 작업 ($Op_A$)**: 0번 자리에 **'n'** 추가 $\rightarrow$ 목표: **"nice"**
- **사용자 B의 작업 ($Op_B$)**: 3번 자리에 **'!'** 추가 $\rightarrow$ 목표: **"ice!"**

---

#### 만약 변환(Transformation)이 없다면? (에러 발생)

1.  사용자 A는 자기 화면에서 **"nice"**를 만듭니다.
2.  사용자 B의 작업(`3번 자리에 '!' 추가`)이 사용자 A에게 도착합니다.
3.  사용자 A의 현재 글자는 **"nice"**입니다. 여기서 단순히 3번 자리에 '!'를 넣으면?
    - `n(0), i(1), c(2), !(3), e(4)` $\rightarrow$ 결과: **"nic!e"** (틀림!)
    - 사용자 B의 의도는 단어 맨 뒤에 느낌표를 붙이는 것이었으나, A가 앞에 'n'을 넣는 바람에 인덱스가 밀려버린 것입니다.

---

#### OT가 작동한다면? (인덱스 보정)

1.  사용자 A에게 사용자 B의 작업(`3번 자리에 '!' 추가`)이 도착합니다.
2.  시스템은 감지합니다: **"잠깐, 이 작업이 생성된 후 우리 쪽에 0번 자리에 글자 하나('n')가 추가됐네?"**
3.  **변환(Transform)**: 사용자 B의 인덱스 값을 **+1** 해줍니다.
    - 원래 작업: `3번 자리에 '!' 추가`
    - 변환된 작업: `4번 자리에 '!' 추가`
4.  사용자 A의 **"nice"**에 변환된 작업을 적용합니다.
    - 결과: **"nice!"** (정확함!)

---

### 3. 요약하자면

- **OT의 논리**: "네가 3번 자리에 뭘 하겠다고 했지만, 내가 그 앞에 글자 하나를 끼워 넣었으니까, 너는 이제 **4번 자리**에 해야 해."
- **복잡성**: 만약 여러 명이 동시에 수십 개의 글자를 지우고 쓰고 한다면, 이 인덱스를 계산하는 로직이 매우 복잡해집니다.
- **사용처**: 그래서 OT는 보통 **중앙 서버**가 있는 시스템(Google Docs 등)에서 서버가 기준이 되어 모든 작업의 순서와 인덱스를 계산해 줄 때 주로 사용됩니다.

### 4. CRDT와의 차이점 (참고)

- **OT**: "내 위치는 **상대적**이야. 남이 편집하면 내 위치 번호를 바꿔줘." (번호표 방식)
- **CRDT**: "나는 위치 번호 안 써. 각 글자마다 **고유한 ID**가 있어. 내 ID는 절대 안 변해." (이름표 방식)

이제 OT가 왜 '변환(Transformation)'이라는 이름을 쓰는지 이해가 되셨나요? 작업의 상세 내용(인덱스 번호 등)을 상황에 맞춰서 변환하기 때문입니다.
