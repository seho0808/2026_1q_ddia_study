# 2판 Chapter 2: 신뢰성, 확장성, 유지보수성

이 장에서는 데이터 중심 애플리케이션의 중요한 비기능적 요구사항인 신뢰성, 확장성, 유지보수성에 대해 다룹니다. 추상적인 개념을 구체화하기 위해 소셜 네트워크(트위터/X) 사례 연구와 성능 측정 지표를 중심으로 설명합니다.

## 1. 요구사항: 기능적 vs 비기능적

애플리케이션을 구축할 때는 두 가지 유형의 요구사항을 고려해야 합니다.

- **기능적 요구사항 (Functional Requirements):**
  - 애플리케이션이 **무엇을 해야 하는지**에 대한 정의.
  - 예: 특정 화면, 버튼, 작업 수행 내용 등.
- **비기능적 요구사항 (Nonfunctional Requirements):**
  - 시스템의 **품질 속성** (작동 방식).
  - 예: 보안, 신뢰성(Reliability), 법적 준수, 확장성(Scalability), 유지보수성(Maintainability), 성능(속도).
  - 명시적으로 기록되지 않을 수 있지만, 기능만큼이나 중요함 (느리거나 자주 고장 나는 앱은 쓸모가 없음).

## 2. 사례 연구: 트위터(X) 타임라인

대규모 시스템에서 확장성 문제를 이해하기 위해, 사용자가 글을 쓰고 팔로우한 사람의 글을 보는 소셜 네트워크 서비스를 예로 듭니다.

### 2.1 가정 및 제약 조건

- **작업 부하:**
  - 초당 평균 5,800건의 포스팅 (피크 시 150,000건/초).
  - 타임라인 조회(읽기) 요청은 포스팅(쓰기)보다 훨씬 빈번함.
- **팔로우 관계:**
  - 사용자당 평균 팔로워/팔로잉 200명.
  - 편차가 매우 큼 (일부 연예인은 1억 명 이상의 팔로워 보유).

### 2.2 접근 방식 1: 풀 모델 (Pull Model / Polling)

- **방식:**
  - 글 작성 시 `Posts` 테이블에 단순히 저장.
  - 사용자가 타임라인을 조회할 때마다 쿼리 실행:
    1. 내가 팔로우하는 모든 사람 찾기 (`Follows` 테이블).
    2. 그들의 모든 글을 찾아 시간순 정렬 (`Posts` 테이블).
- **SQL 예시:**
  ```sql
  SELECT posts.*, users.* FROM posts
  JOIN follows ON posts.sender_id = follows.followee_id
  JOIN users ON posts.sender_id = users.id
  WHERE follows.follower_id = current_user
  ORDER BY posts.timestamp DESC LIMIT 1000
  ```
- **문제점:**
  - 읽기 부하가 매우 큼. 팔로우 수가 많은 사용자의 경우 쿼리 비용이 비쌈.
  - 많은 사용자가 동시에 조회하면 DB 부하가 감당하기 힘듦.

### 2.3 접근 방식 2: 푸시 모델 (Push Model / Fan-out on Write)

- **방식 (구체화된 뷰, Materialized View):**
  - 각 사용자별로 **홈 타임라인 캐시(리스트)**를 미리 생성해 둠.
  - 누군가 글을 쓰면, 그를 팔로우하는 **모든** 사용자의 타임라인 캐시에 새 글을 삽입 (Fan-out).
  - 읽기 요청 시 미리 계산된 캐시만 반환하면 되므로 매우 빠름 (O(1)).
- **장점:** 읽기 성능이 매우 우수하고 네트워크 부하가 적음.
- **단점 (쓰기 증폭):**
  - 글 작성 시 팔로워 수만큼 쓰기 작업 발생.
  - **유명인(Celebrity) 문제:** 팔로워가 수천만 명인 경우, 글 하나 작성 시 수천만 번의 업데이트가 필요하여 지연 발생.

### 2.4 하이브리드 접근 방식 (절충안)

- 대부분의 사용자는 **푸시 모델** 사용.
- 팔로워가 매우 많은 유명인(Celebrity)에 대해서는 **풀 모델** 사용.
- 타임라인 로딩 시, 일반 사용자들의 글(캐시됨)과 유명인의 글(그때그때 조회)을 합쳐서 보여줌.

## 3. 성능 기술하기 (Describing Performance)

시스템 성능을 논의할 때는 명확한 지표가 필요합니다.

### 3.1 처리량 (Throughput)

- **정의:** 시스템이 초당 처리할 수 있는 작업의 양.
- **단위:** 초당 요청 수(RPS, QPS), 초당 데이터 전송량 등.
- **예:** 초당 타임라인 쓰기 횟수, 초당 포스팅 수.

### 3.2 응답 시간 (Response Time)

- **정의:** 클라이언트가 요청을 보내고 응답을 받을 때까지 걸리는 **총 시간**.
- **구성 요소:**
  - **서비스 시간 (Service Time):** 실제 작업을 처리하는 시간.
  - **대기 시간 (Queueing Delay):** 처리 가능한 CPU/스레드를 기다리는 시간 (부하가 높을수록 급격히 증가).
  - **네트워크 지연 (Network Latency):** 데이터가 네트워크를 이동하는 시간.
- **주의:** **지연 시간(Latency)**은 주로 대기 시간(유휴 시간)을 의미하며, 응답 시간과 구분해서 사용해야 함.

### 3.3 평균 vs 백분위수 (Percentiles)

응답 시간은 매번 다르므로 단일 숫자가 아닌 **분포**로 이해해야 합니다.

- **평균 (Arithmetic Mean):**
  - 전체 합을 개수로 나눈 값.
  - 이상치(Outlier)에 의해 왜곡될 수 있어, "전형적인" 사용자 경험을 대변하지 못함.
- **중앙값 (Median, p50):**
  - 분포의 정중앙에 위치한 값.
  - 사용자의 50%가 이 시간보다 빨리 응답받음. 일반적인 대기 시간을 파악하기 좋음.
- **상위 백분위수 (Tail Latencies - p95, p99, p99.9):**
  - **p95:** 95%의 요청이 이 시간 내에 완료됨 (상위 5%의 느린 요청).
  - **중요성:**
    - 꼬리 지연(Tail Latency)은 사용자 경험에 큰 영향을 미침.
    - 보통 데이터가 많은 헤비 유저(VIP 고객)가 느린 응답을 겪을 확률이 높음 (데이터가 많아 처리가 오래 걸리므로).
    - 아마존 등은 내부 서비스 목표(SLO)를 p99.9 기준으로 설정하기도 함.

### 3.4 꼬리 지연 증폭 (Tail Latency Amplification)

- 하나의 사용자 요청을 처리하기 위해 여러 백엔드 서비스(마이크로서비스 등)를 호출해야 하는 경우 발생.
- 병렬로 호출하더라도, **가장 느린 응답** 하나가 전체 요청의 응답 시간을 결정함.
- 백엔드 호출이 많을수록 꼬리 지연(느린 응답)에 걸릴 확률이 높아짐.

### 3.5 성능 최적화와 지표 활용

- **SLO (Service Level Objective) / SLA (Service Level Agreement):** 서비스 가용성 및 성능 목표를 설정할 때 평균보다는 p99, p99.9 같은 백분위수를 사용하는 것이 좋음.
- **모니터링:** 평균값만 보지 말고 백분위수 그래프를 모니터링해야 실제 성능 문제를 파악 가능.
- **부하 대응:** 시스템이 과부하 상태가 되면 큐 대기 시간이 길어지고, 재시도(Retry) 폭풍으로 인해 시스템이 회복 불가능한 상태(Metastable Failure)에 빠질 수 있음. 이를 방지하기 위해 지수 백오프(Exponential Backoff), 서킷 브레이커, 부하 제한(Load Shedding) 등을 사용해야 함.

## 4. 신뢰성과 결함 내성 (Reliability and Fault Tolerance)

신뢰성은 "무언가 잘못되더라도 올바르게 동작함"을 의미합니다. 소프트웨어에서는 예상치 못한 상황이나 오류가 발생해도 시스템이 기능을 수행하는 것을 말합니다.

### 4.1 결함(Fault) vs 장애(Failure)

- **결함 (Fault):** 시스템의 **일부**가 제 기능을 멈추는 것 (예: 하드 디스크 고장, 프로세스 크래시).
- **장애 (Failure):** 시스템 **전체**가 사용자에게 서비스를 제공하지 못하는 것.
- **목표:** 결함(Fault)이 발생하더라도 장애(Failure)로 이어지지 않게 하는 것 (**결함 내성**, Fault Tolerance).
- **단일 실패 지점 (SPOF):** 해당 부분의 결함이 시스템 전체 장애를 유발하는 경우 (SPOF가 없어야 신뢰성 높은 시스템).

### 4.2 하드웨어 결함 (Hardware Faults)

- 하드 디스크, RAM, 전원 장치, 네트워크 케이블 등의 고장은 대규모 시스템에서 **일상적인** 일입니다.
- **대응 전략:** 하드웨어 구성 요소의 **이중화(Redundancy)**.
  - 디스크: RAID 구성.
  - 서버: 이중 전원, 핫 스왑 CPU.
  - 데이터센터: 예비 발전기, 배터리 백업.
- **클라우드 환경:** 단일 머신의 신뢰성보다 소프트웨어적인 결함 내성을 중시하며, **가용성 영역(Availability Zone)**을 활용해 지리적으로 분산시킴으로써 데이터센터 전체 장애에 대비합니다.

### 4.3 소프트웨어 결함 (Software Faults)

- 하드웨어 결함보다 더 큰 위협입니다. 노드 간의 **상관관계(Correlation)**가 높아 동시에 여러 노드에 영향을 줄 수 있기 때문입니다.
- **유형:**
  - 리눅스 커널 버그(Leap second), 특정 시간 경과 후 SSD 작동 중지 등의 체계적 오류.
  - 리소스(CPU, 메모리) 고갈을 유발하는 폭주 프로세스.
  - **연쇄 장애 (Cascading Failures):** 하나의 컴포넌트 장애가 다른 컴포넌트의 과부하를 유발하여 시스템 전체가 무너지는 현상.
- **대응:** 빈틈없는 테스트, 프로세스 격리, 죽은 프로세스의 자동 재시작, 모니터링 등.

### 4.4 인적 오류 (Human Errors)

- 운영자의 설정 실수 등이 하드웨어 결함보다 서비스 중단의 더 큰 원인이 됩니다.
- **대응 전략:**
  - 실수하기 쉬운 부분의 추상화 (잘못된 명령을 내리기 어렵게 만듦).
  - **샌드박스:** 실제 사용자에 영향 없이 실험할 수 있는 환경 제공.
  - **테스트:** 단위 테스트, 통합 테스트, 수동 테스트.
  - **빠른 복구:** 롤백, 점진적 배포(Rolling update).
  - **비난 없는 포스트모텀 (Blameless Postmortems):** 실수한 사람을 비난하지 않고, 시스템적 원인을 찾아 개선하는 문화.

### 4.5 카오스 엔지니어링 (Chaos Engineering)

- 신뢰성을 검증하기 위해 **고의로 결함을 주입**하는 기법 (예: 무작위로 프로세스 죽이기).
- 시스템이 결함을 자동으로 처리하고 복구하는 능력을 지속적으로 훈련시킵니다.

## 5. 확장성 (Scalability)

확장성은 "시스템이 현재보다 더 큰 부하를 처리할 수 있는가?"가 아니라, **"부하가 증가했을 때 어떻게 대처할 것인가?"**에 대한 문제입니다.

### 5.1 부하 기술하기 (Describing Load)

- 시스템의 부하를 측정하는 **부하 매개변수(Load Parameters)**를 정의해야 합니다.
- 예: 웹 서버의 초당 요청 수(RPS), DB의 읽기/쓰기 비율, 대화방의 동시 활성 사용자 수, 캐시 적중률 등.
- 트위터 사례처럼 평균적인 상황뿐만 아니라 병목 현상을 유발하는 **소수의 극단적인 케이스(예: 유명인)**도 고려해야 합니다.

### 5.2 성능과 자원의 관계

부하가 증가했을 때 다음 두 가지 관점에서 확장성을 논의합니다.

1. 자원을 그대로 두었을 때 성능이 얼마나 저하되는가?
2. 성능을 유지하기 위해 자원을 얼마나 늘려야 하는가?

### 5.3 확장 아키텍처

- **수직 확장 (Scale Up / Shared-Memory):**
  - 더 강력한 머신(CPU, RAM 추가)으로 이동.
  - **장점:** 단순함.
  - **단점:** 비용이 기하급수적으로 증가하며, 단일 머신의 성능 한계가 명확함.
- **수평 확장 (Scale Out / Shared-Nothing):**
  - 다수의 저렴한 머신에 부하를 분산.
  - **장점:** 선형적인 확장이 가능하고, 비용 효율적이며, 결함 내성을 갖추기 쉬움.
  - **단점:** 분산 시스템의 복잡성이 증가함 (데이터 분할, 일관성 유지 등).
- **공유 디스크 (Shared-Disk):**
  - 여러 머신이 네트워크 스토리지(NAS/SAN)를 공유.
  - 락(Lock) 경합 및 오버헤드로 확장성에 한계가 있음.
- **클라우드 네이티브 (Separation of Storage and Compute):**
  - **저장소와 연산의 분리**. 무상태(Stateless) 연산 노드는 쉽게 확장하고, 데이터는 별도의 최적화된 스토리지 서비스(S3 등)에 위임.

### 5.4 확장성 원칙

- **"만능 확장 소스(Magic Scaling Sauce)는 없다":** 모든 상황에 맞는 단일 아키텍처는 없으며, 애플리케이션 특성에 맞춰 설계해야 합니다.
- **미래 대비:** 현재보다 10배(One order of magnitude) 정도의 부하를 처리할 수 있도록 설계하되, 그 이상을 미리 과도하게 최적화하는 것은 비효율적입니다.
- **단순성:** 단일 노드로 충분하다면 복잡한 분산 시스템을 도입하지 않는 것이 좋습니다.

## 6. 유지보수성 (Maintainability)

소프트웨어 비용의 대부분은 초기 개발이 아니라 **지속적인 유지보수**(버그 수정, 운영 유지, 기능 추가, 기술 부채 상환 등)에서 발생합니다. 미래의 고통을 최소화하기 위해 다음 세 가지 원칙을 고려해야 합니다.

### 6.1 운용성 (Operability)

- **목표:** 운영팀이 시스템을 원활하게 운영할 수 있게 돕는 것.
- **중요성:** "좋은 운영은 나쁜 소프트웨어의 한계를 극복할 수 있지만, 좋은 소프트웨어라도 운영이 나쁘면 신뢰할 수 없다."
- **좋은 운용성을 위한 요소:**
  - **가시성(Visibility):** 런타임 동작과 내부 상태에 대한 모니터링 및 관측성(Observability) 제공.
  - **자동화:** 표준적인 유지보수 작업의 자동화.
  - **문서화:** 시스템 동작 방식에 대한 명확한 이해 제공 ("X를 하면 Y가 일어난다").
  - **예측 가능성:** 놀라운 동작 최소화.

### 6.2 단순성 (Simplicity)

- **목표:** 시스템의 복잡도를 관리하여 새로운 엔지니어가 시스템을 쉽게 이해할 수 있게 하는 것.
- **복잡성의 문제:** "진흙덩어리(Big Ball of Mud)"가 되면 수정 시 버그 발생 위험이 커지고 유지보수 비용이 급증함.
- **추상화 (Abstraction):** 복잡성을 관리하는 최고의 도구.
  - 세부 구현(우발적 복잡성)을 깔끔한 인터페이스 뒤로 숨김.
  - 예: SQL은 디스크/메모리 구조, 동시성 제어 등의 복잡성을 숨긴 훌륭한 추상화입니다.

### 6.3 발전성 (Evolvability)

- **목표:** 미래의 요구사항 변경에 맞춰 시스템을 쉽게 변경할 수 있게 하는 것.
- **애자일(Agile) & TDD:** 변화에 적응하기 위한 조직적/기술적 프레임워크.
- **데이터 시스템 수준의 발전성:**
  - 시스템을 구성하는 서비스나 데이터베이스 구조를 변경하기 쉬워야 함.
  - **불가역성 최소화:** 되돌릴 수 없는 결정(Irreversible decisions)을 피하고, 쉽게 롤백할 수 있는 구조가 유연성을 높여줌.

## 7. 요약

이 장에서는 데이터 시스템의 세 가지 핵심 비기능적 요구사항을 살펴보았습니다.

1.  **신뢰성 (Reliability):** 결함(Fault)이 발생해도 장애(Failure)로 이어지지 않도록 내성을 갖추는 것.
2.  **확장성 (Scalability):** 부하가 증가해도 성능을 유지할 수 있는 능력과 전략.
3.  **유지보수성 (Maintainability):** 운영, 이해, 수정이 쉬운 시스템을 만드는 것 (운용성, 단순성, 발전성).

이 책의 나머지 부분에서는 이러한 목표를 달성하기 위한 구체적인 기술과 알고리즘을 다룹니다.
