# 개요

## 1. 트랜잭션의 존재 이유: "단순화(Simplification)"

트랜잭션은 자연 법칙이 아니라, **애플리케이션 프로그래밍 모델을 단순화하기 위해 만든 추상화 계층**입니다. 데이터 시스템에서 발생할 수 있는 수많은 복잡한 오류 상황을 데이터베이스가 대신 처리해줌으로써, 개발자가 비즈니스 로직에 집중할 수 있게 돕습니다.

## 2. 데이터 시스템에서 발생할 수 있는 가혹한 현실 (Faults)

신뢰성 있는 시스템을 만들기 위해서는 다음과 같은 결함들을 반드시 처리해야 합니다.

- **하드웨어/소프트웨어 결함:** 쓰기 작업 도중 언제든 DB 소프트웨어나 하드웨어가 중단될 수 있음.
- **애플리케이션 크래시:** 일련의 작업 도중 애플리케이션이 갑자기 종료될 수 있음.
- **네트워크 단절:** 앱과 DB 사이, 혹은 DB 노드 간의 연결이 예기치 않게 끊길 수 있음.
- **동시성 문제 (Race Conditions):** 여러 클라이언트가 동시에 데이터를 쓰면서 서로의 변경사항을 덮어쓰거나, 부분적으로 업데이트된 잘못된 데이터를 읽을 수 있음.

## 3. 트랜잭션의 핵심 개념

- **논리적 단위:** 여러 개의 읽기와 쓰기 작업을 하나의 논리적 단위로 묶는 것.
- **전부 아니면 전무 (All-or-Nothing):**
  - **Commit (성공):** 모든 작업이 성공적으로 반영됨.
  - **Abort/Rollback (실패):** 하나라도 실패하면 전체가 취소됨. 애플리케이션은 부분 실패(Partial Failure)를 걱정할 필요 없이 안전하게 재시도할 수 있음.
- **안전성 보장 (Safety Guarantees):** 특정 오류 시나리오나 동시성 문제를 DB가 책임지고 해결해 주겠다는 약속.

## 4. 트랜잭션 도입의 딜레마

모든 애플리케이션이 트랜잭션을 필요로 하는 것은 아닙니다.

- **트랜잭션을 사용하는 이유:** 데이터의 신뢰성이 매우 중요한 경우(예: 회계 시스템). 영국 우체국 호라이즌 스캔들(Horizon scandal) 사례처럼 ACID 트랜잭션의 부재는 치명적인 결과를 초래할 수 있음.
- **트랜잭션을 포기/완화하는 이유:** 더 높은 성능(Performance)이나 가용성(Availability)을 확보하기 위해.

## 5. 이 장에서 다룰 주요 주제 (미리보기)

1.  **동시성 제어 (Concurrency Control):** 발생 가능한 다양한 경쟁 상태(Race conditions) 탐구.
2.  **격리 수준 (Isolation Levels):**
    - Read Committed (커밋된 읽기)
    - Snapshot Isolation (스냅숏 격리)
    - Serializability (직렬성)
3.  **분산 트랜잭션 (Distributed Transactions):** 분산 환경에서 원자성을 달성하기 위한 **2단계 커밋(2PC, Two-Phase Commit)** 프로토콜.

---

### 💡 핵심 문구 (James Corbett, Google Spanner)

> "트랜잭션이 없어서 발생하는 문제를 해결하기 위해 항상 우회 코드를 짜는 것보다, 일단 트랜잭션을 사용하고 나중에 병목 현상이 발생했을 때 성능 문제를 해결하는 것이 훨씬 낫다."

<br/>
<br/>

# 트랜잭션의 역사와 발전 (What Exactly Is a Transaction?)

### 1) 전통적 관계형 DB (1975년 ~ 현재)

- **기원:** 1975년 IBM System R(최초의 SQL DB)에서 정립된 스타일이 현재까지 이어짐.
- **지속성:** MySQL, PostgreSQL, Oracle 등 현대 주요 DB의 트랜잭션 방식은 50년 전과 놀라울 정도로 유사함.

### 2) NoSQL의 등장과 트랜잭션의 희생 (2000년대 후반)

- **목표:** 새로운 데이터 모델, 복제(Replication), 샤딩(Sharding)을 통한 확장성 확보.
- **결과:** 확장성을 위해 트랜잭션을 포기하거나, 매우 약한 수준의 보장만을 제공함. "트랜잭션은 확장 불가능하다"는 믿음이 팽배했음.

### 3) NewSQL의 등장 (최근)

- **반전:** CockroachDB, TiDB, Spanner 등은 **샤딩과 합의 프로토콜(Consensus)**을 결합하여, 대규모 시스템에서도 강력한 ACID 보장이 가능함을 증명함.

---

<br/>
<br/>

# ACID의 의미와 한계

ACID는 1983년 결함 허용(Fault-tolerance) 용어를 정립하기 위해 만들어졌으나, 오늘날에는 DB마다 구현 방식이 다르고 의미가 모호해져 일종의 **마케팅 용어**처럼 사용되기도 합니다. (반대 개념으로 BASE가 있음)

## 1) Atomicity (원자성)

- **핵심:** "전부 아니면 전무(All-or-Nothing)".
- **오해 주의:** 멀티스레드 프로그래밍의 '원자성(동시성 관련)'과는 의미가 다름. ACID의 원자성은 **동시성과 무관**함.
- **기능:** 여러 쓰기 작업 중 결함(크래시, 네트워크 단절 등)이 발생하면, 지금까지의 모든 쓰기를 무시(Abort/Undo)함.
- **이점:** 애플리케이션은 "부분 완료"를 걱정할 필요 없이 안전하게 재시도할 수 있음. (저자는 '원자성'보다 **'중단 가능성(Abortability)'**이 더 적절한 표현이라고 언급함)

## 2) Consistency (일관성)

- **핵심:** 데이터베이스가 "좋은 상태(Good State)"에 있어야 한다는 애플리케이션 관점의 개념.
- **특징:** 데이터의 **불변식(Invariants)**이 항상 만족되어야 함 (예: 회계의 대차대조표 일치).
- **책임 분담:**
  - **DB:** 외래키, 유니크 제약 조건 등을 통해 일부 강제 가능.
  - **애플리케이션:** 대부분의 복잡한 불변식은 앱 로직에서 올바르게 정의해야 함.
- **결론:** ACID 중 유일하게 **애플리케이션의 책임**이 큰 요소이며, DB만의 속성이 아님.

## 3) Isolation (격리성)

- **핵심:** 동시에 실행되는 트랜잭션들이 서로의 발을 뭉개지 않도록 격리함.
- **이론적 정의 (Serializability):** 각 트랜잭션이 DB를 혼자 사용하는 것처럼 실행되어, 최종 결과가 트랜잭션들을 하나씩 순서대로 실행한 결과와 같아야 함.
- **현실적 타협:** 직렬성(Serializability)은 성능 비용이 크기 때문에, 많은 DB가 더 약한 격리 수준(예: Snapshot Isolation)을 사용함. 이로 인해 일부 경쟁 상태(Race Condition)가 발생할 수 있음.

## 4) Durability (지속성)

- **핵심:** 트랜잭션이 성공적으로 커밋되면, 하드웨어 결함이나 크래시가 발생해도 데이터가 손실되지 않는다는 약속.
- **구현 방식:**
  - **단일 노드:** 비휘발성 저장소(HDD/SSD) 기록, `fsync` 호출, 쓰기 전 로그(WAL) 사용.
  - **복제 시스템:** 여러 노드로 데이터 복사 완료 확인.
- **현실적 한계:** **완벽한 지속성은 존재하지 않음.** (모든 백업이 동시에 파괴되는 경우 등). 지속성은 위험을 줄이기 위한 여러 기술(디스크 기록, 복제, 백업)의 조합으로 달성됨.

---

### 💡 요약 및 시사점

- **트랜잭션은 선택이다:** 모든 시스템이 트랜잭션을 가져야 하는 것은 아니며, 성능과 가용성 사이의 트레이드오프를 이해해야 합니다.
- **용어의 모호성:** 특히 'Consistency'와 'Isolation'은 문맥에 따라 의미가 매우 다양하므로 주의 깊게 살펴봐야 합니다.
- **결함 허용의 핵심:** 트랜잭션의 가장 큰 가치는 **"오류 발생 시 안전하게 중단(Abort)하고 재시도할 수 있는 능력"**에 있습니다.

<br/>
<br/>

# 단일 객체 및 다중 객체 연산 상세 정리

## 1. 다중 객체 트랜잭션 (Multi-Object Transactions)

여러 개의 데이터 항목(행, 문서, 레코드)을 한꺼번에 수정할 때 원자성과 격리성이 어떻게 적용되는지 설명합니다.

- **필요성:** 여러 조각의 데이터를 동기화해야 할 때 필수적입니다.
  - **예시 (이메일 앱):** 새 이메일이 오면 `emails` 테이블에 행을 추가하고, `users` 테이블의 `unread_counter`를 증가시켜야 합니다.
- **격리성 위반 (Figure 8-2):** 한 트랜잭션이 이메일은 넣었지만 카운터는 아직 올리지 못한 상태에서 다른 사용자가 읽으면, "읽지 않은 메일은 있는데 카운터는 0"인 **불일치 상태**를 보게 됩니다.
- **원자성 위반 (Figure 8-3):** 카운터 업데이트 도중 오류가 발생했는데 원자성이 없다면, 이메일만 추가되고 카운터는 영원히 어긋나게 됩니다.
- **구현 방식:** 관계형 DB에서는 보통 클라이언트의 **TCP 연결**을 기반으로 `BEGIN`과 `COMMIT` 사이의 모든 작업을 하나로 묶습니다.

## 2. 단일 객체 쓰기 (Single-Object Writes)

트랜잭션이 보통 여러 객체를 묶는 것을 의미하지만, 단일 객체(예: 20KB 크기의 JSON 문서)를 수정할 때도 원자성과 격리성이 필요합니다.

- **발생 가능한 문제:**
  - 네트워크 단절로 인한 불완전한 JSON 저장.
  - 정전으로 인해 이전 값과 새 값이 섞여서 저장됨.
  - 쓰기 도중 다른 클라이언트가 부분적으로 업데이트된 값을 읽음.
- **해결책:** 대부분의 저장 엔진은 단일 객체 수준에서 **로그(원자성용)**와 **잠금(격리성용)**을 사용하여 이를 방지합니다.
- **고급 연산:** `Increment`(원자적 증가), `Compare-and-Set`(조건부 쓰기) 등은 유용하지만, 엄밀히 말해 여러 객체를 아우르는 "트랜잭션"은 아닙니다.

## 3. 다중 객체 트랜잭션이 왜 필요한가?

NoSQL 등에서 단일 객체 연산만 제공하기도 하지만, 다음과 같은 이유로 다중 객체 트랜잭션은 여전히 중요합니다.

1.  **참조 무결성:** 관계형 모델의 외래 키나 그래프 모델의 에지(Edge)를 일관되게 유지해야 함.
2.  **비정규화(Denormalization) 데이터 동기화:** 문서 DB에서 여러 문서에 흩어진 중복 정보를 동시에 업데이트해야 할 때.
3.  **보조 인덱스(Secondary Indexes):** 데이터가 바뀔 때마다 인덱스도 함께 업데이트되어야 함. 인덱스와 실제 데이터가 불일치하면 검색 결과가 부정확해짐.

## 4. 오류 처리와 중단(Aborts)

트랜잭션의 핵심은 **"오류 발생 시 중단(Abort)하고 안전하게 재시도할 수 있다"**는 철학입니다.

- **ACID DB의 철학:** 원자성, 격리성, 지속성이 위협받느니 차라리 트랜잭션을 완전히 포기(Abort)하는 쪽을 택합니다.
- **리더리스 복제(Leaderless Replication)와의 차이:** 이들은 "최선을 다할 뿐(Best effort)", 오류가 나도 이미 수행한 작업을 되돌리지 않습니다. 복구 책임은 애플리케이션에 있습니다.
- **재시도(Retry) 시 주의사항:**
  - **네트워크 타임아웃:** 실제로는 성공했는데 클라이언트가 응답만 못 받은 경우, 재시도하면 중복 실행될 수 있음 (**멱등성** 필요).
  - **과부하:** 충돌로 인한 실패 시 무작정 재시도하면 시스템 부하가 가중됨 (**지수 백오프** 필요).
  - **영구적 오류:** 제약 조건 위반 등은 재시도해도 해결되지 않음.
  - **외부 부수 효과:** 이메일 발송 등 DB 외부 작업은 롤백되지 않으므로 주의해야 함.

---

### 💡 핵심 요약

- **단일 객체 연산**은 데이터 오염을 막아주지만, **다중 객체 트랜잭션**은 여러 데이터 간의 논리적 일관성을 유지해 줍니다.
- 트랜잭션의 진정한 가치는 **오류 처리의 단순화**에 있습니다. 애플리케이션은 복잡한 부분 실패 시나리오를 고민하는 대신, 실패 시 **"안전하게 재시도"**하는 전략을 취할 수 있습니다.

<br/>
<br/>

# Weak Isolation Levels

## 1. 약한 격리 수준 (Weak Isolation Levels) 개요

### 1) 동시성 문제의 본질

- **발생 조건:** 한 트랜잭션이 다른 트랜잭션에 의해 동시에 수정되고 있는 데이터를 읽거나, 두 트랜잭션이 동시에 같은 데이터를 수정하려고 할 때 발생합니다.
- **특징:** 테스트로 발견하기 매우 어렵습니다. 특정 타이밍에만 발생하며 재현이 어렵기 때문입니다.
- **현실적 타협:** 이론적으로는 **직렬성(Serializability)**이 가장 안전하지만, 성능 비용이 크기 때문에 많은 DB가 더 약한 격리 수준을 기본으로 사용합니다.

### 2) 위험성

- 약한 격리 수준은 이해하기 어렵고 미묘한 버그를 유발할 수 있습니다.
- 실제로 비트코인 거래소 파산, 금융 감사 문제, 고객 데이터 오염 등의 심각한 사고 사례가 존재합니다.
- 해커는 동시성 버그를 악용하기 위해 의도적으로 대량의 동시 요청을 보낼 수 있으므로, 보안 측면에서도 중요합니다.

---

## 2. 커밋된 읽기 (Read Committed)

가장 기본적인 격리 수준으로, 다음 두 가지를 보장합니다.

## 1) 더러운 읽기 방지 (No Dirty Reads)

- **정의:** 트랜잭션이 아직 커밋되지 않은(uncommitted) 다른 트랜잭션의 데이터를 읽는 것을 **'더러운 읽기(Dirty Read)'**라고 하며, 이를 방지합니다.
- **방지해야 하는 이유:**
  1.  **부분적 업데이트 방지:** 여러 로우를 업데이트할 때, 일부만 반영된 상태를 다른 사용자가 보게 되면 혼란을 줍니다(예: 이메일은 왔는데 카운터는 0인 상태).
  2.  **연쇄적 중단(Cascading Aborts) 방지:** 만약 A가 쓴 데이터를 B가 읽었는데, A가 나중에 롤백(Abort)된다면 B도 함께 취소되어야 하는 복잡한 문제가 발생합니다.

## 2) 더러운 쓰기 방지 (No Dirty Writes)

- **정의:** 먼저 진행 중인 트랜잭션이 쓴 값을(아직 커밋되지 않은 상태에서) 다른 트랜잭션이 덮어쓰는 것을 **'더러운 쓰기(Dirty Write)'**라고 하며, 이를 방지합니다.
- **방지해야 하는 이유:**
  - **데이터 뒤섞임 방지 (Figure 8-5 중고차 사례):**
    - A가 차를 사고(목록 업데이트 + 송장 발송), B도 동시에 같은 차를 사려고 할 때.
    - 더러운 쓰기가 허용되면 '목록에는 B가 구매자인데, 송장은 A에게 발송되는' 끔찍한 혼선이 생길 수 있습니다.
- **한계:** 하지만 '카운터 증가'와 같은 **갱신 분실(Lost Update)** 문제는 해결하지 못합니다. (두 쓰기가 모두 커밋된 후에 발생하는 문제이기 때문)

---

## 3. 구현 방식 (Implementation)

### 1) 더러운 쓰기 방지: 행 단위 잠금 (Row-level Locks)

- 데이터를 수정하려는 트랜잭션은 해당 로우에 대한 **잠금(Lock)**을 획득해야 합니다.
- 트랜잭션이 끝날 때까지 잠금을 보유하며, 다른 트랜잭션은 대기해야 합니다.

### 2) 더러운 읽기 방지: 두 가지 방법

1.  **잠금 방식 (Locking):** 읽기 전용 트랜잭션도 잠시 잠금을 얻게 하는 방식. 하지만 쓰기 트랜잭션이 길어지면 모든 읽기 작업이 멈추는 성능 문제가 있어 잘 쓰이지 않습니다.
2.  **버전 관리 방식 (MVCC - 추천 방식):**
    - DB가 **과거의 커밋된 값**과 현재 진행 중인 트랜잭션이 쓴 **새로운 값**을 모두 기억합니다.
    - 다른 트랜잭션이 읽으려고 하면, 현재 진행 중인 트랜잭션이 커밋되기 전까지는 그냥 **과거의 커밋된 값**을 보여줍니다.
    - 커밋이 완료된 후에야 비로소 새로운 값을 보여주기 시작합니다.

---

## 4. 더 약한 수준: 커밋되지 않은 읽기 (Read Uncommitted)

- 더러운 쓰기는 막지만, **더러운 읽기는 허용**하는 수준입니다.
- 성능은 가장 좋지만 데이터 일관성이 매우 취약합니다.

---

### 💡 요약

**커밋된 읽기(Read Committed)**는 "내가 읽는 데이터는 확실히 커밋된 것이며, 내가 쓰는 동안 남이 내 데이터를 덮어쓰지 못한다"는 최소한의 안전장치입니다. 하지만 **'비반복 읽기(Non-repeatable Read)'**와 같은 더 복잡한 동시성 문제는 여전히 발생할 수 있으며, 이는 다음 단계인 **'스냅숏 격리(Snapshot Isolation)'**에서 다루게 됩니다.

---

<br/>
<br/>

# Commited Read 보다 더 높은 단계

## 1. 스냅숏 격리 (Snapshot Isolation)

### 1) 커밋된 읽기(Read Committed)의 한계: 읽기 스큐(Read Skew)

- **문제 상황:** 한 트랜잭션 내에서 여러 데이터를 읽을 때, 다른 트랜잭션이 그 사이 일부 데이터를 수정하고 커밋하면 **데이터의 일관성이 깨진 상태**를 보게 됩니다.
- **예시:** 계좌 A에서 B로 100원을 송금하는 도중, 사용자가 A 계좌(송금 후 -100원)와 B 계좌(송금 전 상태)를 각각 읽으면 총액이 100원 사라진 것처럼 보입니다.
- **특징:** 이를 **비반복 읽기(Non-repeatable Read)**라고도 하며, 커밋된 데이터만 읽었으므로 '커밋된 읽기' 수준에서는 허용되는 현상입니다.
- **심각성:** 일시적인 조회라면 새로고침으로 해결되지만, **백업(Backups)**이나 **분석 쿼리(Analytic Queries)**에서는 영구적인 데이터 오류나 잘못된 분석 결과를 초래합니다.

### 2) 스냅숏 격리의 핵심 개념

- **정의:** 각 트랜잭션은 **일관된 스냅숏**으로부터 데이터를 읽습니다. 즉, 트랜잭션이 시작된 시점에 커밋된 데이터만 보이며, 이후 다른 트랜잭션이 데이터를 바꿔도 이 트랜잭션은 **과거의 고정된 데이터**만 봅니다.
- **원칙:** **"읽는 자는 쓰는 자를 막지 않고, 쓰는 자는 읽는 자를 막지 않는다."** (Readers never block writers, and writers never block readers)

### 3) 구현: 다중 버전 동시성 제어 (MVCC)

- **동작 원리:** DB는 한 로우의 여러 커밋된 버전을 동시에 유지합니다.
- **트랜잭션 ID (txid):** 모든 트랜잭션은 고유하고 증가하는 ID를 가집니다. 데이터 쓰기 시 해당 `txid`가 기록됩니다.
- **가시성 규칙 (Visibility Rules):**
  1.  트랜잭션 시작 시점에 이미 커밋된 데이터만 보임.
  2.  진행 중이거나 나중에 시작된 트랜잭션의 쓰기는 무시함.
  3.  삭제된 데이터도 삭제를 요청한 트랜잭션이 커밋되기 전까지는 계속 보임.
- **장점:** 잠금 경쟁 없이 긴 읽기 작업을 수행할 수 있습니다.

---

## 2. 갱신 분실 (Lost Update) 문제와 해결책

스냅숏 격리가 "읽기 전용 트랜잭션"의 문제를 해결한다면, **갱신 분실**은 "동시 쓰기 트랜잭션" 사이에서 발생하는 문제입니다.

### 1) 문제 상황 (Read-Modify-Write)

두 클라이언트가 동시에 데이터를 읽고 수정하여 다시 쓸 때, 나중에 쓴 값이 먼저 쓴 값을 덮어써서 **먼저 수행된 수정 사항이 사라지는 현상**입니다. (예: 카운터 증가, 위키 페이지 동시 수정)

id name age version
1223 seho 27 1

tx1
id name age version
1223 seho 28 2

tx2
id name age version
1223 seho 37 2

### 2) 해결 방안

#### ① 원자적 쓰기 연산 (Atomic Write Operations)

- **방법:** `UPDATE counters SET value = value + 1 WHERE key = 'foo';`와 같이 DB가 직접 연산을 수행하게 함.
- **장점:** 애플리케이션에서 읽고 수정할 필요가 없어 가장 안전하고 성능이 좋습니다.

#### ② 명시적 잠금 (Explicit Locking)

- **방법:** `SELECT ... FOR UPDATE`를 사용하여 읽을 때부터 해당 로우에 잠금을 겁니다.
- **주의:** 로직이 복잡해지면 데드락(Deadlock) 위험이 있습니다.

#### ③ 갱신 분실 자동 감지 (Automatic Detection)

- **방법:** 트랜잭션들이 평소처럼 실행되다가, 커밋 시점에 갱신 분실이 감지되면 DB가 트랜잭션을 중단(Abort)시키고 재시도를 유도합니다.
- **특징:** PostgreSQL(Repeatable Read), Oracle(Serializable) 등에서 지원하지만, **MySQL(InnoDB)은 이를 감지하지 못하므로 주의**해야 합니다.

#### ④ 조건부 쓰기 (Compare-and-Set / Optimistic Locking)

- **방법:** `UPDATE ... SET content = 'new' WHERE id = 1 AND content = 'old';`와 같이 이전에 읽은 값과 일치할 때만 쓰기를 수행합니다.
- **특징:** 트랜잭션 기능이 없는 DB에서 유용하며, 보통 버전 번호를 사용하여 구현합니다.

---

## 3. 명칭의 혼란 (Naming Confusion)

- **표준의 부재:** SQL 표준 정의가 모호하여 DB마다 용어가 제각각입니다.
- **PostgreSQL:** 스냅숏 격리를 **"Repeatable Read"**라고 부릅니다.
- **Oracle:** 스냅숏 격리를 **"Serializable"**이라고 부릅니다.
- **결론:** 사용하는 DB의 공식 문서에서 해당 격리 수준이 실제로 어떤 보장을 제공하는지 반드시 확인해야 합니다.

---

# 쓰기 스큐(Write Skew)와 팬텀(Phantoms) Reads

## 1. 쓰기 스큐 (Write Skew)

### 1) 정의 및 특징

- **정의:** 두 트랜잭션이 동일한 데이터를 읽고, 그 중 **서로 다른 객체**를 업데이트할 때 발생하는 경쟁 상태입니다.
- **특징:**
  - '더러운 쓰기'나 '갱신 분실'이 아닙니다(서로 다른 객체를 수정하므로).
  - 두 트랜잭션이 순차적으로 실행되었다면 발생하지 않았을 비정상적인 결과가 나타납니다.
  - **갱신 분실의 일반화된 형태**로 볼 수 있습니다.

### 2) 대표 사례: 병원 당직 의사 (Figure 8-8)

- **상황:** 최소 1명의 의사는 당직을 서야 한다는 규칙이 있음. 현재 A와 B 두 명이 당직 중.
- **사건:** A와 B가 동시에 당직 취소를 요청.
- **결과:**
  1.  A의 트랜잭션: "현재 당직이 2명인가?" → YES → A 취소 커밋.
  2.  B의 트랜잭션: "현재 당직이 2명인가?" → YES (스냅숏 격리이므로 A의 수정을 못 봄) → B 취소 커밋.
  3.  최종적으로 당직 의사가 **0명**이 되어 규칙이 위반됨.

### 3) 쓰기 스큐 방지 방법

- **단일 객체 연산:** 여러 객체가 연관되므로 도움이 되지 않음.
- **자동 감지:** PostgreSQL, MySQL, Oracle 등의 스냅숏 격리 수준은 쓰기 스큐를 자동으로 감지하지 못함.
- **제약 조건:** 여러 객체에 걸친 제약 조건(예: "합계가 1 이상이어야 함")은 대부분의 DB에서 지원하지 않음.
- **해결책:**
  1.  **직렬성 격리(Serializable Isolation):** 가장 확실한 해결책.
  2.  **명시적 잠금 (SELECT FOR UPDATE):** 트랜잭션이 의존하는 모든 로우를 명시적으로 잠가서 다른 트랜잭션의 수정을 막음.

---

## 2. 팬텀 (Phantoms)

### 1) 정의

- **정의:** 한 트랜잭션의 쓰기 작업이 다른 트랜잭션의 **검색 질의(Search Query) 결과 집합을 바꾸는 현상**입니다.
- **스냅숏 격리와의 관계:** 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 방지하지만, 읽기-쓰기 트랜잭션에서는 위와 같은 쓰기 스큐를 유발할 수 있습니다.

### 2) 팬텀이 발생하는 패턴

1.  `SELECT`로 특정 조건(예: 빈 회의실, 중복되지 않은 사용자명)을 만족하는지 확인.
2.  결과에 따라 작업을 진행할지 결정.
3.  작업 진행 시 `INSERT`, `UPDATE`, `DELETE` 수행. 이 작업이 1번 단계의 전제 조건을 바꿔버림.

### 3) 잠금의 한계

의사 당직 예제에서는 기존 로우를 수정하므로 `FOR UPDATE`로 잠글 수 있지만, **"존재하지 않는 로우"**를 찾는 경우(예: 회의실 예약)에는 잠글 대상이 없어서 `FOR UPDATE`가 효과가 없습니다.

---

## 3. 충돌 구체화 (Materializing Conflicts)

팬텀 문제를 해결하기 위해 **잠글 대상이 없는 곳에 인위적으로 잠금 객체를 만드는 기법**입니다.

- **예시 (회의실 예약):** 모든 회의실과 모든 시간대(예: 15분 단위)에 대한 로우를 미리 만들어둔 `slots` 테이블을 생성합니다. 예약 시 해당 시간대의 로우를 `SELECT FOR UPDATE`로 잠급니다.
- **단점:**
  - 구현이 어렵고 오류가 발생하기 쉬움.
  - 동시성 제어 메커니즘이 애플리케이션 데이터 모델에 노출되어 구조가 지저분해짐.
- **권장:** 이 방법은 **최후의 수단**으로만 고려해야 하며, 가능하면 **직렬성 격리 수준**을 사용하는 것이 훨씬 바람직합니다.

---

### 💡 추가 사례들

- **회의실 예약:** 동시에 같은 방을 예약하는 문제.
- **멀티플레이어 게임:** 두 유저가 동시에 같은 위치로 말을 이동하는 문제.
- **사용자명 선점:** 동일한 아이디로 동시에 가입하는 문제 (유니크 제약 조건으로 해결 가능).
- **이중 지출 (Double-spending):** 잔액이 마이너스가 되도록 동시에 돈을 쓰는 문제.

---

<br/>
<br/>

# 직렬성 (Serializability) 개요

### 1) 필요성

- **격리 수준의 혼란:** "Repeatable Read"와 같은 약한 격리 수준은 DB마다 구현이 다르고 이해하기 어려워, 대규모 애플리케이션에서 동시성 버그를 유발하기 쉽습니다.
- **도구의 부재:** 정적 분석이나 테스트만으로는 비결정적인 동시성 버그(Race Condition)를 완벽히 찾아낼 수 없습니다.
- **최선의 해결책:** 연구자들은 1970년대부터 **"가장 강력한 격리 수준인 직렬성을 사용하라"**고 권고해 왔습니다.

### 2) 정의

- 여러 트랜잭션이 병렬로 실행되더라도, 그 결과가 **트랜잭션을 한 번에 하나씩 순차적으로 실행했을 때와 동일함**을 보장합니다.
- 즉, 데이터베이스가 모든 가능한 경쟁 상태(Race Condition)를 방지해 줍니다.

### 3) 구현 기술 (세 가지 방식)

1.  **실제 순차 실행 (Actual Serial Execution):** 단일 스레드에서 순서대로 실행.
2.  **2단계 잠금 (2PL, Two-Phase Locking):** 수십 년간 표준이었던 비관적 방식.
3.  **직렬성 스냅숏 격리 (SSI, Serializable Snapshot Isolation):** 낙관적 방식의 최신 기술.

---

# 실제 순차 실행 (Actual Serial Execution)

가장 단순한 방법으로, **단일 스레드에서 한 번에 하나의 트랜잭션만 실행**하여 동시성 문제 자체를 원천 차단합니다.

### 1) 가능해진 배경 (2000년대 이후)

- **저렴해진 RAM:** 전체 활성 데이터셋을 메모리에 유지(In-memory)할 수 있게 되어, 디스크 I/O 대기 시간이 사라졌습니다.
- **OLTP의 특성:** 대부분의 트랜잭션은 짧고 빠릅니다. 긴 분석용 쿼리는 스냅숏 격리를 통해 실행 루프 밖에서 처리할 수 있습니다.

### 2) 상호작용 방식의 변화: 스토어드 프로시저 (Stored Procedures)

- **전통적 방식의 문제:** 애플리케이션과 DB 사이의 네트워크 통신(Round-trip) 대기 시간 동안 단일 스레드 DB는 아무것도 못 하고 놀게 됩니다.
- **해결책:** 트랜잭션 코드 전체를 DB에 미리 제출하여 실행하는 **스토어드 프로시저** 방식을 사용합니다. (Figure 8-9 참고)

### 3) 스토어드 프로시저의 명암

- **단점 (과거의 악명):** 벤더마다 언어가 다르고(PL/SQL 등), 디버깅/버전 관리/테스트가 어렵습니다. 잘못 작성된 코드가 DB 전체 성능을 망칠 수 있습니다.
- **현대적 개선:** Java, Groovy, Lua, JavaScript 등 범용 언어를 사용하며, 메모리 내 실행을 통해 매우 높은 처리량을 달성합니다 (VoltDB, Redis, Datomic 등).

### 4) 제약 사항과 한계

- **단일 코어의 한계:** 처리량이 단일 CPU 코어의 성능으로 제한됩니다.
- **샤딩(Sharding):** 여러 코어를 활용하기 위해 데이터를 샤딩할 수 있지만, **여러 샤드에 걸친 트랜잭션(Cross-shard)**은 조율 비용 때문에 성능이 급격히 떨어집니다.
- **결정론적 실행:** 복제를 위해 스토어드 프로시저가 모든 노드에서 동일한 결과를 내야 합니다 (예: 현재 시간 조회 시 특수 API 사용).

---

# 3. 실제 순차 실행의 요약 및 적용 조건

이 방식은 다음과 같은 제약 조건 하에서 직렬성 격리를 달성하는 매우 효율적인 방법입니다.

1.  **작고 빠른 트랜잭션:** 느린 트랜잭션 하나가 전체 시스템을 멈출 수 있습니다.
2.  **메모리 내 데이터셋:** 데이터가 메모리에 들어갈 수 있는 크기여야 합니다.
3.  **낮은 쓰기 처리량:** 단일 CPU 코어에서 감당 가능하거나, 샤드 간 조율이 필요 없는 구조여야 합니다.

---

<br/>
<br/>
1. 주요 구독 보안 서비스 종류

망 구성도에 반영해야 할 핵심 보안 서비스들은 다음과 같습니다.

WAF (Web Application Firewall): 웹 취약점 공격(SQL Injection, XSS 등)을 차단하는 웹 방화벽입니다. 보통 가장 앞단(Load Balancer 앞)에 위치합니다.

IPS (Intrusion Prevention System): 비정상적인 네트워크 트래픽이나 침입 패턴을 감지하고 실시간으로 차단합니다.

FW (Firewall): IP/Port 기반으로 접근을 제어하는 가장 기본적인 방화벽입니다.

Anti-Virus / 백신: 서버 내부의 악성코드나 바이러스를 탐지합니다.

DB 암호화 및 접근제어: 중요 데이터(개인정보 등)를 암호화하고 DB 접속 권한을 관리합니다.

로그 보관/분석 (SIEM): 통합 로그 관리 및 보안 사고 분석을 위한 서비스입니다. (공공기관은 보통 로그를 6개월~1년 이상 보관해야 하는 의무가 있습니다.)

# 2단계 잠금 (2PL, Two-Phase Locking)

약 30년 동안 직렬성을 구현하는 유일한 표준 알고리즘이었습니다. (※ 주의: 분산 DB의 원자적 커밋을 위한 2단계 커밋(2PC)과는 완전히 다른 개념입니다.)

### 1) 핵심 원리: "쓰는 자는 읽는 자도 막는다"

- **스냅숏 격리와의 차이:** 스냅숏 격리는 "읽는 자와 쓰는 자가 서로 막지 않음"을 지향하지만, 2PL은 경쟁 상태가 발생할 가능성이 있다면 무조건 대기하게 합니다.
- **공유 잠금(Shared Lock):** 읽기 전용. 여러 트랜잭션이 동시에 가질 수 있지만, 누군가 쓰고 있다면 대기해야 합니다.
- **독점 잠금(Exclusive Lock):** 쓰기 전용. 오직 하나의 트랜잭션만 가질 수 있으며, 다른 읽기/쓰기 트랜잭션을 모두 차단합니다.

### 2) "2단계"의 의미

1.  **확장 단계 (Growing Phase):** 트랜잭션 실행 중 필요한 잠금을 계속 획득하는 단계.
2.  **수축 단계 (Shrinking Phase):** 트랜잭션 종료 시(커밋/중단) 모든 잠금을 한꺼번에 해제하는 단계.
    - 한번 잠금을 해제하면 새로운 잠금을 얻을 수 없습니다.

### 3) 2PL의 문제점: 성능과 데드락

- **성능 저하:** 잠금 획득/해제 오버헤드와 낮은 동시성으로 인해 처리량이 크게 떨어집니다. 특히 긴 읽기 작업(백업 등)이 전체 DB의 쓰기를 멈출 수 있습니다.
- **데드락(Deadlock):** 서로가 가진 잠금을 기다리며 무한 대기하는 상황이 빈번합니다. DB가 이를 감지해 하나를 강제 종료(Abort)해야 하므로 애플리케이션의 재시도 부하가 큽니다.

### 4) 팬텀 방지: 서술 잠금과 인덱스 범위 잠금

- **서술 잠금(Predicate Lock):** 특정 조건(예: `room_id = 123`)에 해당하는 **미래의 데이터(팬텀)**까지 잠그는 개념입니다. 성능 문제로 실제로는 잘 쓰이지 않습니다.
- **인덱스 범위 잠금(Index-range Lock):** 서술 잠금의 근사치로, 인덱스의 특정 범위에 잠금을 걸어 팬텀을 방지합니다. 2PL 기반 직렬성 DB에서 주로 사용하는 방식입니다.

---

# 직렬성 스냅숏 격리 (SSI, Serializable Snapshot Isolation)

2008년에 처음 소개된 기술로, 스냅숏 격리의 성능 이점을 유지하면서 완전한 직렬성을 제공하는 **낙관적(Optimistic)** 방식입니다.

### 1) 비관적(2PL) vs 낙관적(SSI)

- **2PL (비관적):** 잘못될 것 같으면 일단 멈추고 기다립니다.
- **SSI (낙관적):** 일단 실행하고, 커밋 시점에 "격리 수준 위반"이 있었는지 확인하여 문제가 있다면 중단(Abort)시킵니다.

### 2) 핵심 아이디어: "과거의 전제(Premise) 확인"

트랜잭션이 "현재 당직 의사가 2명이다"라는 전제 하에 작업을 수행했다면, 커밋 시점에 그 전제가 여전히 유효한지 확인합니다.

### 3) 충돌 감지 메커니즘

1.  **오래된 MVCC 버전 읽기 감지:** 트랜잭션이 읽은 데이터가 커밋 시점에 이미 다른 트랜잭션에 의해 수정되었는지 확인합니다. (Figure 8-10)
2.  **읽기 이후의 쓰기 감지:** 트랜잭션이 데이터를 읽은 후, 다른 트랜잭션이 그 데이터 범위에 새로운 값을 썼는지(팬텀) 확인합니다. (Figure 8-11)
    - 이때 잠금은 **'인계철선(Tripwire)'** 역할만 하며, 실제 실행을 차단하지는 않습니다.

### 4) SSI의 장점

- **예측 가능한 지연 시간:** 읽는 자와 쓰는 자가 서로를 차단하지 않으므로 응답 시간이 안정적입니다.
- **수평 확장성:** 단일 코어에 묶이지 않으며, 여러 장비로 충돌 감지 로직을 분산시킬 수 있습니다 (예: FoundationDB).
- **읽기 부하에 최적:** 읽기 전용 쿼리는 잠금 없이 일관된 스냅숏을 볼 수 있어 매우 효율적입니다.

---

# 3. 요약 및 결론

| 방식                    | 접근 철학     | 주요 특징                           | 단점                              |
| :---------------------- | :------------ | :---------------------------------- | :-------------------------------- |
| **순차 실행**           | 극단적 비관적 | 단일 스레드, 스토어드 프로시저 사용 | 단일 코어 한계, 샤딩 시 조율 비용 |
| **2단계 잠금 (2PL)**    | 비관적        | 공유/독점 잠금, 모든 경쟁 상태 방지 | 낮은 동시성, 불안정한 지연 시간   |
| **직렬성 스냅숏 (SSI)** | 낙관적        | MVCC 기반, 커밋 시 충돌 검사        | 충돌이 많을 때 높은 중단(Abort)율 |

**결론적으로**, 현대적인 고성능 시스템에서는 **SSI**가 가장 유망한 대안으로 떠오르고 있으며, 성능과 안전성 사이의 오랜 딜레마를 해결하는 열쇠가 되고 있습니다.

<br/>
<br/>

# 분산 트랜잭션 (Distributed Transactions)

## 1. 분산 트랜잭션이란?

단일 노드 트랜잭션은 한 대의 머신이 모든 로직과 동시성 제어를 담당하지만, **분산 트랜잭션**은 여러 노드가 트랜잭션에 관여하는 상황을 말합니다.

- **발생 시나리오:**
  - 샤딩된 데이터베이스에서 여러 샤드에 걸쳐 데이터를 수정해야 할 때.
  - 기본 데이터와 전역 보조 인덱스(Global Secondary Index)가 서로 다른 노드에 존재할 때.

## 2. 분산 환경에서의 동시성 제어

분산 트랜잭션의 동시성 제어(격리 수준 보장) 알고리즘은 단일 노드와 유사하게 작동합니다.

- 샤딩된 DB에서의 **순차 실행**이 가능합니다.
- **2단계 잠금(2PL)**도 분산 환경에서 작동합니다.
- **직렬성 스냅숏 격리(SSI)**를 위한 분산 직렬성 검사기(Distributed Serializability Checkers)도 존재합니다.

## 3. 원자성 달성의 어려움 (The Challenge of Atomicity)

단일 노드와 달리 분산 환경에서는 **"모두 성공하거나 모두 실패(All-or-Nothing)"**를 보장하는 것이 훨씬 어렵습니다.

### 1) 단일 노드의 원자성 구현

- **핵심:** 저장 엔진의 **쓰기 전 로그(WAL)**와 **커밋 레코드**의 순서에 의존합니다.
- **결정적 순간:** 디스크가 커밋 레코드를 완전히 기록하는 찰나입니다. 이 기록 전에는 중단(Abort)이 가능하고, 기록 후에는 크래시가 나도 커밋된 것으로 간주합니다. 즉, **단일 장치(디스크 컨트롤러)**가 원자성을 결정합니다.

### 2) 분산 노드의 원자성 문제

단순히 모든 노드에 "커밋해!"라고 요청을 보내는 것만으로는 부족합니다. 다음과 같은 이유로 일부는 성공하고 일부는 실패하는 **불일치 상태**가 발생할 수 있기 때문입니다 (Figure 8-12).

- **제약 조건 위반:** 특정 노드에서만 충돌이나 제약 조건 위반이 발생해 중단이 필요할 수 있음.
- **네트워크 손실:** 일부 커밋 요청이 네트워크에서 사라져 타임아웃으로 중단됨.
- **노드 크래시:** 일부 노드가 커밋 레코드를 쓰기 전에 크래시가 발생해 복구 시 롤백됨.

### 3) 불일치의 치명적 결과

한 노드에서 커밋된 데이터는 즉시 다른 트랜잭션에 보일 수 있습니다(Read Committed 이상). 만약 나중에 다른 노드에서 실패했다는 이유로 이미 커밋된 데이터를 취소하려고 하면, 그 데이터를 이미 읽어간 다른 트랜잭션들까지 모두 소급해서 취소해야 하는 **연쇄적 혼란**이 발생합니다.

## 4. 원자적 커밋 문제 (The Atomic Commitment Problem)

이러한 문제를 해결하기 위해, 트랜잭션에 참여하는 모든 노드가 **"전부 커밋하거나 전부 중단"**하도록 보장해야 합니다. 어느 한쪽으로 치우친 혼합된 결과가 나오지 않게 관리하는 것이 분산 시스템의 핵심 과제이며, 이를 **원자적 커밋 문제**라고 부릅니다.

---

### 💡 핵심 요약

- 분산 트랜잭션은 여러 노드에 걸친 작업의 **원자성**을 보장하는 것이 가장 큰 숙제입니다.
- 단일 노드처럼 디스크 하나가 결정권을 갖는 것이 아니라, **여러 노드 간의 합의**가 필요합니다.
- 이 문제를 해결하기 위한 대표적인 알고리즘이 바로 다음에 이어질 **2단계 커밋(2PC)**입니다.

---

<br/>
<br/>

# 2단계 커밋 (2PC, Two-Phase Commit)

2단계 커밋은 여러 노드에 걸친 분산 트랜잭션에서 **원자적 커밋(Atomic Commit)**을 달성하기 위한 고전적이고 대중적인 알고리즘입니다.

## 1. 핵심 구성 요소

- **코디네이터(Coordinator):** 트랜잭션 매니저라고도 하며, 전체 트랜잭션의 커밋 여부를 결정하고 관리하는 중심 역할을 합니다.
- **참여자(Participants):** 실제 데이터를 읽고 쓰는 데이터베이스 노드들입니다.

## 2. 동작 과정: 약속의 시스템 (A System of Promises)

2PC는 이름처럼 두 단계로 나뉘어 진행됩니다.

### 1단계: 준비 단계 (Prepare Phase)

1.  애플리케이션이 커밋할 준비가 되면, 코디네이터는 모든 참여자에게 **준비(Prepare) 요청**을 보냅니다.
2.  각 참여자는 이 요청을 받으면 **"내가 실제로 커밋할 수 있는가?"**를 확인합니다.
    - 데이터를 디스크에 안전하게 기록하고, 제약 조건이나 충돌 여부를 체크합니다.
3.  준비가 되었다면 참여자는 코디네이터에게 **"Yes"**라고 응답합니다.
    - **중요:** "Yes"라고 대답하는 것은 **"나는 무슨 일이 있어도 이 트랜잭션을 커밋할 준비가 되었으며, 이후에는 커밋을 거부할 권리를 포기한다"**는 강력한 약속입니다.

### 2단계: 커밋 단계 (Commit Phase)

1.  **결정:** 코디네이터가 모든 참여자로부터 "Yes"를 받으면 커밋을 결정합니다. 하나라도 "No"가 있거나 타임아웃이 발생하면 중단(Abort)을 결정합니다.
2.  **커밋 지점(Commit Point):** 코디네이터는 결정을 내린 즉시 자신의 **트랜잭션 로그(디스크)**에 그 결정을 기록합니다. 이 순간이 트랜잭션의 운명이 결정되는 '결정적 순간'입니다.
3.  **실행:** 코디네이터는 모든 참여자에게 커밋 또는 중단 요청을 보냅니다. 참여자가 크래시가 났더라도, 복구 후에 코디네이터의 결정에 따라 반드시 작업을 완료해야 합니다.

---

## 3. 코디네이터 장애와 "의심스러운(In-doubt)" 상태

2PC의 가장 큰 취약점은 코디네이터가 장애가 났을 때 발생합니다.

- **의심스러운 상태 (In-doubt/Uncertain):** 참여자가 "Yes"라고 응답한 후, 코디네이터로부터 최종 결정(커밋/중단)을 듣지 못한 상태를 말합니다. (Figure 8-14)
- **교착 상태:** 이 상태의 참여자는 독단적으로 커밋하거나 중단할 수 없습니다. 다른 참여자와 일관성이 깨질 수 있기 때문입니다.
- **해결책:** 참여자는 코디네이터가 복구될 때까지 **무한정 기다려야 합니다.** 코디네이터는 복구 후 자신의 로그를 읽어 미결된 트랜잭션의 상태를 참여자들에게 다시 알려줍니다.

---

## 4. 2PC의 한계와 대안

1.  **블로킹 프로토콜 (Blocking Protocol):** 코디네이터 장애 시 시스템이 멈출 수(Blocking) 있습니다. 이로 인해 가용성에 문제가 생길 수 있습니다.
2.  **성능 오버헤드:** 여러 번의 네트워크 통신과 매 단계마다 디스크 쓰기(fsync)가 필요하므로 단일 노드 트랜잭션보다 훨씬 느립니다.
3.  **3단계 커밋 (3PC)의 한계:** 2PC의 블로킹 문제를 해결하기 위해 제안되었으나, 네트워크 지연이 무한할 수 있는 실제 환경에서는 원자성을 완벽히 보장하지 못해 잘 쓰이지 않습니다.

---

### 💡 요약 및 비유 (결혼식 비유)

- **준비 단계:** 주례(코디네이터)가 신랑/신부(참여자)에게 "결혼하시겠습니까?" 묻고, 둘 다 "네(Yes)"라고 대답하는 과정.
- **약속:** "네"라고 대답한 후에는 마음대로 취소할 수 없습니다.
- **커밋 지점:** 주례가 "성혼 선언"을 하는 순간. 설령 주례가 선언 직후 쓰러지더라도, 두 사람이 이미 "네"라고 약속했으므로 이 결혼은 유효하며 주례가 깨어난 후 확정해줘야 합니다.

---

**내용 정리가 완료되었습니다.** 다음 주제인 **"Fault-Tolerant Consensus(결함 허용 합의)"**나 다른 궁금한 점이 있으시면 말씀해 주세요!

제공해주신 내용을 바탕으로 **"다양한 시스템에 걸친 분산 트랜잭션"**의 핵심 내용인 XA 트랜잭션의 한계, 현대적 대안, 그리고 '정확히 한 번(Exactly-once)' 처리에 대해 자세히 정리해 드립니다.

---

# 다양한 시스템에 걸친 분산 트랜잭션

분산 트랜잭션은 강력한 안전성을 제공하지만, 성능 저하와 운영상의 복잡성 때문에 양면성을 가집니다. 이를 이해하기 위해 먼저 두 가지 유형을 구분해야 합니다.

## 1. 분산 트랜잭션의 두 유형

1.  **데이터베이스 내부 분산 트랜잭션:** 동일한 DB 소프트웨어를 사용하는 노드들 사이의 트랜잭션 (예: Spanner, TiDB, CockroachDB). 최적화가 가능하여 성능과 신뢰성이 상대적으로 높습니다.
2.  **이종(Heterogeneous) 분산 트랜잭션:** 서로 다른 기술(예: 서로 다른 벤더의 DB, 메시지 브로커 등) 간의 트랜잭션. 표준 프로토콜이 필요하며 구현이 훨씬 까다롭습니다.

---

## 2. XA 트랜잭션 (이종 시스템 간의 표준)

XA(eXtended Architecture)는 서로 다른 기술 간에 2단계 커밋(2PC)을 구현하기 위한 1991년 표준 규격입니다.

### 1) 작동 방식

- **코디네이터:** 보통 애플리케이션 프로세스 내에 라이브러리 형태로 포함됩니다.
- **드라이버:** DB나 메시지 브로커의 드라이버가 XA API를 지원하여 코디네이터와 통신합니다.
- **흐름:** 코디네이터가 드라이버를 통해 참여자들에게 준비(Prepare), 커밋(Commit), 중단(Abort)을 지시합니다.

### 2) 치명적인 문제점: 의심스러운(In-doubt) 상태와 잠금

- **잠금 유지:** 트랜잭션이 '의심스러운 상태'(코디네이터의 결정을 기다리는 상태)에 빠지면, 해당 트랜잭션이 점유한 **로우 수준 독점 잠금이 해제되지 않습니다.**
- **가용성 마비:** 코디네이터가 크래시되어 복구에 20분이 걸린다면, 그동안 다른 트랜잭션들은 해당 데이터에 접근하지 못하고 줄줄이 대기하게 되어 시스템 전체가 마비될 수 있습니다.
- **수동 해결:** 코디네이터 로그가 손실되면 관리자가 직접 참여자 상태를 확인하고 수동으로 커밋/롤백을 결정해야 합니다.
- **휴리스틱 결정(Heuristic Decisions):** 위급 상황에서 참여자가 독단적으로 결정하는 비상구이지만, 이는 **원자성을 파괴**할 위험이 큽니다.

---

## 3. 현대적 내부 분산 트랜잭션 (NewSQL)

최신 분산 DB들은 XA의 한계를 극복하기 위해 다음과 같은 방법을 사용합니다.

- **코디네이터 복제:** 코디네이터 자체를 복제하고 합의 알고리즘(Paxos, Raft)을 사용하여 고가용성을 확보합니다.
- **직접 통신:** 애플리케이션을 거치지 않고 코디네이터와 데이터 샤드가 직접 통신합니다.
- **교착 상태 감지:** 여러 샤드에 걸친 데드락을 감지하는 기능을 통합합니다.

---

## 4. 정확히 한 번(Exactly-once) 메시지 처리

분산 트랜잭션의 가장 중요한 유스케이스 중 하나는 메시지 큐에서 메시지를 읽어 DB를 업데이트할 때, 중복이나 누락 없이 **정확히 한 번만** 처리되도록 보장하는 것입니다.

### 1) 분산 트랜잭션을 이용한 방법

- 메시지 브로커의 '확인 응답(Ack)'과 'DB 쓰기'를 하나의 분산 트랜잭션으로 묶어 원자적으로 커밋합니다.

### 2) 분산 트랜잭션 없이 달성하는 방법 (멱등성 활용)

저자는 분산 트랜잭션 없이도 DB 내부 트랜잭션만으로 이를 달성할 수 있는 더 효율적인 대안을 제시합니다.

1.  **메시지 ID 기록:** 모든 메시지에 고유 ID를 부여하고, DB에 '처리된 메시지 ID' 테이블을 만듭니다.
2.  **단일 트랜잭션:** '비즈니스 데이터 업데이트'와 '메시지 ID 삽입'을 **하나의 DB 트랜잭션**으로 묶습니다.
3.  **중복 체크:** 메시지가 다시 들어오면 DB에 ID가 있는지 확인하여 이미 처리되었다면 무시합니다.
4.  **결과:** 이 방식은 작업을 **멱등(Idempotent)**하게 만들어, 네트워크 오류로 재시도가 발생해도 부수 효과가 중복되지 않게 합니다.

---

### 💡 핵심 요약

- **XA 트랜잭션**은 이종 시스템 간 통합을 가능하게 하지만, 코디네이터 장애 시 **잠금이 해제되지 않는 심각한 운영 리스크**가 있습니다.
- **현대적 분산 DB**는 코디네이터 복제와 합의 알고리즘을 통해 이 문제를 해결합니다.
- **정확히 한 번 처리**를 위해서는 값비싼 분산 트랜잭션 대신, DB 내에 처리 로그를 남기는 **멱등성 설계**가 더 권장되는 패턴입니다.

---

<br/>
<br/>

---

# 최종 요약

트랜잭션은 애플리케이션이 하드웨어 결함, 소프트웨어 오류, 복잡한 동시성 문제 등을 무시하고 **"마치 아무런 문제가 없는 것처럼"** 코딩할 수 있게 해주는 강력한 추상화 계층입니다.

## 1. 격리 수준별 발생 가능한 이상 현상 (Anomalies)

가장 핵심적인 내용을 표와 함께 정리하면 다음과 같습니다.

| 격리 수준              | 더러운 읽기 | 읽기 스큐  | 팬텀 읽기  |  갱신 분실  | 쓰기 스큐  |
| :--------------------- | :---------: | :--------: | :--------: | :---------: | :--------: |
| **Read Uncommitted**   |  발생 가능  | 발생 가능  | 발생 가능  |  발생 가능  | 발생 가능  |
| **Read Committed**     | **방지됨**  | 발생 가능  | 발생 가능  |  발생 가능  | 발생 가능  |
| **Snapshot Isolation** | **방지됨**  | **방지됨** | **방지됨** | DB마다 다름 | 발생 가능  |
| **Serializable**       | **방지됨**  | **방지됨** | **방지됨** | **방지됨**  | **방지됨** |

### 주요 이상 현상 정의

- **더러운 읽기(Dirty Reads):** 커밋되지 않은 다른 트랜잭션의 쓰기를 읽는 것.
- **더러운 쓰기(Dirty Writes):** 커밋되지 않은 데이터를 덮어쓰는 것. (거의 모든 트랜잭션 구현에서 방지됨)
- **읽기 스큐(Read Skew):** 한 트랜잭션 내에서 서로 다른 시점의 데이터를 읽어 일관성이 깨지는 현상. **MVCC**를 사용하는 스냅숏 격리로 해결.
- **갱신 분실(Lost Updates):** 두 트랜잭션이 동시에 읽기-수정-쓰기 주기를 수행하여 한쪽의 수정사항이 사라지는 것.
- **쓰기 스큐(Write Skew):** 데이터를 읽고 내린 결정이 커밋 시점에는 더 이상 유효하지 않게 되는 현상. 오직 **직렬성 격리**로만 방지 가능.
- **팬텀 읽기(Phantom Reads):** 한 트랜잭션의 쓰기가 다른 트랜잭션의 검색 결과 집합을 바꾸는 현상.

---

## 2. 직렬성(Serializability) 구현의 세 가지 접근법

1.  **실제 순차 실행 (Actual Serial Execution):**
    - 단일 스레드에서 트랜잭션을 하나씩 실행.
    - 트랜잭션이 매우 짧고 빠르며(스토어드 프로시저 활용), 데이터가 메모리에 들어갈 때 효과적임.
2.  **2단계 잠금 (2PL, Two-Phase Locking):**
    - 수십 년간의 표준 방식이나, 성능 저하와 데드락 문제로 인해 최근에는 기피됨.
3.  **직렬성 스냅숏 격리 (SSI, Serializable Snapshot Isolation):**
    - 낙관적(Optimistic) 방식으로, 트랜잭션을 차단하지 않고 실행한 뒤 커밋 시점에 직렬성 위반 여부를 검사하여 중단(Abort)시킴. 현대적 시스템에서 선호됨.

---

## 3. 분산 트랜잭션과 원자적 커밋

- **2단계 커밋 (2PC):** 여러 노드에 걸친 원자성을 보장하기 위한 알고리즘.
- **XA 트랜잭션:** 서로 다른 기술(DB, 메시지 브로커 등) 간의 표준이나, 코디네이터 장애 시 **잠금이 해제되지 않는 블로킹 문제** 등 운영상 리스크가 큼.
- **대안:** 분산 트랜잭션 대신 **멱등성(Idempotence)** 설계를 통해 '정확히 한 번(Exactly-once)' 처리를 달성하는 것이 더 권장됨.

---

## 4. 결론

트랜잭션은 데이터 모델(관계형, 문서형 등)에 상관없이 **복잡한 오류 상황을 '트랜잭션 중단'이라는 단순한 케이스로 치환**해 줍니다. 개발자는 모든 예외 상황을 일일이 처리하는 대신, 실패 시 **"다시 시도"**하는 단순한 전략만으로도 데이터의 일관성을 유지할 수 있습니다.
