# 데이터 중심 애플리케이션 설계
## Chapter 7. 트랜잭션 (Transactions)

> 트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.
> 어떤 연산은 성공하고 어떤 연산은 실패하는 **부분적인 실패**를 걱정할 필요가 없기 때문에 오류 처리가 훨씬 단순해진다.

---

## 1. ACID

트랜잭션이 제공하는 안전성 보장은 흔히 **원자성(Atomicity)**, **일관성(Consistency)**, **격리성(Isolation)**, **지속성(Durability)** 을 의미하는 약어인 `ACID`로 알려져 있다.

---

### 1-1. 원자성 (Atomicity)

- 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶임
- 트랜잭션은 **완료(커밋)** 되거나, 결함 발생 시 모든 쓰기 작업이 **중단(어보트)** 되거나 둘 중 하나
- **오류가 생겼을 때 트랜잭션을 어보트하고 모든 내용을 취소하는 능력이 원자성의 핵심**

```
성공 시: 모든 쓰기 커밋
실패 시: 모든 쓰기 롤백 (부분 성공 없음)
```

---

### 1-2. 일관성 (Consistency)

> "일관성"이라는 단어는 문맥에 따라 의미가 다름에 주의

| 맥락 | 의미 |
|---|---|
| Eventual / Strong Consistency | 복제 시스템 간 데이터 동기화 |
| Consistent Hashing | 파티셔닝 재균형화 방법 |
| CAP 정리 | 선형성(Linearizability) |
| **ACID** | **트랜잭션 완료 시 불변식(invariant) 만족** |

**핵심 포인트:**
- ACID의 일관성은 데이터에 관한 **불변식**이 반드시 만족되어야 함을 의미
- 데이터베이스는 유일성 조건, 외래 키 조건 등을 확인할 수 있으나, 비즈니스 로직의 불변식은 **애플리케이션의 책임**
- **ACID 중 일관성(C)만 유일하게 애플리케이션 속성** — 나머지(A, I, D)는 데이터베이스 속성

---

### 1-3. 격리성 (Isolation)

- 동시에 실행되는 트랜잭션은 서로 격리되어야 함
- **트랜잭션은 다른 트랜잭션을 방해할 수 없다**
- 각 트랜잭션이 마치 혼자 실행되는 것처럼 동작해야 함

---

### 1-4. 지속성 (Durability)

- 트랜잭션이 성공적으로 커밋됐다면 **하드웨어 결함이 발생하거나 DB가 죽더라도 데이터는 손실되지 않아야 함**
- 데이터베이스는 트랜잭션이 커밋됐다고 보고하기 전에 **쓰기나 복제가 완료될 때까지 기다려야 함**
- 완벽한 지속성은 불가능 — 모든 하드디스크와 백업이 동시에 파괴되면 방법이 없음

---

### 1-5. 다중 객체 연산 (트랜잭션)

- 관계형 DB는 TCP 연결 기반으로 `BEGIN TRANSACTION`, `COMMIT` 등으로 트랜잭션 경계를 확인
- **비관계형 DB는 구현 복잡성과 높은 가용성/성능을 위해 다중 객체 트랜잭션을 지원하지 않는 경우가 많음**

**다중 객체 트랜잭션이 필요한 경우:**
1. 서로 참조하는 여러 레코드 삽입 시 참조 키가 항상 최신이어야 할 때
2. 비정규화된 여러 테이블의 데이터를 한 번에 갱신해야 할 때
3. 보조 색인이 있는 경우 값 변경 시 색인도 함께 갱신해야 할 때

---

### 1-6. 오류와 어보트 처리

> **트랜잭션의 핵심 기능은 오류 시 어보트되고 안전하게 재시도할 수 있다는 것**

**재시도의 한계:**
- 트랜잭션이 실제로는 커밋됐지만 네트워크 문제로 클라이언트는 실패했다고 생각 → **중복 처리 위험**
- 오류가 과부하 때문이라면 재시도는 더 큰 문제 유발
- **일시적인 오류**(데드락, 네트워크, 시스템 장애)에만 가치있고 **영구적인 오류**(제약 조건 위반)는 재시도 불필요

---

## 2. 완화된 격리 수준

> 직렬성 격리는 성능 비용이 크기 때문에 많은 DB는 **완화된(약한) 격리 수준**을 사용
> 각 수준의 특성을 파악해 애플리케이션에 적합한 격리 수준을 선택하는 것이 중요

---

### 2-1. 커밋 후 읽기 (Read Committed)

가장 기본적인 트랜잭션 격리 수준으로 두 가지를 보장:

1. 읽을 때 **커밋된 데이터만 본다** → 더티 읽기(Dirty Read) 없음
2. 쓸 때 **커밋된 데이터만 덮어쓴다** → 더티 쓰기(Dirty Write) 없음

#### 더티 읽기 방지

- 다른 트랜잭션에서 **커밋되지 않은 데이터를 읽는 것** = 더티 읽기
- 더티 읽기가 위험한 이유:
  - 트랜잭션이 여러 객체 갱신 시 일부는 갱신된 값, 일부는 갱신 전 값을 보게 됨
  - 트랜잭션 어보트 후 롤백해야 할 데이터를 다른 트랜잭션이 읽을 수 있음
- **구현:** 잠금(lock) 사용 대신 과거 커밋된 값과 현재 쓴 값을 모두 기억 → 커밋 전까지 과거 값을 반환

#### 더티 쓰기 방지

- 아직 커밋되지 않은 데이터를 새로운 트랜잭션이 덮어쓰는 것 = 더티 쓰기
- **구현:** 로우 수준 잠금(row-level lock) — 한 트랜잭션만 객체에 대한 잠금 보유 가능

#### Read Committed의 한계 — 비반복 읽기 (Non-repeatable Read / Read Skew)

```
상황: Account1(500원), Account2(500원)에서 Account2 → Account1으로 100원 송금 중

Alice의 조회 트랜잭션:
  1. Account1 조회 → 송금 전 값 읽음: 500원
  2. (이 사이에 송금 트랜잭션 커밋됨)
  3. Account2 조회 → 송금 후 값 읽음: 400원

결과: Alice가 본 총액 = 900원 (실제: 1000원) → 100원이 사라진 것처럼 보임!
```

> Read Committed는 다른 트랜잭션이 커밋한 데이터를 읽을 수 있기 때문에
> 한 트랜잭션 내에서 같은 데이터를 조회할 때 결과가 달라질 수 있음

---

### 2-2. 스냅숏 격리 (Snapshot Isolation)

> 비반복 읽기 문제를 해결하는 가장 흔한 방법

**핵심 원칙:**
- 각 트랜잭션은 **특정 시점에 고정된 데이터베이스의 일관된 스냅숏으로부터 읽는다**
- 트랜잭션 시작 시 커밋된 상태였던 데이터만 보게 되어 **Non-repeatable Read가 발생하지 않음**

**지원 DB:** PostgreSQL, InnoDB 기반 MySQL, Oracle 등

#### 스냅숏 격리 구현 — MVCC (Multi-Version Concurrency Control)

- **객체마다 커밋된 버전을 여러 개 유지** → 다중 버전 동시성 제어
- 트랜잭션별 고유한 **트랜잭션 ID(txid)** 할당
- 데이터를 쓸 때마다 트랜잭션 ID와 버전별 객체 기록

```
각 Row에 created_by, deleted_by 필드 존재:

txid | created_by | deleted_by | data
-----|------------|------------|------
1    | 10         | (없음)     | "Alice"   ← 현재 유효한 버전
2    | 8          | 12         | "Bob"     ← txid 12에 의해 삭제됨

트랜잭션 11이 조회할 때:
  - created_by ≤ 11 이고
  - deleted_by가 없거나 > 11 인 버전만 볼 수 있음
```

**가시성 규칙:**
- 트랜잭션 시작 시점에 커밋된 데이터만 조회
- 진행 중인(Uncommitted) 트랜잭션의 변경사항 무시
- 나중에 시작된 트랜잭션의 변경사항도 무시
- 실제 삭제는 하지 않고 `deleted_by` 필드 설정으로 삭제 표시 → 해당 버전 접근 트랜잭션 없을 때 실제 삭제

> PostgreSQL, MySQL에서는 스냅숏 격리를 **반복 읽기(Repeatable Read)** 라고도 부름

---

### 2-3. 갱신 손실 (Lost Update) 방지

> Read Committed / Snapshot Isolation은 주로 읽기 전용 트랜잭션의 보장에 관한 것
> **동시에 실행되는 쓰기 트랜잭션 간의 충돌**도 고려해야 함

**갱신 손실 발생 패턴:** `읽기 → 수정 → 쓰기 (read-modify-write)` 를 여러 트랜잭션이 동시에 수행

```
카운터 증가 예시:
T1: READ counter (42) → counter+1 (43) → 대기
T2: READ counter (42) → counter+1 (43) → COMMIT
T1: → COMMIT (counter = 43)

결과: 두 번 증가했지만 최종 값은 43 (44가 되어야 함!) → 갱신 손실
```

#### 갱신 손실 방지 방법

**1) 원자적 쓰기 연산**
```sql
-- 대부분의 관계형 DB에서 동시성 안전
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

**2) 명시적 잠금**
```sql
-- MySQL의 경우 FOR UPDATE로 로우 잠금
SELECT * FROM items WHERE id = 1 FOR UPDATE;
-- 이후 수정 작업 수행
-- 실수할 여지가 많음
```

**3) 갱신 손실 자동 감지**
- 병렬 실행 허용 후 갱신 손실 감지 시 트랜잭션 어보트 → 재시도 강제
- 오라클, SQL Server에서 지원
- InnoDB 기반 MySQL은 미지원

**4) Compare-and-Set (CAS)**
```sql
-- 읽은 후 변경되지 않았을 때만 갱신 허용
UPDATE item SET name = 'new name 1' WHERE id = 123 AND name = 'old name';
-- WHERE 조건 불일치 시 실패 → 갱신 손실 방지
-- WHERE 절이 최신 데이터를 읽지 못하면 막을 수 없는 경우도 있음
```

**5) 충돌 해소와 복제**
- 다중 리더 / 리더 없는 복제 환경에서는 추가 단계 필요
- 교환 법칙이 성립하는 원자적 연산(카운터 증가 등)은 복제 상황에서도 잘 동작
- 많은 DB의 **최종 쓰기 승리(Last Write Wins)** 방식은 갱신 손실이 발생하기 쉬움

---

### 2-4. 쓰기 스큐 (Write Skew)와 팬텀

> 동시에 실행되는 두 트랜잭션이 같은 객체들을 읽어서 **각각 다른 객체들을 갱신**하여 애플리케이션의 요구사항을 위반하는 현상

```
비교:
- 같은 객체 갱신 시: 더티 쓰기, 갱신 손실 발생
- 다른 객체 갱신 시: 쓰기 스큐 발생
```

#### 쓰기 스큐 예시 — 의사 호출 대기 시스템

```
요구사항: 최소 1명의 의사가 항상 호출 대기해야 함
현재 상태: Alice(대기중), Bob(대기중)

T1 (Alice 퇴근 요청):
  SELECT COUNT(*) FROM doctors WHERE on_call = true; → 2 반환
  → 1명 이상이므로 Alice on_call = false로 변경

T2 (Bob 퇴근 요청):
  SELECT COUNT(*) FROM doctors WHERE on_call = true; → 2 반환 (스냅숏 격리)
  → 1명 이상이므로 Bob on_call = false로 변경

결과: 호출 대기 의사 0명 → 요구사항 위반!
```

**해결:** `SELECT` 절에 `FOR UPDATE`를 붙여 로우를 명시적으로 잠금

#### 쓰기 스큐 패턴

1. `SELECT`로 어떤 조건에 부합하는 로우 검색 → 요구사항 확인
2. 결과에 따라 계속 진행할지 결정
3. 진행 결정 시 데이터베이스에 쓰기 → **이 쓰기로 인해 2단계의 전제 조건이 변경됨**

#### 팬텀 (Phantom)

> 어떤 트랜잭션에서 실행한 쓰기가 **다른 트랜잭션의 검색 질의 결과를 바꾸는 효과**

- 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만
- **읽기-쓰기 트랜잭션에서는 팬텀이 쓰기 스큐를 유발할 수 있음**

#### 잠금으로 해결할 수 없는 경우

예시: 회의실 예약 시스템
- 중복 예약 방지를 위해 예약 전 해당 시간대 예약 조회
- 예약이 없으면 **반환되는 로우가 없으므로 잠글 수 없음**

**해결 방법 — 충돌 구체화 (Materializing Conflicts)**
- 인위적으로 DB에 잠금 객체를 추가하여 팬텀을 잠금 충돌 문제로 변환
- 구체화 방법을 찾기 어렵고 오류 발생 쉬움 → **최후의 수단**
- **대부분의 경우 직렬성 격리 수준으로 해결하는 것이 선호됨**

---

## 3. 직렬성 (Serializability)

> **여러 트랜잭션이 병렬로 실행되더라도 결과는 한 번에 하나씩 직렬로 실행될 때와 같도록 보장**

직렬성을 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용:
1. 트랜잭션 직렬 실행
2. 2단계 잠금 (2PL)
3. 직렬성 스냅숏 격리 (SSI)

---

### 3-1. 트랜잭션 직렬 실행

- 동시성 문제를 회피하는 가장 간단한 방법: **단일 스레드에서 하나씩만 실행**
- RAM 가격 하락과 인메모리 DB 구현 가능, OLTP 특성(짧은 트랜잭션)으로 실현 가능해짐

**적용 조건:**
- 모든 트랜잭션이 **작고 빨라야 함** — 느린 트랜잭션 하나가 모든 처리 지연
- 활성화된 데이터셋을 **메모리에 적재** 가능해야 함
- 쓰기 처리량이 **단일 CPU 코어**에서 처리 가능해야 함

**단일 스레드 최적화 — 스토어드 프로시저 (Stored Procedure)**
- 기존 상호작용식 트랜잭션(여러 번 네트워크 왕복)은 단일 스레드에서 처리량 매우 저하
- 트랜잭션 코드 전체를 스토어드 프로시저 형태로 DB에 제출
- **I/O 대기 없이 단일 스레드에서 좋은 처리량 획득**

```
스토어드 프로시저 단점:
- 코드 관리 어려움
- 애플리케이션에서 디버깅 어려움
- 잘못 작성 시 DB 성능에 영향
```

**처리량 확장 — 파티셔닝**
- 여러 파티션에 걸친 트랜잭션은 잠금 필요 → 오버헤드 발생
- **트랜잭션을 한 파티션에서 처리할 수 있도록 설계하는 것이 중요**

**사용 예:** Redis, VoltDB, Datomic

---

### 3-2. 2단계 잠금 (Two-Phase Locking, 2PL)

> 직렬성 구현을 위해 가장 많이 쓰인 알고리즘
> **2단계 잠금(2PL)과 2단계 커밋(2PC)은 비슷하지만 완전히 다름**

- 2PL은 **쓰기 트랜잭션이 읽기 트랜잭션도 막음** (스냅숏 격리와의 큰 차이점)
- 잠금 획득 오버헤드 + 동시성 감소 → **다른 격리 수준에 비해 성능이 크게 나쁨**

#### 2단계 잠금 구현

잠금을 `공유 모드`와 `독점 모드`로 구분:

| 구분 | 공유 모드 (Shared) | 독점 모드 (Exclusive) |
|---|---|---|
| 사용 목적 | 읽기 | 쓰기 |
| 동시 획득 | 여러 트랜잭션 가능 | 단 하나의 트랜잭션만 가능 |
| 충돌 | 독점 모드와 충돌 | 모든 잠금과 충돌 |

- 읽다가 쓰려고 하면 공유 → 독점 모드로 업그레이드 필요
- 획득한 잠금은 **트랜잭션이 종료될 때까지 보유**
- 데드락 발생 가능성 높음 → DB가 자동 감지하여 트랜잭션 어보트

**사용 예:** MySQL InnoDB (SERIALIZABLE)

#### 서술 잠금 (Predicate Lock)과 색인 범위 잠금 (Index-Range Lock)

**서술 잠금:** 잠글 객체가 없는 경우(회의실 예약 등) 검색 조건에 부합하는 모든 객체를 잠금
- 트랜잭션이 `SELECT` 조건에 부합하는 객체를 읽을 때 공유 모드 서술 잠금 획득
- 쓰기 시 해당 객체들이 서술 잠금에 부합하는지 확인
- **2단계 잠금 + 서술 잠금 = 모든 형태의 쓰기 스큐 방지 → 직렬성 격리**

**색인 범위 잠금:** 서술 잠금의 성능 문제 해결을 위한 근사
- 서술 조건을 간략화하여 더 많은 객체를 잠금
- 예: "13:00~14:00 1번 방 예약" → "모든 시간 1번 방 예약" 또는 "13:00~14:00 모든 방"으로 근사
- 정밀도는 낮지만 **오버헤드가 훨씬 낮은 좋은 타협안**

---

### 3-3. 직렬성 스냅숏 격리 (Serializable Snapshot Isolation, SSI)

> 직렬성 격리의 성능 문제를 해결하기 위해 등장한 유망한 기법

| 구분 | 2단계 잠금 (2PL) | SSI |
|---|---|---|
| 동시성 제어 방식 | **비관적** — 충돌 가능성 있으면 차단 | **낙관적** — 충돌 없다고 가정 후 커밋 시 검증 |
| 트랜잭션 차단 | 있음 | 없음 |
| 성능 (경쟁 적음) | 낮음 | 높음 |
| 성능 (경쟁 심함) | 낮음 | 낮음 (어보트 증가) |

**기반:** 스냅숏 격리 + 쓰기 작업 간 직렬성 충돌 감지 알고리즘

**직렬성 충돌 감지 케이스:**

#### 케이스 1) 오래된 MVCC 읽기 감지

```
상황: 트랜잭션 43이 SELECT 쿼리 실행 시점에 트랜잭션 42가 이미 쓰기를 수행

트랜잭션 42: 데이터 쓰기 시작
트랜잭션 43: SELECT → 오래된 MVCC 객체 읽음 (42가 커밋 전이므로)
트랜잭션 42: COMMIT
트랜잭션 43: COMMIT 시도 → 42가 커밋됐으므로 오래된 데이터를 읽은 것 확실 → 어보트!
```
- **읽는 즉시 어보트하지 않는 이유:** 읽기 전용 트랜잭션이라면 쓰기 스큐 위험이 없기 때문

#### 케이스 2) 과거 읽기에 영향을 미치는 쓰기 감지

```
트랜잭션 42, 43 둘 다 SELECT 쿼리 실행
  → 색인 범위 잠금으로 각 트랜잭션이 해당 객체를 읽었다는 사실을 기록
  → (이 잠금은 트랜잭션을 차단하지 않음!)

트랜잭션 42가 객체를 쓸 때:
  → 해당 객체를 최근에 읽은 트랜잭션 확인 (색인 범위 잠금 조회)
  → 트랜잭션 43에게 "데이터가 더 이상 최신이 아님"을 알림

트랜잭션 42 먼저 커밋 성공
트랜잭션 43 커밋 시도 → 어보트!
```

#### SSI의 성능

- 2PL 대비 **트랜잭션이 다른 트랜잭션을 기다리느라 차단되지 않음** → 읽기 많은 경우 성능 우수
- 추적의 세밀함에 따라 기록 오버헤드 조정 가능 (덜 상세 = 빠르지만 어보트 증가)
- **읽기-쓰기 트랜잭션이 짧을수록 유리** (충돌 가능성 감소)

**사용 예:** PostgreSQL (SERIALIZABLE), FoundationDB

---

## 4. 정리 & 요약

### ACID 요약

| 속성 | 보장 내용 | 주체 |
|---|---|---|
| **원자성 (A)** | 트랜잭션 내 쓰기는 모두 커밋 or 모두 어보트 | DB |
| **일관성 (C)** | 트랜잭션 완료 시 불변식이 반드시 만족됨 | **애플리케이션** |
| **격리성 (I)** | 동시 실행 트랜잭션은 서로 방해할 수 없음 | DB |
| **지속성 (D)** | 커밋된 데이터는 장애 후에도 손실되지 않음 | DB |

---

### 격리 수준 비교

| 격리 수준 | 방지하는 문제 | 성능 |
|---|---|---|
| **Read Committed** | 더티 읽기, 더티 쓰기 | ⭐⭐⭐⭐ |
| **Snapshot Isolation** | + 비반복 읽기(Read Skew) | ⭐⭐⭐ |
| **Serializable** | + 갱신 손실, 쓰기 스큐, 팬텀 (모두) | ⭐~⭐⭐⭐ |

---

### 경쟁 조건 (Race Condition) 요약

| 현상 | 설명 | 방지 수준 |
|---|---|---|
| **더티 읽기** | 커밋되지 않은 데이터를 읽음 | Read Committed 이상 |
| **더티 쓰기** | 커밋되지 않은 데이터를 덮어씀 | 거의 모든 트랜잭션 구현 |
| **읽기 스큐** | 한 트랜잭션 내 동일 데이터 조회 결과 달라짐 | Snapshot Isolation |
| **갱신 손실** | 동시 read-modify-write 시 한쪽 변경이 사라짐 | 원자적 연산, 잠금, 자동 감지 |
| **쓰기 스큐** | 각각 다른 객체를 갱신해 불변식 위반 | **직렬성 격리만 방지** |
| **팬텀 읽기** | 다른 트랜잭션 쓰기가 검색 질의 결과를 변경 | Snapshot Isolation(단순), SSI(쓰기 스큐 맥락) |

---

### 직렬성 격리 구현 비교

| 방법 | 방식 | 장점 | 단점 |
|---|---|---|---|
| **직렬 실행** | 단일 스레드 순차 실행 | 구현 단순, 오버헤드 없음 | 단일 CPU 코어 처리량 한계 |
| **2단계 잠금 (2PL)** | 비관적 잠금 | 검증된 기술 | 성능 저하, 데드락 가능 |
| **SSI** | 낙관적 + 커밋 시 충돌 감지 | 높은 동시성, 좋은 성능 | 충돌 시 어보트 및 재시도 필요 |

---