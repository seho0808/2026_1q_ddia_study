# 07. 트랜잭션

> 트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.
> 
- 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것이다.

트랜잭션이 필요한지 어떻게 알 수 있을까? 이 질문에 대답하려면 먼저 트랜잭션이 제공하는 안전성 보장에는 어떤 것이 있으며 이와 관련된 비용은 무엇인지 정확히 이해해야 한다.

# 애매모호한 트랜잭션의 개념

다른 모든 기술적 설계 선택과 마찬가지로 트랜잭션은 이점과 한계가 있다.

## ACID의 의미

현실에서는 데이터베이스마다 ACID 구현이 제각각이다.

오늘날 시스템이 “ACID를 준수”한다고 할 때 그 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다.

### 원자성

오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력

### 일관성

일관성은 애플리케이션의 속성이다. 애플리케이션에서 일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수는 있지만 데이터베이스만으로 되는 것은 아니다. 따라서 C는 실제로 ACID에 속하지 않는다.

### 격리성

ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.

직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않는다. ex. 직렬성보다 보장이 약한 스냅숏 격리를 구현한 오라클

### 지속성

트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

- WAL
- 현실에서 절대적 보장을 제공하는 한 가지 기법은 없다.

## 단일 객체 연산과 다중 객체 연산

다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.

- 격리성은 사용자 2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일은 없게 해준다.

### 단일 객체 쓰기

### 다중 객체 트랜잭션의 필요성

- 관계형 데이터 모델에서 테이블의 로우는 종종 다른 테이블의 로우를 참조하는 외래 키를 갖는다.
- 문서 데이터베이스는 비정규화를 장려하기도 한다. 비정규화된 정보를 갱신할 때는 한 번에 여러 문서를 갱신해야 한다.
- 보조 색인 갱신: 트랜잭션 관점에서 색인은 서로 다른 데이터베이스 객체다.

### 오류와 어보트 처리

어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.

- 커밋 성공을 알리는 도중 네트워크가 끊겼을 때 재시도하면 트랜잭션이 두 번 실행됨. 중복 제거 메커니즘 필요
- 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 개선하는 게 아니라 악화시킬 수 있다.
- 영구적인 오류는 재시도해도 아무 소용이 없다.
- 외부 부수효과
- 재시도 중 다운 → 데이터 손실

# 완화된 격리 수준

동시성 문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.

데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.

직렬성 격리는 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.

따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는, **완화된 격리 수준을 사용**하는 시스템들이 흔하다.

## 커밋 후 읽기

### 더티 읽기 방지

다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 없음

### 더티 쓰기 방지

나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 경우 → 더티 쓰기

보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두번째 쓰기를 지연시키는 방법을 사용한다.

- 커밋 후 읽기는 두 번의 카운터 증가 사이에 발생하는 경쟁 조건은 막지 못한다.

### 커밋 후 읽기 구현

- 로우 수준 잠금을 사용해 더티 쓰기를 방지
- 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게함
- 문제점: 비반복 읽기, 읽기 스큐
    
    

## 스냅숏 격리와 반복 읽기

트랜잭션이 특정 시점에 고정된 데이터베이스의 일관된 스냅숏만 볼 수 있게 한다.

### 스냅숏 격리 구현

스냅숏 격리의 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것이다.

→ 따라서 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다.

- ***MVCC(Multi-Version Concurrency Control)***
    
    > 데이터베이스에서 동시성을 제어하는 기법 중 하나로, 하나의 데이터를 여러 버전으로 관리하여 읽기 작업과 쓰기 작업이 충돌하지 않도록 하는 방법이다.
    > 
    
    **MVCC가 필요한 이유**
    
    - 일반적인 락 기반의 동시성 제어는 트랜잭션 간 경쟁이 발생하여 성능이 저하될 수 있다.
    - MVCC는 락을 최소화하면서 동시에 읽기와 쓰기 작업을 수행할 수 있도록 설계된 방식이다.
    - 최근에는 데이터베이스들이 더 많은 동시성 처리를 위해 락보다는 MVCC를 사용한다.
    
    **동작 방식**
    
    1. 각 트랜잭션이 데이터를 수정할 때 새로운 버전 생성
    2. 읽기 작업(select)은 기존 버전을 참조
        1. READ COMMITED, REAPEATABLE READ 같은 격리 수준에 사용됨
    3. 쓰기 작업(update, delete, insert)은 새로운 버전 생성
        1. update는 기존 데이터를 즉시 변경하는 것이 아니라, 새로운 버전을 생성함
        2. 이전 데이터를 참조하는 트랜잭션이 종료될 때까지 기존 데이터는 그대로 유지됨.
    4. 불필요한 버전 삭제 (Garbage Collection)
        1. 데이터베이스는 GC 작업을 수행하여 불필요한 버전을 삭제함.
    
    **장점**
    
    - **읽기 작업이 블로킹되지 않음** → SELECT 시 락을 사용하지 않음
    - **동시성 향상** → 여러 트랜잭션이 충돌 없이 동작 가능
    - **트랜잭션 격리 수준 향상** → `REPEATABLE READ`에서 일관된 데이터 제공
    
    **단점**
    
    - **불필요한 데이터 버전이 증가** → **스토리지 공간이 많이 사용됨**
    - **Garbage Collection 필요** → 불필요한 데이터 삭제 작업이 필요하여 성능 저하 가능
    - **쓰기 작업이 많으면 성능 저하 가능** → 새로운 버전을 계속 생성해야 하므로 Overhead 발생

### 일관된 스냅숏을 보는 가시성 규칙

아래 두 조건이 모두 참이면 객체를 볼 수 있다.

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

### 반복 읽기와 혼란스러운 이름

스냅숏 격리는 오라클에서는 '직렬성'으로, PostgreSQL과 MySQL에서는 '반복 읽기(Repeatable Read)'로 불리기도 한다. 이처럼 이름이 혼란스러운 이유는 SQL 표준에 스냅숏 격리의 개념이 없었기 때문이다. 표준의 정의가 모호하여 데이터베이스마다 같은 이름이라도 제공하는 보장이 다르다.

### 갱신 손실 방지

두 트랜잭션이 동시에 같은 데이터를 읽고 수정할 때, 나중에 커밋된 쓰기가 먼저 커밋된 내용을 덮어써서 데이터가 유실되는 현상을 막아야 한다.

- **원자적 쓰기 연산**: 데이터베이스에서 제공하는 `UPDATE ... SET x = x + 1` 같은 연산을 사용하여 '읽기-수정-쓰기' 주기를 한 번에 처리한다.
- **명시적인 잠금**: 애플리케이션이 `FOR UPDATE` 구문을 사용해 수정할 데이터를 미리 잠그는 방식이다.
- **갱신 손실 자동 감지**: 데이터베이스가 트랜잭션 실행 중 갱신 손실을 발견하면 트랜잭션을 어보트시키고 재시도하게 한다.
- **Compare-and-set**: 값을 업데이트하기 전에 읽었던 당시의 값과 현재 값이 일치하는지 확인하는 연산이다.
- **충돌 해소와 복제**: 복제된 데이터베이스에서는 버전 벡터 등을 사용하여 여러 노드에서 발생한 쓰기 충돌을 병합하거나 해소해야 한다.

### 쓰기 스큐와 팬텀

- **쓰기 스큐를 특징짓기**: 두 트랜잭션이 서로 다른 객체를 갱신하지만, 결과적으로 애플리케이션의 비즈니스 규칙(예: 당직 의사는 최소 한 명이어야 한다)을 위반하는 현상이다.
- **추가적인 쓰기 스큐의 예**: 회의실 예약 시스템, 게임 내 캐릭터 위치 선점, 사용자 이름 중복 가입 등.
- **쓰기 스큐를 유발하는 팬텀**: 어떤 트랜잭션의 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 현상을 팬텀(Phantom)이라 하며, 이는 쓰기 스큐의 주요 원인이 된다.
- **충돌 구체화**: 팬텀을 방지하기 위해 데이터베이스에 인위적으로 잠금용 로우를 생성하여 동시성을 제어하는 기법이다. 하지만 구현이 지저분하므로 최후의 수단으로 사용한다.

### 직렬성

가장 강력한 격리 수준으로, 여러 트랜잭션이 병렬로 실행되더라도 결과는 순차적으로 하나씩 실행한 것과 동일함을 보장한다.

- **실제적인 직렬 실행**: 하드웨어 성능 향상으로 인해 단일 스레드에서 트랜잭션을 순차적으로 하나씩 실행하는 것이 가능해졌다. (ex. Redis, VoltDB)
- **트랜잭션을 스토어드 프로시저 안에 캡슐화하기**: 네트워크 호출 대기 시간을 줄이기 위해 트랜잭션 로직을 데이터베이스 내부에서 실행되는 프로시저로 작성한다.
- **스토어드 프로시저의 장단점**: I/O 대기를 없애 성능이 좋지만, 디버깅이 어렵고 DB 서버의 리소스를 많이 점유한다.
- **파티셔닝**: 여러 CPU 코어를 활용하기 위해 데이터를 파티셔닝하지만, 여러 파티션에 걸친 트랜잭션은 성능이 급격히 떨어진다.
- **직렬 실행 요약**: 트랜잭션이 작고 빨라야 하며, 활성 데이터셋이 메모리에 들어갈 수 있는 경우에만 유효하다.

### 2단계 잠금(2PL)

가장 널리 쓰였던 직렬성 구현 알고리즘이다. "쓰는 쪽이 읽는 쪽을 막고, 읽는 쪽이 쓰는 쪽을 막는다"는 점이 스냅숏 격리와의 결정적 차이다.

- **2단계 잠금 구현**: 공유 잠금(Shared lock)과 독점 잠금(Exclusive lock)을 사용하며, 트랜잭션이 끝날 때까지 모든 잠금을 유지한다.
- **2단계 잠금의 성능**: 잠금을 획득하고 기다리는 오버헤드와 교착 상태(Deadlock)가 자주 발생하여 처리량(Throughput)이 크게 저하된다.
- **서술 잠금**: 특정 객체가 아니라 검색 조건에 해당하는 모든 객체에 잠금을 거는 방식이다.
- **색인 범위 잠금**: 서술 잠금의 오버헤드를 줄이기 위해 색인 자체에 범위를 지정해 잠금을 거는 근사치 방식이다.

### 직렬성 스냅숏 격리(SSI)

성능 손실을 최소화하면서 직렬성을 제공하는 최신 기법이다. 낙관적 동시성 제어 방식을 사용한다.

- **비관적 동시성 제어 대 낙관적 동시성 제어**: 비관적(2PL)은 위험하면 일단 막고 보지만, 낙관적(SSI)은 일단 진행한 뒤 커밋 시점에 문제가 있으면 어보트한다.
- **뒤처진 전제에 기반한 결정**: 트랜잭션이 질의 결과를 기반으로 결정을 내렸는데, 커밋 시점에 그 전제가 바뀌었다면 직렬성이 깨진 것으로 간주한다.
- **오래된 MVCC 감지하기**: 트랜잭션이 읽은 데이터 버전이 다른 트랜잭션에 의해 수정되었는지 추적한다.
- **과거의 읽기에 영향을 미치는 쓰기 감지하기**: 트랜잭션이 데이터를 읽은 후, 다른 트랜잭션이 그 데이터를 수정하려고 하면 읽은 쪽에서 경고를 기록한다.
- **직렬성 스냅숏 격리의 성능**: 읽기 작업이 쓰기 작업을 차단하지 않으므로 읽기 비중이 높은 시스템에서 2PL보다 훨씬 빠르다.

### 정리

트랜잭션은 복잡한 동시성 이슈와 하드웨어 결함 속에서 애플리케이션 개발자를 보호하는 강력한 추상화 도구다. 하지만 완벽한 안전(직렬성)은 비용이 따르며, 시스템의 요구사항에 따라 적절한 격리 수준을 선택하는 혜안이 필요하다.
