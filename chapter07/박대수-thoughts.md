# Chapter 07: 트랜잭션 - Deep Dive

## 원자적 연산이 복제 상황에서도 잘 동작하는 이유

복제된 데이터베이스 환경에서 원자적 연산(단일 객체 연산)이 효과적으로 동작하는 이유는 다음과 같습니다:

### 1. 로그 기반 복제의 순차적 적용

**로그 기반 복제**에서는 모든 쓰기 연산이 리더에서 발생한 순서대로 로그에 기록되고, 팔로워들이 동일한 순서로 재실행합니다.

- **연산의 원자성 보장**: 단일 객체에 대한 원자적 연산은 하나의 로그 엔트리로 기록되므로, 팔로워에서도 동일하게 하나의 단위로 적용됩니다.
- **순서 일관성**: 복제 로그의 순차적 적용으로 인해 모든 복제본에서 동일한 연산 순서를 유지합니다.
- **부분적 적용 방지**: 하나의 원자적 연산이 로그에 기록되면, 팔로워에서는 그 연산을 완전히 적용하거나 전혀 적용하지 않습니다.

### 2. 단일 파티션 내에서의 로컬 트랜잭션

대부분의 복제 시스템에서 **단일 객체 연산은 단일 파티션 내에서 수행**됩니다:

- **파티션 단위의 격리**: 각 파티션은 독립적으로 복제되므로, 파티션 내의 연산은 다른 파티션의 간섭 없이 원자적으로 수행됩니다.
- **합의 알고리즘 활용**: 리더 선출과 로그 복제에 합의 알고리즘(Raft, Paxos 등)을 사용하면, 모든 복제본이 동일한 연산 순서를 따릅니다.
- **선형성 보장**: 단일 객체에 대한 연산이 선형성(linearizable)을 만족하면, 복제 환경에서도 일관된 결과를 보장합니다.

### 3. 복제 지연과 일관성 모델

복제 지연이 있는 상황에서도 원자적 연산이 잘 동작하는 이유:

- **최종적 일관성**: 복제 지연으로 인해 일시적으로 다른 값을 볼 수 있지만, 결국 모든 복제본이 동일한 최종 상태에 도달합니다.
- **읽기 일관성**: 강한 일관성 읽기가 필요한 경우, 리더에서 읽거나 합의 기반 읽기를 통해 보장할 수 있습니다.
- **커밋된 연산의 영속성**: 원자적 연산이 리더에서 커밋되면, 복제 로그를 통해 모든 팔로워에 전파되어 손실되지 않습니다.

### 4. 다중 객체 연산과의 차이점

단일 객체 연산이 복제에서 잘 동작하는 반면, 다중 객체 연산은 더 복잡합니다:

- **다중 객체 연산의 어려움**: 여러 객체에 걸친 연산은 여러 파티션에 걸칠 수 있어, 분산 합의가 필요합니다.
- **2단계 커밋(2PC)의 복잡성**: 다중 객체 트랜잭션을 복제 환경에서 구현하려면 2PC를 사용해야 하지만, 이는 복제 지연과 결합되면 매우 복잡해집니다.
- **단일 객체 연산의 단순성**: 하나의 객체만 다루므로, 복제 프로토콜이 단순하고 신뢰할 수 있습니다.

### 5. 실제 시스템에서의 구현

현대 데이터베이스 시스템에서 이러한 원칙이 어떻게 적용되는지:

- **DynamoDB**: 단일 항목 연산은 원자적이며, 복제 환경에서도 강한 일관성을 보장합니다.
- **Cassandra**: 최종적 일관성 모델을 사용하지만, 단일 파티션 내에서는 원자적 연산을 지원합니다.
- **PostgreSQL**: 물리적 복제에서 WAL(Write-Ahead Log)을 통해 원자적 연산의 순서를 보장합니다.

### 결론

원자적 연산이 복제 상황에서도 잘 동작하는 근본적인 이유는 **복제 프로토콜이 연산의 순서와 원자성을 보장**하기 때문입니다. 단일 객체 연산은 복제 로그의 단일 엔트리로 표현될 수 있고, 로그의 순차적 적용을 통해 모든 복제본에서 동일한 결과를 보장합니다. 이는 다중 객체 연산보다 훨씬 단순하고 신뢰할 수 있는 접근 방식입니다.