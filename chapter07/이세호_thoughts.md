# ACID란 그럼 뭘 의미하는거지..? 애초에 ACID는 허상인가

1. 학술적 기원의 차이
   트랜잭션 (Transaction): 1970년대 초반, 짐 그레이(Jim Gray) 등에 의해 데이터베이스 시스템에서 '하나의 논리적 작업 단위'를 정의하기 위해 등장했습니다. 이는 시스템이 고장 나더라도 데이터의 일관성을 유지하기 위한 실무적인 고민에서 출발했습니다.

ACID: 1983년 테오 해더(Theo Härder)와 안드레아스 로이터(Andreas Reuter)가 기존에 존재하던 트랜잭션의 특성들을 정리하여 'ACID'라는 용어로 공식화했습니다. 즉, 트랜잭션이라는 개념이 먼저 확립된 후, 이를 평가하거나 구현하기 위한 표준 지표로서 ACID가 나중에 정리된 것입니다.

2. 관계의 본질: "정의 vs 구현 표준"
   트랜잭션은 "무엇(What)"에 가깝고, ACID는 그 트랜잭션이 "어떠해야 하는지(How/Attributes)"를 설명합니다.

3. 실제로 "따로 노는" 경우 (학술적/실무적 분리)
   모든 트랜잭션이 반드시 ACID를 완벽하게 지켜야만 '트랜잭션'이라 불리는 것은 아닙니다.

- BASE 모델 (NoSQL): 분산 시스템에서는 가용성을 위해 ACID 중 일관성(Consistency)을 일부 포기하기도 합니다. 이때도 '트랜잭션'이라는 용어를 쓰지만, ACID를 엄격히 따르지 않는 '유연한 트랜잭션'으로 취급합니다.

- 격리 수준 (Isolation Level): 실제 상용 DB(MySQL, Oracle 등)에서는 성능을 위해 ACID 중 'I(Isolation)'를 완벽히 지키지 않는 설정을 기본으로 사용하는 경우가 많습니다. 학술적으로는 ACID 위반이지만, 실무적으로는 여전히 트랜잭션입니다.

결론:

트랜잭션과 ACID는 **"자동차와 안전 기준"**의 관계와 비슷합니다. 자동차(트랜잭션)라는 개념이 먼저 발명되었고, 이후에 안전한 자동차라면 마땅히 갖춰야 할 기준(ACID)이 학술적으로 정립된 것이죠. 둘은 실무에서 한 몸처럼 쓰이지만, 개념적으로는 대상을 정의하는 것과 그 대상의 품질을 정의하는 것이라는 차이가 있습니다.

# 헷갈리는 지점 - 둘다 MVCC로 구현한다고..? Read Committed vs Repeatable Read

📸 Read Committed (커밋된 읽기)

이 수준에서는 "쿼리(SELECT 문)를 날릴 때마다" 새로 사진을 찍습니다.

동작: 트랜잭션 내에 쿼리가 3개 있다면, 각 쿼리가 실행되는 순간마다 최신 커밋된 상태의 스냅숏을 새로 만듭니다.

결과: 쿼리 실행 직전에 다른 트랜잭션이 커밋했다면, 그 내용을 바로 볼 수 있습니다. 그래서 '비반복 읽기(Non-repeatable Read)' 현상이 발생합니다.

🖼️ Repeatable Read (반복 가능한 읽기)

이 수준에서는 "트랜잭션이 시작될 때 딱 한 번" 사진을 찍습니다.

동작: 트랜잭션의 첫 번째 읽기 작업 시점에 스냅숏을 생성하고, 트랜잭션이 끝날 때까지 그 사진만 계속 돌려봅니다.

결과: 그사이 다른 트랜잭션이 100번을 커밋해도, 나는 처음 찍은 사진 속의 데이터만 봅니다. 그래서 '데이터의 일관성'이 유지됩니다.

# MVCC를 실제로 구현하면 어떤 형태?

## 책에서는 왜 분산 트랜잭션에서 SAGA를 언급하지 않는가

- SAGA가 더 평범한 해결책 아닌가?
  - 후반 챕터에 나온다고함.
  - 지금은 일단 db 내에서의 분산 처리에 집중한다고함.
