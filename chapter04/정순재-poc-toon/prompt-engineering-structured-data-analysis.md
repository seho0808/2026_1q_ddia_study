# Prompt Engineering for Structured Data: A Comparative Evaluation of Styles and LLM Performance

## 메타데이터

- **제목**: Prompt Engineering for Structured Data A Comparative Evaluation of Styles and LLM Performance
- **저자**: Jules White, Ashraf Elnashar*, Douglas Schmidt
- **DOI**: 10.20944/preprints202506.1937.v1
- **제출일**: 2025년 6월 23일
- **게시일**: 2025년 6월 24일
- **키워드**: Structured Data Generation, LLMs, Prompt Engineering, JSON, YAML, CSV Formats, Token Efficiency, Data Validation, Cost-Effective AI

---

## Abstract

구조화된 데이터 생성에 대한 프롬프트 엔지니어링 전략의 효과성은 LLM의 능력과 아키텍처가 계속 진화함에 따라 여전히 열려있는 도전 과제입니다. 이전 연구는 GPT-4o를 사용하여 제한된 프롬프트 스타일 세트를 검토했지만, 본 연구는 6가지 프롬프트 스타일(JSON, YAML, CSV, function calling APIs, simple prefixes, hybrid CSV/prefix format)을 세 가지 최첨단 LLM(ChatGPT-4o, Claude, Gemini)에서 비교함으로써 범위를 크게 확장했습니다.

### 주요 평가 지표

1. **정확도(Accuracy)**: 예상 데이터 속성과 값을 정확히 재현하는 능력
2. **토큰 비용(Token Cost)**: API 사용에 소비되는 토큰 수
3. **생성 시간(Generation Time)**: 데이터 생성에 필요한 시간

### 주요 발견사항

- **Claude**: 가장 높은 정확도를 일관되게 제공
- **ChatGPT-4o**: 가장 토큰 효율적이고 시간 효율적
- **Gemini**: 모든 지표에서 균형잡힌 트레이드오프 제공

---

## 1. Introduction

### 연구 배경

구조화된 데이터 추출은 LLM 애플리케이션에서 지속적인 도전 과제입니다. 현대 LLM은 비구조화된 텍스트에서 구조화된 출력을 생성하는 놀라운 능력을 보여주며, 비즈니스 인텔리전스, 헬스케어, 전자상거래 등의 도메인에서 변혁적인 잠재력을 제공합니다.

### 이전 연구와의 차별점

이전 연구는 GPT-4o와 세 가지 프롬프트 스타일(JSON, YAML, Hybrid CSV/Prefix)만을 평가했습니다. 본 연구는 다음과 같이 확장했습니다:

- **프롬프트 스타일**: 3개 → 6개 (JSON, YAML, CSV, API Function Calls, Simple Prefixes, Hybrid CSV/Prefix)
- **LLM 모델**: 1개 → 3개 (ChatGPT-4o, Claude, Gemini)
- **평가 깊이**: 단일 모델 평가 → 다중 모델 비교 분석

### 프롬프트 스타일의 다양성

- **계층적 형식 (JSON, YAML)**: 구조적 엄격성과 하위 시스템 호환성 제공, 하지만 장황하고 계산 비용이 높음
- **단순 형식 (CSV, Prefix-based)**: 더 컴팩트한 표현으로 빠르고 저렴하지만, 구조와 의미적 명확성에서 트레이드오프 존재
- **하이브리드 접근법 (CSV with prefixed rows)**: 구조적 단서를 표 형식에 유지
- **Function-calling APIs**: 네이티브 스키마 기반 인터페이스로 엄격한 데이터 검증 및 프로그래밍 워크플로우 통합 가능

### 연구 기여

1. **실험 설계**: 세 가지 시나리오(개인 스토리, 의료 기록, 영수증)에서 무작위 데이터셋 생성
2. **비교 평가**: 선도적인 LLM(ChatGPT-4o, Claude, Gemini)의 출력을 예상 결과와 비교
3. **자동화된 검증 프레임워크**: 출력 충실도, 토큰 소비, 생성 지연 시간 측정

---

## 2. Research Questions

### Q1: 정확도 (Accuracy)

**어떤 프롬프트 스타일이 각 LLM에 대해 가장 정확한 구조화된 데이터 출력을 생성하는가?**

- 속성 완전성과 정확성 측면에서 평가
- 각 LLM이 예상 속성과 값을 얼마나 정확히 일치시키는지 측정
- 모든 필수 필드가 올바르게 표현되는지 확인

### Q2: 토큰 비용 (Token Cost)

**각 프롬프트 스타일의 토큰 비용은 얼마이며, 어떤 스타일이 가장 비용 효율적인 데이터 생성을 제공하는가?**

- 토큰 사용량은 API 비용과 직접 연결
- 정확도를 희생하지 않고 토큰 사용을 최소화하는 스타일 식별
- 비용 효율성이 중요한 애플리케이션에 핵심적

### Q3: 생성 시간 (Generation Time)

**각 프롬프트 스타일은 생성 시간 측면에서 어떻게 수행되며, 각 LLM에 대해 가장 빠른 기법은 무엇인가?**

- 구조화된 출력 생성에 필요한 응답 시간 측정
- 실시간 애플리케이션이나 배치 처리 작업에서 중요
- 각 LLM별로 가장 빠른 스타일 식별

### Q4: 시나리오별 성능

**특정 시나리오나 데이터 유형(예: 개인 스토리, 영수증, 의료 기록)에서 특정 프롬프트 스타일이 다른 것보다 더 나은 성능을 보이는가?**

- 데이터 유형에 따라 다른 구조 및 완전성 요구사항 존재
- 특정 프롬프트 스타일이 특정 시나리오에 더 적합한지 탐색
- 데이터 유형, 컨텍스트, LLM에 기반한 실용적 가이드 제공

---

## 3. Experiment Design

### 실험 구조

실험은 두 단계로 구성됩니다:

#### Stage One: Data Generation and Prompt Testing

- 세 가지 컨텍스트(개인 스토리, 영수증, 의료 기록)에 맞춘 무작위 데이터셋 생성
- 6가지 프롬프트 스타일 적용
- 세 가지 지표 기록: 정확도, 토큰 사용량, 생성 시간

#### Stage Two: Assessment and Refinement

- 각 LLM이 생성한 출력을 원본 데이터셋과 비교하여 검증
- 정확도 측정
- 가장 효율적이고 효과적인 프롬프트 스타일 식별
- 실행 가능한 권장사항으로 정리

### 데이터셋

#### 3.1.1. Personal Stories Dataset

- **목적**: 각 LLM이 구조화된 입력 속성을 충실히 통합한 서사적 출력을 생성하는 능력 평가
- **속성**: name, age, city, email (선택적)
- **검증**: 패턴 매칭 알고리즘을 사용하여 모든 입력 속성이 생성된 텍스트에 포함되었는지 확인

#### 3.1.2. Medical Record Dataset

- **목적**: 각 LLM이 입력 속성을 정확히 나타내는 구조화된 의료 기록을 생성하는 능력 평가
- **속성**: name, age (선택적), city (선택적), email (선택적), diagnosis, prescriptions, doctor's notes
- **특징**: 의료 특정 필드 포함 (실험 범위 외)

#### 3.1.3. Receipt Dataset

- **목적**: 각 LLM이 입력 속성을 정확히 나타내는 구조화된 영수증을 생성하는 능력 평가
- **속성**: name, age (선택적), city (선택적), email (선택적)
- **특징**: 거래 또는 개인에 대한 구조화된 정보를 공식 영수증 템플릿에 포함

### 프롬프트 스타일

#### 1. JSON Format
- 계층적 구조와 중첩 속성에 적합
- 구조적 엄격성 제공

#### 2. YAML Format
- 인간이 읽기 쉬운 형식 강조
- 엄격한 포맷팅 표준 유지
- 인간과 기계 모두의 해석에 적합

#### 3. CSV Format
- 평면적이고 표 형식의 데이터 표현
- 단순성과 데이터 분석 도구와의 호환성 보장

#### 4. API Function Call Format
- API 상호작용 시뮬레이션
- JSON으로 함수 인수를 포맷팅
- 스키마 요구사항을 정확히 충족하도록 LLM에 도전

#### 5. Simple Prefix Format
- 레이블이 지정된 필드 사용 (예: `Name:`, `Age:`)
- 인간이 읽기 쉬운 형식과 경량 표현에 초점

#### 6. Hybrid CSV/Prefix Format
- 표 형식 데이터와 접두사 텍스트 요소 결합
- 값이 없을 때도 모든 속성에 대한 플레이스홀더 유지 요구

### 평가 지표

1. **정확도 측정**: 생성된 출력에 올바르게 포함된 속성의 백분율 계산
2. **토큰 사용량 측정**: 각 프롬프트 스타일과 LLM에 대해 소비된 토큰 수 평가
3. **시간 효율성 측정**: 출력 생성에 대한 응답 시간 계산

---

## 4. Analysis of Experiment Results

### 4.1. ChatGPT-4o 분석

#### 4.1.1. 정확도 분석

- **구조화된 데이터셋** (Patient Information, Receipt): 거의 100%의 일관된 높은 정확도
- **서사 스타일 데이터셋** (Personal Story): 20%-40%로 정확도가 크게 감소
- **최고 성능 스타일**: API Function Call, YAML, Hybrid CSV/Prefix
- **약점**: 서사 데이터 구조화에서의 어려움

#### 4.1.2. 토큰 사용량 분석

- **가장 높은 토큰 사용**: API Function Call, JSON (특히 Patient Information, Personal Story)
- **가장 낮은 토큰 사용**: CSV (모든 데이터셋 유형에서)
- **균형잡힌 스타일**: Hybrid CSV/Prefix, Simple Prefixes
- **데이터셋별**: Receipt 데이터셋이 모든 프롬프트 스타일에서 가장 낮은 토큰 사용량

#### 4.1.3. 시간 분석

- **가장 긴 처리 시간**: API Function Call, JSON (특히 Patient Information, Personal Story)
  - Patient Information의 JSON 처리: 10초 이상
- **가장 짧은 처리 시간**: CSV, Receipt 데이터셋 (종종 3초 미만)
- **중간 범위**: Hybrid CSV/Prefix, YAML

### 4.2. Claude 분석

#### 4.2.1. 정확도 분석

- **구조화된 데이터셋**: 거의 100%의 일관된 높은 정확도 (모든 프롬프트 스타일)
- **서사 스타일 데이터셋**: 약 40%로 정확도 안정화
- **특징**: 프롬프트 스타일과 무관하게 일관된 성능
- **강점**: 구조화된 작업에서의 신뢰성

#### 4.2.2. 토큰 사용량 분석

- **가장 높은 토큰 사용**: API Function Call, JSON (700 토큰 초과)
- **가장 낮은 토큰 사용**: CSV, Simple Prefixes
- **데이터셋별**: Receipt가 가장 낮은 토큰 소비
- **순서**: Patient Information > Personal Story > Receipt

#### 4.2.3. 시간 분석

- **가장 긴 처리 시간**: API Function Call, JSON (평균 12초 이상)
- **가장 짧은 처리 시간**: CSV, Receipt (2초 미만)
- **중간 범위**: Hybrid CSV/Prefix, YAML

### 4.3. Gemini 분석

#### 4.3.1. 정확도 분석

- **구조화된 데이터셋**: 거의 100%의 일관된 높은 정확도
- **서사 스타일 데이터셋**: 약 40%로 정확도 안정화
- **최고 성능 스타일**: API Function Call, YAML
- **약점**: Hybrid CSV/Prefix에서 Patient Information에 대한 정확도 약간 감소

#### 4.3.2. 토큰 사용량 분석

- **가장 높은 토큰 사용**: API Function Call, JSON (500 토큰 초과)
- **가장 낮은 토큰 사용**: CSV (Receipt에서 100 토큰 미만)
- **중간 범위**: Hybrid CSV/Prefix, YAML
- **데이터셋별**: Patient Information > Personal Story > Receipt

#### 4.3.3. 시간 분석

- **가장 긴 처리 시간**: API Function Call (Personal Story에서 10초 초과)
- **가장 짧은 처리 시간**: CSV, Hybrid CSV/Prefix (Receipt에서 4초 미만)
- **중간 범위**: YAML, JSON
- **특징**: Personal Story가 가장 가변적이고 시간 집약적

---

## 5. Comparison of ChatGPT-4o, Claude, and Gemini

### 5.1. 정확도 비교

**주요 발견사항:**

- **Claude**: 가장 정확한 LLM (80% 이상의 일관된 정확도)
  - 다양한 입력 구조와 데이터셋 처리 능력
  - 견고성과 다용도성 강조
- **ChatGPT-4o**: 안정적인 성능 (75%-80% 범위)
  - 다양한 프롬프트 스타일에 대한 적응성
- **Gemini**: 가변적 정확도
  - YAML, API Function Call에서 우수
  - Hybrid CSV/Prefix에서 65% 미만으로 감소

**프롬프트 스타일별:**
- **높은 정확도**: API Function Call, YAML (모든 모델)
- **도전적**: Hybrid CSV/Prefix (특히 Gemini)

### 5.2. 토큰 사용량 비교

**주요 발견사항:**

- **ChatGPT-4o**: 가장 토큰 효율적 (모든 프롬프트 스타일에서 가장 낮은 토큰 사용)
  - CSV, Simple Prefixes, Hybrid CSV/Prefix에서 특히 효율적
- **Claude**: 가장 높은 토큰 사용 (대부분의 프롬프트 스타일)
  - API Function Call, JSON에서 ChatGPT-4o와 Gemini보다 훨씬 높음
  - 더 상세하고 장황한 응답 생성 경향
- **Gemini**: 중간 위치
  - 모든 프롬프트 스타일에서 중간 범위의 토큰 사용
  - 상세 출력과 토큰 효율성 사이의 균형

**실용적 함의:**
- **ChatGPT-4o**: 토큰 제한이나 비용 제약이 중요한 애플리케이션에 이상적
- **Claude**: 더 상세하고 정교한 응답이 필요한 경우에 유리하지만, 토큰 경제성이 필수적인 경우에는 부적합
- **Gemini**: 다양한 애플리케이션에 대한 다용도 옵션

### 5.3. 시간 성능 비교

**주요 발견사항:**

- **ChatGPT-4o**: 가장 빠른 처리 시간 (4-6초 범위 유지)
  - 모든 프롬프트 스타일에서 일관된 시간 효율성
  - JSON과 같은 복잡한 프롬프트 스타일에서도 효율적
- **Claude**: 가장 긴 처리 시간
  - API Function Call, JSON에서 9초에 근접
  - 상세한 출력 생성 프로세스로 인한 오버헤드
- **Gemini**: 가변적 성능
  - CSV, Hybrid CSV/Prefix에서 효율적
  - JSON에서 Claude와 유사한 처리 시간

**프롬프트 스타일별:**
- **단순 스타일 (CSV)**: 모든 모델에서 짧은 처리 시간
- **복잡한 스타일 (JSON, API Function Call)**: 처리 시간 증가

### 5.4. 종합 성능 비교

#### 5.4.1. 메트릭별 비교 (Bar Charts)

**전체 성능 요약:**

- **Claude**
  - 정확도: 85% (최고)
  - 토큰 효율성: 60%
  - 시간 효율성: 60%
  - **강점**: 복잡한 데이터 구조(JSON, YAML) 요구 작업에서 탁월

- **ChatGPT-4o**
  - 정확도: 78%
  - 토큰 효율성: 90% (최고)
  - 시간 효율성: 95% (최고)
  - **강점**: 비용에 민감한 작업에 가장 실용적

- **Gemini**
  - 정확도: 76%
  - 토큰 효율성: 70%
  - 시간 효율성: 75%
  - **강점**: 모든 메트릭에서 균형잡힌 성능

#### 5.4.2. 트레이드오프 분석 (Radar Charts)

**시각화 목적:**
- Bar Chart: 상세한 메트릭별 비교, 정량적 강점/약점 파악
- Radar Chart: 통합 프로필을 통한 직관적 이해, 실용적 의사결정 지원

#### 5.4.3. 성능 분석

**정확도:**
- Claude (85%) > ChatGPT-4o (78%) > Gemini (76%)
- Claude는 계층적 표현(JSON, YAML)에서 구조적 무결성 보존 능력 강함

**토큰 효율성:**
- ChatGPT-4o (90%) > Gemini (70%) > Claude (60%)
- ChatGPT-4o는 간결하고 컴팩트한 출력 생성 능력

**시간 효율성:**
- ChatGPT-4o (95%) > Gemini (75%) > Claude (60%)
- ChatGPT-4o는 대부분의 프롬프트 스타일에서 더 빠른 응답 시간

#### 5.4.4. 트레이드오프 및 실용적 권장사항

**Claude:**
- **이상적**: 높은 충실도의 구조화된 출력이 필요한 작업
- **특화**: JSON, YAML과 같은 복잡한 형식
- **트레이드오프**: 토큰 사용량 증가 및 처리 시간 증가

**ChatGPT-4o:**
- **이상적**: 성능과 리소스 효율성 사이의 최적 균형
- **특화**: 비용에 민감하거나 실시간 애플리케이션
- **트레이드오프**: 정확도는 약간 낮지만 토큰 및 시간 효율성 우수

**Gemini:**
- **이상적**: 범용 구조화된 데이터 생성
- **특화**: 다양한 애플리케이션에 대한 다용도 후보
- **트레이드오프**: Hybrid CSV/Prefix에서 정확도 감소 및 가변성

#### 5.4.5. 비교표 요약

**주요 인사이트:**

- **JSON, YAML**: 모든 모델에서 계층적 데이터 표현에 효과적, 하지만 장황성으로 인한 높은 토큰 소비
- **CSV, Simple Prefix**: 경량, 비용 효율적, 짧은 처리 시간, 하지만 복잡한 데이터 구조 표현에서 유연성 희생
- **Hybrid CSV/Prefix**: 표 형식과 접두사 강점 균형, 다양한 애플리케이션에 잠재력, 하지만 모든 모델에서 일관된 성능 보장에 도전

---

## 6. Related Work

### 프롬프트 엔지니어링

- 프롬프트 설계가 LLM의 구조화된 출력 생성 능력에 중요한 역할
- Brown et al. (2020): 프롬프트 기반 스타일 도입
- 대부분의 연구는 특정 LLM에 맞춘 프롬프트 사용 → 교차 모델 평가에 편향 가능
- **본 연구의 기여**: GPT-4o, Claude, Gemini에 걸쳐 표준화된 프롬프트 세트 사용

### 교차 LLM 비교

- 기존 연구는 단일 LLM의 격리된 성능에 초점
- Raffel et al. (2020): T5 프레임워크 내 다양한 트랜스포머 모델 비교
- Zhang et al. (2021): 작업별 애플리케이션에 대한 교차 모델 평가
- **본 연구의 기여**: 동일한 데이터셋과 일관된 프롬프트를 사용하여 세 가지 선도 LLM 평가

### 성능 메트릭

- 정확도, 토큰 사용량, 응답 시간을 포함한 다면적 접근 필요
- Vaswani et al. (2017), OpenAI, Anthropic: 토큰 효율성 강조
- **본 연구의 기여**: 다양한 데이터셋과 프롬프트 스타일에서 이러한 메트릭을 포괄적으로 분석

### 도메인별 응용

- 헬스케어: 합성 의료 기록 생성
- 전자상거래: 제품 설명 및 영수증 요약 생성
- **본 연구의 데이터셋**: Personal Stories, Medical Records, Receipt Records

---

## 7. Concluding Remarks

### 주요 교훈

#### 1. 프롬프트 설계의 트레이드오프는 컨텍스트 의존적

- 계층적 형식(JSON, YAML): 우수한 정확도, 높은 토큰 비용
- 단순 형식(CSV, Simple Prefixes): 비용 효율적, 복잡한 구조에 대한 유연성 감소
- 개발자와 데이터 과학자가 정확도, 효율성, 비용 효율성을 균형있게 선택할 수 있도록 도움

#### 2. 대안 형식의 고유한 장점

- Simple Prefixes, Hybrid 접근법: 특정 사용 사례에서 높은 정확도와 감소된 토큰 비용 제공
- 덜 장황하고 명확성과 간결성 사이의 균형
- 영수증이나 거래 기록과 같은 반구조화된 데이터에 가치

#### 3. 일관된 프롬프트가 평가 공정성 향상

- 다른 LLM에 걸쳐 일관된 프롬프트 사용은 평가의 공정성 보장
- 각 LLM의 고유한 능력을 강조
- 표준화된 프롬프트는 성능 비교를 위한 신뢰할 수 있는 기준선 제공

#### 4. 효율성 향상은 LLM 간에 다름

- ChatGPT-4o: 토큰 소비와 시간 모두에서 가장 높은 효율성
- Claude: 정확도에서 탁월
- Gemini: 두 가지 사이의 균형
- 속도나 비용 제약이 중요한 특정 사용 사례에 대한 LLM 선택 가이드 제공

#### 5. 애플리케이션이 프롬프트 선택에 영향

- 프롬프트 스타일 선택은 애플리케이션 도메인에 따라 크게 다를 수 있음
- JSON, YAML: 헬스케어와 같은 계층적 데이터 표현이 필요한 도메인에 더 적합
- CSV, Simple Prefixes: 토큰 효율성과 처리 속도가 중요한 전자상거래 도메인에서 탁월
- 결과는 이러한 도메인에 걸쳐 유사한 구조화된 데이터로 일반화 가능

#### 6. 프롬프트 설계가 결과에 영향

- 신중한 초기 프롬프트 설계가 LLM 출력의 정확도와 효율성을 결정하는 데 핵심 역할
- 데이터셋의 복잡성과 의도된 사용 사례에 맞는 프롬프트 스타일 선택의 중요성
- 향후 연구: 반복적 정제의 역할 탐색

### 연구 확장

이 논문은 이전 연구를 다음과 같이 확장했습니다:

- **프롬프트 디자인 공간 확장**: 3개 → 6개 스타일
- **모델 다양성 확장**: 1개 → 3개 LLM
- **평가 깊이 확장**: 단일 모델 평가 → 다중 모델 비교 분석

이러한 기여는 실세계 애플리케이션에서 구조화된 데이터 생성을 위해 LLM을 효과적으로 활용하는 방법에 대한 더 넓은 이해를 지원합니다.

---

## 참고사항

### 실험 방법론

- **표준화된 프롬프트**: 모든 LLM에 대해 동일한 프롬프트 사용 (LLM별 맞춤 없음)
- **자동화된 검증**: Python 유틸리티를 통한 구조화된 데이터 검증 및 분석
- **시각화**: Technique vs. Accuracy, Technique vs. Token Cost, Technique vs. Time 그래프

### 실용적 권장사항 요약

| LLM | 정확도 | 토큰 효율성 | 시간 효율성 | 최적 사용 사례 |
|-----|--------|------------|------------|---------------|
| **Claude** | ⭐⭐⭐⭐⭐ (85%) | ⭐⭐⭐ (60%) | ⭐⭐⭐ (60%) | 복잡한 계층적 데이터 구조가 필요한 작업 |
| **ChatGPT-4o** | ⭐⭐⭐⭐ (78%) | ⭐⭐⭐⭐⭐ (90%) | ⭐⭐⭐⭐⭐ (95%) | 비용에 민감하거나 실시간 애플리케이션 |
| **Gemini** | ⭐⭐⭐⭐ (76%) | ⭐⭐⭐⭐ (70%) | ⭐⭐⭐⭐ (75%) | 범용 구조화된 데이터 생성 |

### 프롬프트 스타일별 특성

| 스타일 | 정확도 | 토큰 효율성 | 시간 효율성 | 복잡도 |
|--------|--------|------------|------------|--------|
| **JSON** | 높음 | 낮음 | 낮음 | 높음 |
| **YAML** | 높음 | 중간 | 중간 | 중간 |
| **CSV** | 중간 | 높음 | 높음 | 낮음 |
| **API Function Call** | 높음 | 낮음 | 낮음 | 높음 |
| **Simple Prefix** | 중간 | 높음 | 중간 | 낮음 |
| **Hybrid CSV/Prefix** | 중간-높음 | 중간 | 중간 | 중간 |

---

## References

논문의 전체 참고문헌 목록은 원본 논문을 참조하세요.

---

**Note**: 이 문서는 원본 논문의 주요 내용을 요약한 것입니다. 상세한 실험 결과, 그래프, 표는 원본 논문을 참조하시기 바랍니다.
