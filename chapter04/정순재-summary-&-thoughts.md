# Chapter 4. 부호화와 발전 (Encoding and Evolution)

- 이번 챕터에선 크게 다음과 같은 주제를 다룸
  - 데이터 부호화 포맷
    - 스키마리스
      - JSON, XML, CSV
      - 메시지팩
    - 스키마 기반
      - thrift, protobuf
      - avro
  - 데이터플로 모드
    - 데이터베이스
    - 서비스 (REST, RPC)
    - 메시지 브로커 (pub/sub)
    - 분산 액터 프레임워크 (Akka, Orleans, Erlang OTP)
- 그리고 챕터 전체를 관통하는 주제는 바로 호환성(Compatibility).

## 데이터 부호화 포맷

- JSON, XML, CSV는 텍스트 기반 포맷으로 가독성이 좋지만, 크기가 크고, 호환성이 좋지 않다.
  - 이러한 단점에도 불구하고 매우 인기가 높은데
  - 이유는 바로 사람들이 "동의"했기 때문.
  - 직관적이고 사용성이 좋을 수록 "동의"를 구하기 쉬운듯. 그게 설령 많은 단점을 가지고 있더라도.
- protobuf도 굉장히 인기가 높은데
  - 구글의 grpc가 호환성을 굉장히 잘 만들어서 그런듯.
  - 언어나 프레임워크를 초월해 사용 가능하기 때문에 어느 환경에서든 쉽게 채택될 수 있음.
  - 즉, "동의"를 쉽게 구할 수 있음.
  - 코드 생성에 의존하는 것도 한몫함.
  - 약타입 vs 강타입, 동적 타입 vs 정적 타입에 대한 논쟁과도 맞닿아있음.
  - 빌드/배포단계에서도 동적타입 입장에선 코드 생성에 의존하는건 불필요한 작업이 될 수 있음.
  - 하지만 반대진영에선 굉장히 인기가 좋음.
  - 스키마의 최신 상태를 확신할 수 있다는 것도 엄청난 장점
  - 백엔드 개발자라면 한번쯤 경험해본 rest api 명세 지옥을 떠올려보자.

## 데이터플로

- 데이터베이스
  - "미래의 자신에게 메시지를 보내는 일"이라는 표현은 굉장히 재밌음.
  - 저장할때 db 설계를 신경쓰지 않는다면 메시지를 해석하고 새로 메시지를 쓰려(db에 데이터를 가공해 저장하려)면 매우 어려움.
  - 결국 데이터 스키마도 어플리케이션이 성숙함에 따라 함께 발전해야 함. 이는 챕터의 초반부에 잘 설명해줌.
  - "데이터가 코드보다 더 오래 산다"라는 말도 재밌었음.
  - 이는 결국 데이터가 가장 변하지 않는 요소라고 봐도 무방함.
  - 데이터는 일종의 자산이라 생각하기 때문에 지갑을 바꿔도 그 가치는 변하지 않음.
  - 하지만 그렇기에 데이터는 쉽게 쌓이고, 레거시화되기 쉬움.
  - 경험상 복잡하게 쌓인 데이터는 스파게티 코드보다 더 악취가 심하고 해결이 어려움.
- REST와 RPC
  - 팀이 만들어진지 2년정도만에 100개 가까이 되는 MSA 구조의 회사를 경험해본적이 있음.
  - 그런데 중요한 점은 대부분의 서비스가 REST API를 통해 통신하고 있었음.
  - 이유를 물어보니 RPC가 아니라 REST API를 사용하는 것이 더 쉽고, 더 안정적이기 때문이라고 함.
  - 위에서 언급한 "동의" 문제가 떠올랐음.
  - REST API도 사용하다보면 닥치게 되는 많은 고민들이 있지만
  - 일정 수준의 동의를 구하게 되면 사용성이 아주 좋음.
  - 브라우저 친화적인 것도 한몫하는 듯. HTTP 기반 웹 생태계의 성숙도가 굉장히 높아 다른 고민할 필요 없음.
  - 한때 tRPC라고 타입스크립트 기반 RPC 프레임워크가 유행했는데 지금은 어떤지 모르겠음.
  - 채용 시장에서 잘 보이지 않는 것으로 봐선 일단 한국시장에선 많이 사용되진 않는듯.
- 메시지 브로커
  - 꽤 역사가 깊은 기술로 알고 있지만 EDA, MSA의 유행과 함께 순풍을 맞았었음. 지금은 어떤지 모르겠음.
  - 서비스간의 의존을 아름답게 줄여줘 MSA와 궁합이 아주 잘맞음.
- 분산 액터 프레임워크
  - 잘 모르겠음.
  - llm 답변으로 대체함

**액터 모델 (Actor Model)**:

- 동시성을 위한 프로그래밍 모델
- 각 액터는 메일박스(큐)를 가짐
- 비동기 메시지 전달
- 로컬 액터처럼 보이지만 **원격일 수도 있음**

**예시 프레임워크**:

- Akka (Scala/Java)
- Orleans (C#)
- Erlang OTP

**스키마 발전 고려사항**:

- 롤링 업그레이드 시 새/구 버전 노드 공존
- 메시지 포맷도 호환성 보장 필요
- 아브로, Protobuf 등 활용 권장
