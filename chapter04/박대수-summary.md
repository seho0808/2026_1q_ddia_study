# DDIA 4장 - 부호화와 발전 요약

## 1. 호환성 (Compatibility)

### 하위 호환성과 상위 호환성
- **하위 호환성 (Backward Compatibility)**: 새로운 코드는 이전 버전의 데이터를 읽을 수 있어야 함
- **상위 호환성 (Forward Compatibility)**: 이전 코드는 새로운 버전의 데이터를 읽을 수 있어야 함
- 호환성은 데이터베이스, 파일 형식, 네트워크 프로토콜에서 중요
- 롤링 업그레이드 시 시스템 중단 없이 버전 업그레이드가 가능

## 2. 데이터 부호화 형식 (Data Encoding Formats)

### 내장 부호화 vs 범용 부호화
- **내장 부호화**: 언어별 직렬화 (Java Serializable, Python pickle 등)
  - 장점: 사용이 쉽고 동일 언어에서 호환성 좋음
  - 단점: 다른 언어와의 호환성 부족, 보안 취약성, 버전 관리 어려움

- **범용 부호화**: JSON, XML, CSV 등
  - **JSON**: 텍스트 기반, 인간이 읽기 쉬움, 유연성 높음
  - **XML**: 상세한 구조 표현 가능, 스키마 지원, 장황함
  - **이진 변형**: MessagePack, BSON, BJSON 등 - JSON보다 효율적

## 3. 스키마 기반 부호화 (Schema-based Encoding)

### 스리프트 (Thrift)와 프로토콜 버퍼 (Protocol Buffers)
- **공통점**: 이진 형식, 스키마 정의 필요, 코드 생성 지원
- **스리프트**: Facebook 개발, 다양한 언어 지원, RPC 프레임워크 포함
- **프로토콜 버퍼**: Google 개발, 더 간결한 이진 형식, gRPC와 통합

### 필드 태그 (Field Tags)
- 각 필드에 고유 번호 할당 (필드 이름 대신)
- 스키마 변경 시 필드 추가/삭제가 유연
- 필드 태그로 이전 데이터의 필드를 식별

### 아브로 (Avro)
- **특징**: 스키마를 데이터와 별도 관리, 동적 타이핑 지원
- **장점**: 스키마 발전이 용이, JSON 기반 스키마 정의
- **사용**: Hadoop 생태계에서 널리 사용

## 4. 스키마 발전 (Schema Evolution)

### 쓰기 스키마 vs 읽기 스키마
- **쓰기 스키마**: 데이터를 기록할 때 사용되는 스키마
- **읽기 스키마**: 데이터를 읽을 때 사용되는 스키마
- 스키마 버전이 다를 수 있음 (롤링 업그레이드)

### 스키마 발전 규칙
- **안전한 변경**:
  - 필드 추가 (기본값 설정)
  - 선택 필드 → 필수 필드 (단, 기존 데이터에 값이 있어야 함)
- **위험한 변경**:
  - 필수 필드 삭제
  - 필드 타입 변경
- 각 포맷별로 다른 규칙 적용 (Protobuf vs Avro vs Thrift)

## 5. 데이터 플로 모드 (Data Flow Modes)

### 데이터베이스 (Database)
- 스키마 변경 시 마이그레이션 필요
- 하위 호환성으로 이전 데이터 읽기, 상위 호환성으로 새 데이터 쓰기

### 데이터 덤프 (Data Dump/Restore)
- 배치 처리, 스키마 변환 가능
- 오래된 덤프 파일을 새 스키마로 변환

### 실시간 데이터 플로우 (Real-time Data Streams)
- 메시지 브로커를 통한 데이터 전송
- 소비자가 생산자보다 최신 버전일 수 있음

## 6. API 디자인 원칙 (API Design Principles)

### 데이터가 코드보다 더 오래 산다
- 데이터는 애플리케이션보다 더 오래 유지됨
- API 디자인 시 미래 호환성 고려 필요
- 데이터 모델은 신중하게 설계해야 함

### REST vs RPC
- **REST**: HTTP를 사용한 리소스 기반 API
  - 장점: 표준화, 캐싱, 확장성
  - 단점: 여러 요청 필요할 수 있음

- **RPC**: 원격 프로시저 호출
  - 장점: 요청-응답이 간단
  - 단점: 로컬 호출처럼 보이지만 네트워크 오버헤드

## 7. 메시징 시스템 (Messaging Systems)

### 메시지 브로커 (Message Brokers)
- 메시지 큐를 통한 비동기 통신
- 생산자와 소비자의 decoupling
- 예시: RabbitMQ, Kafka, Amazon SQS

### 분산 엑터 프레임워크 (Distributed Actor Frameworks)
- 액터 모델: 각 액터가 독립적 상태와 메시지 처리
- 장점: 동시성, 장애 격리, 위치 투명성
- 예시: Erlang OTP, Akka, Orleans

