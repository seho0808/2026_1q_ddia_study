# MongoDB 읽기/쓰기 원리 요약

> 데이터 중심 애플리케이션 설계 (DDIA) 2장 기반 정리

---

## 1. MongoDB의 기본 전제

MongoDB는 관계형 데이터베이스(RDB) 와 달리,

- 데이터를 행(row) 이 아닌 문서(document) 단위로 다룬다.
- 데이터 모델링의 목적은 정규화가 아니라 접근 패턴 최적화다.

핵심 질문:

> "이 데이터는 언제, 어떻게, 함께 읽히는가?"

---

## 2. MongoDB를 선택해야 할 때

적합한 경우:

- 읽기 패턴이 명확하고 예측 가능할 때
- 데이터가 자연스럽게 문서 단위로 묶일 때
- 스키마가 자주 변경되거나 유동적일 때
- 수평 확장이 필수일 때
- 관계보다 집계가 중요할 때

부적합한 경우:

- 복잡한 JOIN이 빈번할 때
- 다대다 관계가 핵심일 때
- 강한 일관성이 필수일 때 (금융, 재고)
- 데이터 간 참조 무결성이 중요할 때

판단 기준:

> 데이터가 "함께 쓰이는 단위"로 저장 가능한가?

---

## 3. MongoDB의 저장 단위: Document

- MongoDB의 최소 원자 단위는 하나의 Document
- 하나의 Document 내부:
  - 필드
  - 중첩 객체 (sub-document)
  - 배열
- Document 내부 연산은 항상 원자적(Atomic)

→ 여러 테이블/행 간의 일관성을 DB가 보장하는 구조가 아님

---

## 4. 쓰기(Write) 원리

### 4.1 Insert

1. 클라이언트가 BSON 문서 전송
2. MongoDB가 Journal(WAL)에 기록
3. 메모리 캐시에 반영
4. 백그라운드에서 디스크 flush

특징:

- 단일 문서 insert가 빠름
- 스키마 검증 비용이 낮음
- 대량 append-write에 유리

---

### 4.2 Update

- Document 단위 원자성 보장
- 작은 변경은 부분 업데이트
- 구조가 크게 바뀌면 문서 재작성

의미:

- 같은 Document 안에서는 불일치가 발생하지 않음
- Document 간 불일치는 애플리케이션 책임

---

### 4.3 Transaction

- Multi-document 트랜잭션 지원
- Replica Set / Sharded Cluster에서도 가능
- 성능 비용 큼 → 핵심 경로에는 비권장

MongoDB의 기본 철학:

> "트랜잭션은 예외적 수단이지 기본 설계 수단이 아니다."

---

## 5. 읽기(Read) 원리

### 5.1 Find

- 인덱스 탐색 → Document 위치 조회 → Document 반환
- 인덱스 없으면 Collection Scan

---

### 5.2 저장소 지역성 (Storage Locality)

저장소 지역성이란:

> 함께 사용되는 데이터가 물리적으로도 가까이 저장되어 있는 정도

MongoDB에서:

- 하나의 Document는 연속된 BSON 블록
- 중첩 구조 덕분에 한 번의 디스크 읽기로 필요한 데이터 확보 가능

결과:

- Disk seek 감소
- Cache hit 증가
- Network hop 감소 (분산 환경에서 특히 중요)

---

## 6. 데이터 구조 설계: Embedding vs Referencing

### 6.1 Embedding (중첩)

사용 시점:

- 1:1 또는 1:Few 관계
- 부모와 함께 조회되는 데이터
- 자식 데이터가 단독으로 조회되지 않음
- 데이터가 자주 변경되지 않음

예시: 사용자 문서에 주소 중첩

### 6.2 Referencing (참조)

사용 시점:

- 1:Many 또는 Many:Many 관계
- 자식 데이터가 독립적으로 조회됨
- 데이터가 자주 변경됨
- 16MB 문서 크기 제한에 근접

예시: 주문 문서에 상품 ID만 저장

### 6.3 설계 원칙

- 읽기 패턴에 맞게 데이터를 배치
- 함께 조회되면 함께 저장
- 독립적으로 변경되면 분리

---

## 7. 효율적인 스키마 패턴

### 7.1 Subset Pattern

- 자주 쓰는 필드만 메인 문서에
- 나머지는 별도 컬렉션

### 7.2 Bucket Pattern

- 시계열 데이터를 시간 단위로 묶음
- 문서 수 감소, 인덱스 효율 증가

### 7.3 Computed Pattern

- 집계 결과를 미리 계산해 저장
- 읽기 성능 향상, 쓰기 시 갱신 필요

### 7.4 Extended Reference Pattern

- 참조 + 자주 쓰는 필드 일부 복사
- JOIN 없이 필요한 정보 확보

---

## 8. 피해야 할 안티패턴

### 8.1 무한 성장 배열

- 배열에 계속 push하면 문서 크기 폭증
- 16MB 제한 도달, 성능 저하
- 해결: Bucket Pattern 또는 별도 컬렉션

### 8.2 과도한 중첩

- 깊은 중첩은 쿼리/인덱스 복잡도 증가
- 부분 업데이트 어려움
- 해결: 2-3 depth 이내 유지

### 8.3 잦은 $lookup 의존

- JOIN 대용으로 $lookup 남용
- Random I/O, 메모리 사용량 증가
- 해결: 설계 시점에 Embedding 또는 Extended Reference

### 8.4 범용 스키마

- 모든 케이스를 하나의 스키마로
- 대부분의 필드가 null
- 해결: 용도별 컬렉션 분리

### 8.5 RDB 사고방식 그대로 적용

- 테이블 단위로 컬렉션 설계
- 정규화 우선
- MongoDB의 장점을 살리지 못함

---

## 9. Aggregation & $lookup (조인)

- MongoDB는 SQL-style JOIN을 기본 쿼리에서 지원하지 않음
- Aggregation Pipeline의 `$lookup`으로 조인 유사 기능 제공

특징:

- 내부적으로 반복적인 index lookup 수행
- Random I/O 증가
- 메모리 사용량 증가

결론:

> `$lookup`은 가능하지만 "권장 설계"는 아님

---

## 10. 불일치(Consistency) 문제를 다루는 방식

MongoDB는 자동으로 불일치를 해결하지 않는다

대신 다음 전략을 사용:

1. Immutable 데이터
   - 주문 당시 사용자 이름, 가격 스냅샷
2. 단일 Document에 최대한 중첩
3. 애플리케이션 레벨 동기화
4. Event / Change Stream 기반 비동기 보정
5. 필요 시 트랜잭션 (최후의 수단)

MongoDB식 질문:

> "어떤 불일치는 허용 가능한가?"

---

## 11. 대량 데이터 적재 관점

### MongoDB가 유리한 경우

- 로그, 이벤트, 클릭 스트림
- AI 학습용 raw 데이터

이유:

- Schema-less
- FK / 제약조건 없음
- Append-write 최적화
- 수평 확장(Sharding) 용이

### RDB가 유리한 경우

- 재고, 회계, 정산, 권한

이유:

- 강한 일관성
- 정교한 JOIN
- ACID 보장

---

## 12. Sharding과 읽기/쓰기 원리

- 데이터는 Shard Key 기준으로 분산

좋은 Shard Key:

- 카디널리티가 높음
- 쿼리에 자주 포함됨
- 단조 증가하지 않음

나쁜 Shard Key:

- 모든 샤드에 브로드캐스트
- 핫스팟 발생
- 네트워크 + I/O 비용 폭증

---

## 13. 핵심 요약

- MongoDB는 "관계를 잘 처리하려는 DB"가 아니다
- MongoDB는 "접근 패턴에 맞게 데이터를 배치하는 DB"다

설계 체크리스트:

1. 읽기 패턴을 먼저 정의했는가?
2. 함께 조회되는 데이터를 함께 저장했는가?
3. 무한 성장하는 배열이 없는가?
4. $lookup 없이 주요 쿼리가 가능한가?
5. 일관성 요구사항을 앱에서 처리할 수 있는가?

한 문장 요약:

> MongoDB는 조인과 일관성을 포기하는 대신 예측 가능한 성능과 저장소 지역성을 얻는다.

---

## 14. MongoDB vs RDB 사고방식 차이

| 관점      | MongoDB        | RDB            |
| --------- | -------------- | -------------- |
| 기본 단위 | Document       | Row            |
| 관계 처리 | 저장 시 해결   | 조회 시 해결   |
| 일관성    | 앱 책임        | DB 책임        |
| 확장      | 수평 확장 용이 | 수직 확장 중심 |
| 핵심 가치 | 지역성         | 정합성         |

---

끝.
