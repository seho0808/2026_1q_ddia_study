### 데이터 모델이 중요한 이유

데이터 모델은 단순히 저장 방식의 문제가 아니라, **문제를 어떻게 사고할지를 결정**한다. 대부분의 애플리케이션은 여러 데이터 모델을 계층적으로 쌓아서 만든다.

| 계층              | 역할                                         |
| ----------------- | -------------------------------------------- |
| 애플리케이션      | 현실을 객체/데이터 구조/API로 모델링         |
| 범용 데이터 모델  | JSON, XML, 관계형 테이블, 그래프 등으로 표현 |
| 데이터베이스 엔진 | 메모리/디스크/네트워크 상의 바이트로 표현    |
| 하드웨어          | 전류, 빛의 파동, 자기장으로 표현             |

각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다. 그리고 각 데이터 모델은 어떤 연산은 쉽고 빠르게, 어떤 연산은 어렵고 느리게 만든다는 가정을 내포한다.

------

### 관계형 모델

SQL의 기반이 되는 관계형 모델의 특징:

- 데이터는 **관계(테이블)**로 구성되고, 각 관계는 순서 없는 **튜플(로우)** 모음
- 비즈니스 데이터 처리(트랜잭션, 일괄 처리)에 근원
- 정규화된 구조로 데이터를 저장하고 질의하는 표준 도구로 자리잡음
- 오늘날 웹 서비스 대부분이 여전히 관계형 DB 기반

------

### 객체-관계형 불일치 (Impedance Mismatch)

OOP 언어로 개발하면서 SQL 데이터 모델을 사용할 때 발생하는 문제. 애플리케이션 객체와 DB 테이블 사이에 **거추장스러운 전환 계층**이 필요하다.

**전통적인 관계형 접근**: 직위, 학력, 연락처를 개별 테이블에 넣고 외래 키로 users 테이블 참조

**JSON 표현의 장점**:

- 다중 테이블 스키마보다 더 나은 **지역성(locality)** — 모든 관련 정보가 한 곳에 있어 질의 하나로 충분
- 일대다 관계가 트리 구조로 명시적으로 드러남
- 애플리케이션 코드와 저장 계층 간 임피던스 불일치 감소

------

### 문서 모델 vs 관계형 모델: 선택 기준

#### 언제 문서 모델이 유리한가

- 데이터가 **문서와 비슷한 구조**(일대다 관계 트리, 한 번에 전체를 적재)
- 문서와 비슷한 구조를 여러 테이블로 찢으면 다루기 힘든 스키마와 불필요한 복잡성 발생

#### 언제 관계형 모델이 유리한가

- **다대다 관계**가 빈번한 경우
- 비정규화로 조인 필요성을 줄일 수 있지만, 애플리케이션이 비정규화된 데이터의 일관성을 유지해야 함
- 애플리케이션에서 조인을 흉내내면 복잡도 이동 + 성능 저하

#### 문서 모델의 제한사항

- 문서 내 중첩 항목을 바로 참조할 수 없음 (깊은 중첩이 아니면 보통 문제 없음)
- 조인 지원이 미흡 — 애플리케이션에 따라 문제일 수도 아닐 수도

------

### 스키마 유연성: 쓰기 스키마 vs 읽기 스키마

문서 DB가 "스키마리스"라고 불리지만 이는 오해의 소지가 있다. 데이터를 읽는 코드는 구조에 대한 가정을 한다. 즉 **암묵적 스키마**가 존재하되, DB가 강제하지 않을 뿐이다.

| 구분         | 쓰기 스키마 (Schema-on-Write)         | 읽기 스키마 (Schema-on-Read)                        |
| ------------ | ------------------------------------- | --------------------------------------------------- |
| 스키마       | 명시적, DB가 강제                     | 암묵적, 읽을 때 해석                                |
| 유사 개념    | 정적(컴파일 타임) 타입 확인           | 동적(런타임) 타입 확인                              |
| 타입 변경 시 | `ALTER TABLE` + `UPDATE` 마이그레이션 | 새 필드로 문서 작성 시작 + 예전 문서 처리 코드 추가 |

**읽기 스키마가 유리한 상황**:

- 컬렉션 내 항목들이 모두 동일한 구조가 아닐 때 (여러 다른 유형의 오브젝트)
- 외부 시스템에 의해 데이터 구조가 결정되어 제어할 수 없을 때

**쓰기 스키마가 유리한 상황**:

- 모든 레코드가 동일한 구조로 예상 가능할 때
- 스키마가 문서화와 구조 강제를 위한 유용한 메커니즘으로 작동

------

### 데이터 지역성

문서는 보통 단일 연속 문자열(JSON, XML 또는 이진 변형)로 저장된다. **전체 문서에 자주 접근**하는 패턴이라면 저장소 지역성으로 성능 이점을 얻는다.

**주의사항**:

- 문서의 작은 부분만 접근해도 전체 문서를 적재해야 하므로 큰 문서에선 낭비
- 문서 갱신 시 보통 전체를 재작성해야 함 (부호화된 크기를 바꾸지 않는 수정은 예외)
- 따라서 **문서를 작게 유지하고, 크기가 증가하는 쓰기를 피하라**는 권장사항이 있음

------

### 질의 언어: 선언형 vs 명령형

| 구분        | 명령형                          | 선언형 (SQL)                               |
| ----------- | ------------------------------- | ------------------------------------------ |
| 방식        | 특정 순서로 특정 연산 수행 지시 | 결과가 충족해야 할 조건과 변환 방법만 지정 |
| 실행 계획   | 개발자가 결정                   | 쿼리 옵티마이저가 자동 결정                |
| 성능 최적화 | 코드 변경 필요                  | 질의 변경 없이 DB 엔진 개선 가능           |
| 병렬 처리   | 순서 의존성으로 어려움          | 결과 패턴만 지정하므로 용이                |

**선언형의 핵심 이점**: 기능적으로 더 제한적이라는 사실이 오히려 DB에게 자동 최적화 여지를 더 많이 준다. SQL은 특정 순서를 보장하지 않으므로 순서가 바뀌어도 상관없지만, 명령형 코드는 순서 의존성을 DB가 확신할 수 없다.

------

### MapReduce

많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델. MongoDB 등 일부 NoSQL이 제한된 형태로 지원한다.

**위치**: 선언형도 완전한 명령형도 아닌 중간 지점. 질의 로직을 `map`/`reduce` 함수로 표현하고, 처리 프레임워크가 반복 호출한다.

**PostgreSQL 예시**:

```sql
SELECT date_trunc('month', observation_timestamp) AS observation_month,
       sum(num_animals) AS total_animals
FROM observations
WHERE family = 'Sharks'
GROUP BY observation_month;
```

**MongoDB MapReduce 예시**:

```javascript
db.observations.mapReduce(
  function map() {
    var year = this.observationTimestamp.getFullYear();
    var month = this.observationTimestamp.getMonth() + 1;
    emit(year + "-" + month, this.numAnimals);
  },
  function reduce(key, values) {
    return Array.sum(values);
  },
  { query: { family: "Sharks" }, out: "monthlySharkReport" }
);
```

**제약사항**: `map`/`reduce` 함수는 **순수 함수**여야 한다. 입력 데이터만 사용하고, 추가 DB 질의 불가, 부수 효과 없어야 함. 이 제약 덕분에 임의 순서로 어디서나 실행 가능하고, 장애 시 재실행 가능하다.

**MapReduce의 한계**:

- 두 개의 JS 함수를 신중하게 작성해야 해서 단일 질의보다 어려움
- 선언형 언어는 쿼리 옵티마이저 활용 기회를 주지만 MapReduce는 그렇지 않음

**MongoDB의 대안 — Aggregation Pipeline**:

```javascript
db.observations.aggregate([
  { $match: { family: "Sharks" } },
  { $group: {
    _id: {
      year: { $year: "$observationTimestamp" },
      month: { $month: "$observationTimestamp" }
    },
    totalAnimals: { $sum: "$numAnimals" }
  }}
]);
```

SQL의 부분 집합과 유사한 표현력을 JSON 기반 구문으로 제공한다.

| 모델          | 대상 사용 사례                                      | 스키마               |
| ------------- | --------------------------------------------------- | -------------------- |
| **문서 DB**   | 데이터가 문서 자체에 포함, 문서 간 관계가 거의 없음 | 암묵적 (읽기 스키마) |
| **그래프 DB** | 모든 것이 잠재적으로 관련 있음                      | 암묵적               |
| **관계형 DB** | 다대일/다대다 관계가 빈번, 정규화 중요              | 명시적 (쓰기 스키마) |

스키마가 명시적이든 암시적이든, 애플리케이션은 결국 데이터가 특정 구조를 갖는다고 가정한다. 차이는 그 가정을 어디서 강제하느냐의 문제다.

## 그래프형 데이터 모델

**다대다 관계가 매우 일반적**이라면 그래프로 데이터를 모델링하는 것이 자연스럽다. 그래프는 **정점(vertex)**과 **간선(edge)**으로 구성된다.

### 그래프 데이터베이스의 종류

| 모델               | 대표 제품                                  |
| ------------------ | ------------------------------------------ |
| 속성 그래프 모델   | Neo4j, Titan, InfiniteGraph                |
| 트리플 저장소 모델 | Datomic, AllegroGraph                      |
| 선언형 질의 언어   | 사이퍼(Cypher), 스파클(SPARQL), 데이터로그 |

------

### 속성 그래프 모델

**정점의 구성 요소**:

- 고유한 식별자
- 유출(outgoing) 간선 집합
- 유입(incoming) 간선 집합
- 속성 컬렉션 (키-값 쌍)

**간선의 구성 요소**:

- 고유한 식별자
- 꼬리 정점 (간선이 시작하는 정점)
- 머리 정점 (간선이 끝나는 정점)
- 관계 유형을 설명하는 레이블
- 속성 컬렉션 (키-값 쌍)

------

## Event Sourcing과 CQRS

지금까지의 데이터 모델은 데이터를 작성한 형태 그대로 질의한다. 하지만 복잡한 애플리케이션에서는 모든 다양한 질의와 표현 방식을 만족시키는 단일 데이터 표현을 찾기 어렵다.

-> 데이터를 한 가지 형태로 작성하고, 거기서 다양한 읽기에 최적화된 여러 표현을 파생(derive)한다.

쓰기에만 최적화한다면 가장 간단하고 빠르고 표현력 있는 방법은 **이벤트 로그**:

- 데이터를 작성할 때마다 타임스탬프를 포함한 self-contained 문자열(주로 JSON)로 인코딩
- 이벤트 시퀀스에 append
- 이벤트는 **immutable** — 변경/삭제 없이 오직 append만

------

### 컨퍼런스 관리 시스템 예시

컨퍼런스는 복잡한 비즈니스 도메인이다:

- 개별 참석자 등록 및 카드 결제
- 회사의 대량 좌석 주문 및 청구서 결제 후 개별 할당
- 연사, 후원사, 자원봉사자용 좌석 예약
- 예약 취소, 수용 인원 변경 등

이 상황에서 단순히 "사용 가능한 좌석 수"를 계산하는 것조차 어려운 질의가 된다.

**Event Sourcing 접근**:

1. 모든 상태 변경(등록 오픈, 참석자 등록/취소 등)을 먼저 이벤트로 저장
2. 이벤트가 로그에 append될 때마다 여러 **materialized view**(projection, read model)를 업데이트

**Materialized View 예시**:

- 각 예약 상태와 관련 정보를 수집하는 뷰
- 컨퍼런스 주최자 대시보드용 차트 계산 뷰
- 참석자 배지 프린터용 파일 생성 뷰

------

### 용어 정의

| 용어                                                | 설명                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| **Event Sourcing**                                  | 이벤트를 source of truth로 사용하고 모든 상태 변경을 이벤트로 표현 |
| **CQRS** (Command Query Responsibility Segregation) | 쓰기 최적화 표현과 별도로 읽기 최적화 표현을 유지하고 파생   |
| **Command**                                         | 사용자 요청. validation 필요                                 |
| **Event**                                           | command가 실행되고 valid하다고 판단된 후의 fact. 로그에 추가됨 |

**이벤트 네이밍 규칙**: 과거 시제 사용 권장 (예: "좌석이 예약되었다"). 이벤트는 과거에 일어난 사실의 기록이기 때문. 사용자가 나중에 취소해도 "이전에 예약을 보유했다"는 사실은 여전히 참이고, 취소는 별도의 이벤트로 추가된다.

------

### Star Schema Fact Table과의 비교

| 관점   | Star Schema Fact Table        | Event Sourcing                           |
| ------ | ----------------------------- | ---------------------------------------- |
| 공통점 | 과거에 발생한 이벤트의 컬렉션 | 과거에 발생한 이벤트의 컬렉션            |
| 스키마 | 모든 로우가 동일한 컬럼 집합  | 각기 다른 속성을 가진 다양한 이벤트 타입 |
| 순서   | unordered collection          | 순서가 중요 (예약 → 취소 순서)           |

------

### Event Sourcing과 CQRS의 장점

**의도 전달력 향상**:

- "예약이 취소되었다"라는 이벤트가
- "`bookings` 테이블의 row 4001의 `active` 컬럼을 `false`로 설정하고, 관련 3개 row를 `seat_assignments`에서 삭제하고, 환불 row를 `payments`에 삽입했다"보다 이해하기 쉬움

**재현 가능성**:

- materialized view는 이벤트 로그에서 재현 가능한 방식으로 파생
- 언제든 view를 삭제하고 동일한 코드로 동일한 순서로 동일한 이벤트를 처리해 재계산 가능
- view maintenance 코드에 버그가 있으면 view 삭제 후 새 코드로 재계산
- 디버깅도 용이 — 코드를 원하는 만큼 재실행하며 동작 검사 가능

**유연한 materialized view**:

- 특정 질의에 최적화된 여러 view 보유 가능
- 이벤트와 동일한 DB든 다른 DB든 저장 가능
- 어떤 데이터 모델이든 사용 가능, 빠른 읽기를 위해 denormalize 가능
- 서비스 재시작 시 재계산해도 괜찮다면 메모리에만 유지하고 persist 안 해도 됨

**시스템 진화 용이**:

- 기존 이벤트 로그에서 새 materialized view를 쉽게 빌드
- 새로운 이벤트 타입이나 기존 이벤트에 새 속성 추가로 새 기능 지원 (기존 이벤트는 수정 없이 유지)
- 기존 이벤트에서 새로운 동작 연결 가능 (예: 취소 시 대기자 명단 다음 사람에게 좌석 제공)

**되돌리기 용이**:

- 실수로 작성된 이벤트는 후속 deletion 이벤트로 되돌림
- downstream view가 자동으로 반영
- 직접 update/delete하는 DB에서는 commit된 트랜잭션 되돌리기 어려움
- irreversible action 수를 줄여 변경하기 쉬운 시스템

**감사 로그(Audit Log)**:

- 이벤트 로그가 시스템에서 발생한 모든 것의 감사 로그 역할
- 규제 산업에서 가치 있음

**높은 쓰기 처리량**:

- sequential access 패턴으로 DB보다 높은 write throughput 처리 가능
- 일시적인 이벤트 burst를 로그가 흡수
- downstream 시스템이 overwhelm되지 않고 자신의 속도로 따라잡기 가능

------

### Event Sourcing과 CQRS의 단점

**외부 정보 의존성 문제**:

- 예: 이벤트에 한 통화 가격이 있고 view에서 다른 통화로 변환 필요
- 이벤트 처리 시 외부 소스에서 환율을 가져오면 문제 — 다른 날짜에 view 재계산 시 다른 결과
- **해결책**: 환율을 이벤트 자체에 포함하거나, 타임스탬프 기준 historical 환율을 query하되 동일 타임스탬프에 항상 동일 결과 보장 필요
- 이벤트 처리 로직을 **deterministic**하게 유지해야 함

**개인정보 삭제 문제**:

- 이벤트가 불변이어야 하는데 사용자가 GDPR 등에 따라 데이터 삭제 요청 가능
- 사용자별 이벤트 로그면 해당 사용자 전체 로그 삭제로 해결
- 여러 사용자 관련 이벤트가 섞여 있으면 불가
- **해결책**: 개인 데이터를 이벤트 외부에 저장하거나, 나중에 삭제 가능한 key로 암호화 (crypto-shredding)
- 단, derived state 재계산이 어려워짐

**Side-effect 재처리 주의**:

- 외부에 visible한 side-effect가 있는 경우 주의 필요
- 예: materialized view rebuild할 때마다 confirmation email 재발송 방지 필요

------

### Event Sourcing 지원 시스템

| 유형          | 예시                                                         |
| ------------- | ------------------------------------------------------------ |
| 전용 시스템   | EventStoreDB, MartenDB(PostgreSQL 기반), Axon Framework      |
| 메시지 브로커 | Apache Kafka로 이벤트 로그 저장, stream processor로 materialized view 유지 |
| 범용 DB       | 어떤 DB 위에서든 구현 가능                                   |

**핵심 요구사항**: 이벤트 저장 시스템이 모든 materialized view가 로그에 나타나는 것과 **정확히 동일한 순서**로 이벤트를 처리하도록 보장해야 함. 분산 시스템에서는 항상 달성하기 쉽지 않음.

------

## DataFrame, Matrix, Array

### DataFrame이란

R, Python Pandas, Apache Spark, ArcticDB, Dask 등에서 지원하는 데이터 모델. ML 모델 훈련용 데이터 준비, 데이터 탐색, 통계 분석, 시각화 등에 널리 사용된다.

언뜻 보면 관계형 DB 테이블이나 스프레드시트와 비슷하다. Bulk operation을 지원:

- 모든 row에 function 적용
- 조건에 따른 row filtering
- 일부 컬럼으로 grouping하고 다른 컬럼 aggregating
- 특정 key 기반으로 다른 DataFrame과 joining (관계형의 join을 DataFrame에서는 보통 **merge**라고 부름)

------

### DataFrame vs SQL

| 관점       | SQL            | DataFrame                                            |
| ---------- | -------------- | ---------------------------------------------------- |
| 질의 방식  | 선언형 query   | 구조와 내용을 수정하는 일련의 command                |
| 워크플로우 | 최종 결과 명세 | 점진적으로 데이터를 "wrangle"해서 원하는 형태로 변환 |
| 사용 환경  | 공유 DB        | 주로 data scientist의 private copy, 종종 로컬 머신   |

DataFrame API는 관계형 DB가 제공하는 것을 훨씬 넘어서는 다양한 operation을 제공하며, 전형적인 관계형 모델링과 매우 다른 방식으로 사용된다.

------

### DataFrame의 일반적인 사용: Relational → Matrix 변환

많은 ML 알고리즘이 입력으로 matrix나 다차원 배열을 기대한다.

**예시 — 영화 평점 데이터**:

| 변환 전 (Relational)                    | 변환 후 (Matrix)                         |
| --------------------------------------- | ---------------------------------------- |
| user_id, movie_id, rating 형태의 테이블 | 각 컬럼이 영화, 각 row가 사용자인 matrix |

- 스프레드시트의 pivot table과 유사
- matrix는 sparse할 수 있음 (많은 사용자-영화 조합에 데이터 없음)
- 수천 개의 컬럼을 가질 수 있어 관계형 DB에 잘 안 맞지만, DataFrame과 sparse array 라이브러리(NumPy 등)는 쉽게 처리

------

### Non-numerical 데이터의 숫자 변환

Matrix는 숫자만 포함할 수 있으므로 변환 기술이 필요하다:

**날짜**: 적절한 범위 내의 floating-point 숫자로 scale

**카테고리 데이터 (One-hot Encoding)**:

- 작고 고정된 값 집합 중 하나를 취하는 컬럼 (예: 영화 장르)
- 가능한 각 값에 대해 컬럼 생성 ("comedy", "drama", "horror" 등)
- 해당 장르에 1, 나머지에 0
- 여러 장르에 속하는 경우로도 쉽게 일반화

데이터가 숫자 matrix 형태가 되면 많은 ML 알고리즘의 기초를 형성하는 **선형대수 연산**에 적용할 수 있다.

------

### Array Database

TileDB 같이 대규모 다차원 숫자 배열 저장에 특화된 DB.

| 용도          | 예시                                       |
| ------------- | ------------------------------------------ |
| 지리공간 측정 | 규칙적으로 간격을 둔 grid의 raster data    |
| 의료 영상     | CT, MRI 등                                 |
| 천문학        | 망원경 관측 데이터                         |
| 금융          | 시간에 따른 자산 가격과 거래 (time series) |

DataFrame의 인기로 인해 Spark, Flink 같은 batch processing framework에도 추가되었다.
