`poc-salting` 구현이 완료되었고 시뮬레이션 결과가 매우 흥미롭습니다! 📊

### 🎯 실험 결과 분석 (10,000 요청, 50%가 핫스팟)

**Scenario 1: No Salting (일반적인 경우)**

- **문제점:** `Node-E`가 **5,955개**의 요청을 혼자 처리했습니다. (나머지는 약 1,000개씩)
- **Load Factor:** 평균 대비 **2.98배**의 부하를 받고 있습니다. 이게 실제 DB였다면 `Node-E`는 이미 뻗었을 겁니다.
- 원인: `Justin-Bieber`라는 핫 키가 우연히 `Node-E`에 할당되었기 때문입니다.

**Scenario 2: With Salting (Salting 적용)**

- **해결:** `Node-E`의 부하가 **973개**로 확 줄었고, 나머지 노드들도 2,000개 수준으로 **평준화**되었습니다.
- **Load Factor:** 최대 부하가 평균의 **1.24배** 수준으로 매우 안정적입니다.
- 원인: `Justin-Bieber` 키 뒤에 난수(0~9)를 붙여서 `Justin-Bieber#3`, `Justin-Bieber#7` 등으로 쪼개버렸기 때문입니다.

**Scenario 3: Trade-off (읽기 비용)**

- **비용:** 일반 키는 노드 1개만 조회하면 되지만, 핫 키(`Justin-Bieber`)를 읽으려면 **4개의 노드**를 전부 뒤져봐야 합니다. (흩어져 있으니까요)
- **결론:** 쓰기 부하를 분산하는 대신, 읽기 비용이 증가하는 **Trade-off**를 명확히 확인할 수 있습니다.

### 📝 코드 설명

- **`src/LoadBalancer.ts`**:
  - `markAsHotKey`: 어떤 키가 핫스팟인지 등록합니다.
  - `writeWithSalting`: 핫 키면 뒤에 `#random`을 붙여서 저장합니다.
  - `readWithSalting`: 핫 키면 가능한 모든 접미사(`#0` ~ `#9`)를 붙여서 조회할 노드 목록을 만듭니다. (Scatter-Gather)

이 PoC를 통해 "왜 Salting이 쓰기 부하 분산에 강력한지", 그리고 "왜 읽기 비용이 비싸지는지"를 직관적으로 이해할 수 있습니다.

혹시 여기서 더 나아가 **"읽기 비용을 줄이기 위한 캐싱 전략"** 같은 걸 추가로 실험해보고 싶으신가요?
