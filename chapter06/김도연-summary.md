# 06. 파티셔닝

> 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 **파티션**으로 쪼갤 필요가 있다. 이 작업을 **샤딩**이라고도 한다.
> 

# 파티셔닝과 복제

각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.

# 키-값 데이터 파티셔닝

대량의 데이터를 파티셔닝한다고 생각해보자. 어떤 레코드를 어느 노드에 저장할지 어떻게 결정해야 할까?

파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.

파티셔닝이 고르게 이뤄지지 않으면 불균형하게 부하가 높은 파티션이 생길 수 있는데 이를 핫스팟이라고 한다.

## 키 범위 기준 파티셔닝

파티셔닝하는 방법 중 하나는 종이 백과사전처럼 각 파티션에 연속된 범위의 키를 할당하는 것이다.

각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다. 이렇게 하면 범위 스캔이 쉬워지는 이점이 있고, 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어오는 데 사용할 수 있다.

키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다.

## 키의 해시값 기준 파티셔닝

쏠림과 핫스팟의 위험 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는 데 해시 함수를 사용한다.

파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다.

- MD5, Fowler-Noll-Vo

이 기법은 키를 파티션 사이에 균일하게 분산시키는 데 좋다. 파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다(이런 기법을 일관성 해싱이라고 부르기도 한다).

하지만 파티셔닝에 키의 해시값을 사용해서 파티셔닝하면 범위 질의의 효율성이 떨어진다.

카산드라는 두 가지 파티셔닝 전략 사이에서 타협한다.

카산드라에서 테이블을 선언할 때 여러 칼럼을 포함하는 복합 기본키를 지정할 수 있다. 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고 남은 칼럼은 카산드라의 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용한다. 첫번째 칼럼에 고정된 값을 지정하면 키의 다른 칼럼에 대해서는 범위 스캔을 효율적으로 실행할 수 있다.

## 쏠린 작업부하와 핫스팟 완화

키를 해시값 기준으로 파티셔닝하면 핫스팟을 줄이는 데 도움이 된다. 하지만 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.

요청이 매우 많이 쏠리는 키를 발견했을 때 간단한 해결책은 각 키의 시작이나 끝에 임의의 숫자를 붙이는 것이다.

그러나 다른 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요해진다. 이 기법은 요청이 몰리는 소수의 키에만 적용하는 것이 타당하다.

# 파티셔닝과 보조 색인

보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다.

보조 색인이 있는 데이터베이스를 파티셔닝하는 데 널리 쓰이는 두 가지 방법이 있다. 문서 기반 파티셔닝과 용어 기반 파티셔닝이다.

## 문서 기준 보조 색인 파티셔닝(지역 색인)

사용자들이 차를 검색할 때 색상과 제조사로 필터링할 수 있게 하려면 color와 make에 보조 색인을 만들어야 한다. 색인을 선언했다면 데이터베이스가 자동으로 색인 생성을 할 수 있다. 예를 들어 빨간색 자동차가 데이터베이스에 추가되면 데이터베이스 파티션은 자동으로 그것을 color:red 색인 항목에 해당하는 문서 ID 목록에 추가한다.

이런 색인 방법을 사용하면 각 파티션이 완전히 독립적으로 동작한다.

→ **지역 색인**

빨간색 자동차를 찾고 싶다면 모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.

파티셔닝된 데이터베이스에 이런 식으로 질의를 보내는 방법을 scatter/gather 라고도 하는데 보조 색인을 써서 읽는 질의는 큰 비용이 들 수 있다.

## 용어 기준 보조 색인 파티셔닝(전역 색인)

각 파티션이 자신만의 보조 색인을 갖게 하는 대신, 모든 파티션의 데이터를 담당하는 전역 색인을 만들 수도 있다. 그러나 한 노드에만 색인을 저장할 수는 없다. 해당 노드가 병목이 되어 파티셔닝의 목적을 해치기 때문이다.

전역 색인이 갖는 이점은 읽기가 효율적이라는 것이다. 클라이언트는 모든 파티션에 스캐터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다. 그렇지만 전역 색인은 쓰기가 느리고 복잡하다는 단점이 있다.

# 파티션 재균형화

- 균등하게 분배되어야함
- 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야함
- 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안됨

## 재균형화 전략

파티션을 노드에 할당하는 방법

### 쓰면 안되는 방법: 해시값에 모드 N 연산을 실행

mod 연산을 사용하게 되면 데이터를 필요 이상으로 많이 이동시키게 된다.

### 파티션 개수 고정

파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당한다.

파티션 개수는 바뀌지 않고 파티션에 할당된 키도 변경되지 않는다. 유일한 변화는 노드에 어떤 파티션이 할당되는가 뿐이다. 파티션 할당 변경은 즉시 반영되지 않고 네트워크를 통해 대량의 데이터를 전송해야 하므로 시간이 좀 걸린다. 따라서 데이터 전송이 진행 중인 동안에 읽기나 쓰기가 실행되면 기존에 할당된 파티션을 사용한다.

### 동적 파티셔닝

키 범위 파티셔닝을 사용하는 데이터베이스에서는 파티션을 동적으로 만든다. 파티션 크기가 설정된 값을 넘어서면 파티션을 두 개로 쪼개 각각에 원래 파티션의 절반 정도 데이터가 포함되게 한다. 반대로 데이터가 많이 삭제되어 파티션 크기가 임곗값 아래로 떨어지면 인접한 파티션과 합쳐질 수 있다.

### 노드 비례 파티셔닝

카산드라와 케타마에서 사용되는 세 번째 방법은 파티션 개수가 노드 대수에 비례하게 하는 것이다.

## 운영: 자동 재균형화와 수동 재균형화

재균형화는 요청 경로를 재설정해야 하고 대량의 데이터를 노드 사이에 이동해야 하므로 비용이 큰 연산이다. 주의 깊게 처리하지 않으면 네트워크나 노드에 과부하가 걸릴 수 있고 재균형화가 진행 중인 동안에는 실행되는 다른 요청의 성능이 저하될 수 있다.

재균형화 과정에 사람이 개입하는게 좋을 수도 있다. 완전 자동 처리보다는 느릴 수 있지만 운영상 예상치 못한 일을 방지하는 데 도움이 될 수 있다.

# 요청 라우팅

클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?

- 클라이언트, 라우팅 계층, 아무 노드

→ 라우팅 결정을 내리는 구성요소가 노드에 할당된 파티션의 변경 사항을 어떻게 아느냐가 문제다.

- ZooKeeper 같은 별도의 코디네이터 서비스 사용
- 가십 프로토콜
- 목시 라우팅 계층

## 병렬 질의 실행

분석용으로 자주 사용되는 대규모 병렬 처리(MPP) 관계형 데이터베이스 제품은 훨씬 더 복잡한 종류의 질의를 지원한다.

MPP 질의 최적화기는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.

# 정리

파티셔닝의 목적은 핫스팟(불균형적으로 높은 부하를 받는 노드)이 생기지 않게 하면서 데이터와 질의 부하를 여러 장비에 균일하게 분배하는 것이다. 그렇게 하려면 데이터에 적합한 파티셔닝 방식을 선택해야 하고 클러스터에 노드가 추가되거나 클러스터에서 노드가 제거될 때 파티션 재균형화를 실행해야 한다.
