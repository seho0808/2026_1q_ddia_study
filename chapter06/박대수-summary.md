## 파티셔닝과 복제의 차이
- **복제**: 동일한 데이터를 여러 노드에 복사해 두는 것. 가용성과 내고장성을 높이고, 읽기 처리량을 확장하는 데 주로 사용된다. 데이터 사본이 여러 개이므로 한 노드 장애 시에도 다른 복제본으로 서비스가 계속 가능하다.
- **파티셔닝(샤딩)**: 전체 데이터를 키 범위나 해시 기준으로 나누어 서로 다른 노드에 분배하는 것. 각 노드는 전체 데이터의 일부만 저장하고 처리하므로, 데이터 양이 커질수록 수평적으로 확장할 수 있다. 다만, 노드 장애 시 해당 파티션 범위의 데이터만 영향을 받는다.
- **조합**: 실제 시스템에서는 파티셔닝과 복제를 함께 사용한다. 각 파티션을 여러 노드에 복제해 두면, 규모 확장(파티셔닝)과 내고장성·읽기 성능 향상(복제)을 동시에 달성할 수 있다.

## 키-값 데이터 파티셔닝
- **범위 파티셔닝**: 키의 정렬 순서를 유지한 채 특정 범위(예: `user_0000`~`user_0999`) 단위로 파티션을 나누는 방식. 범위 스캔과 정렬 쿼리에 유리하지만, 특정 키 구간으로 트래픽이 몰리면 핫스팟이 생길 수 있다.
- **해시 파티셔닝**: 키에 해시 함수를 적용해 파티션을 배정하는 방식. 키가 고르게 분산되어 부하 균형에 유리하지만, 키 순서가 깨지므로 범위 조회가 비효율적일 수 있다.
- **조합·튜닝 포인트**: 실제 서비스에서는 접두사/접미사 설계, 가상 노드(consistent hashing), 비즈니스 도메인별 파티션 키 선택 등을 통해 핫스팟을 줄이고, 데이터 접근 패턴에 맞게 파티셔닝 전략을 조합한다.

## 파티셔닝과 보조 색인
- **문제**: 테이블을 파티셔닝하면 기본 키 기준으로는 어느 파티션에 데이터가 있는지 알 수 있지만, 보조 색인(secondary index) 기준으로는 어느 파티션을 조회해야 할지 애매해진다.
- **로컬 보조 색인**: 각 파티션 안에 해당 파티션 데이터에 대한 색인을 따로 둔다. 쓰기·파티션 이동에 유리하지만, 보조 색인으로 검색 시 여러 파티션을 동시에 조회해야 할 수 있다.
- **글로벌 보조 색인**: 전체 파티션을 통합해서 하나의 색인 구조로 관리한다. 특정 보조 키로 빠르게 조회할 수 있지만, 쓰기 시 메인 데이터 파티션과 글로벌 색인을 함께 갱신해야 하므로 복잡성과 쓰기 비용이 증가한다.
- **트레이드오프**: 읽기 패턴(보조 키 조회가 얼마나 자주/중요한지)과 쓰기 부하, 일관성 요구사항을 고려해 로컬/글로벌 색인을 혼합하거나, 일부 쿼리를 허용 가능한 수준에서 비효율(멀티 파티션 스캔)로 남겨두는 선택을 한다.

## 파티션 재균형화
- **필요성**: 데이터/트래픽이 시간이 지나며 불균형해지면 일부 파티션과 노드만 과부하가 걸리므로, 파티션을 다시 나누거나 재배치해서 부하를 나눠 가져야 한다.
- **전략 1 – 범위 파티셔닝에서의 분할/병합**: 특정 범위 파티션의 데이터가 커지면 범위를 둘로 쪼개거나, 너무 작은 파티션은 병합한다. 메타데이터에서 범위→파티션 매핑을 업데이트하면서 점진적으로 데이터를 옮긴다.
- **전략 2 – 해시 파티셔닝에서의 컨시스턴트 해싱**: 해시 공간을 여러 ‘가상 노드’로 나눈 뒤 실제 노드에 할당한다. 노드를 추가/삭제할 때 일부 가상 노드만 재배치하면 되므로, 이동해야 할 데이터 양이 줄어든다.
- **온라인 재균형화**: 실제 시스템에서는 다운타임 없이 데이터 복사와 트래픽 전환을 단계적으로 수행해야 한다. 복제본을 먼저 동기화한 뒤, 읽기/쓰기 라우팅을 새 파티션으로 점진적으로 전환하는 전략을 사용한다.

## 요청 라우팅
- **메타데이터 기반 라우팅**: 클라이언트나 프론트 도입부(게이트웨이, 라우터)가 “어떤 키가 어느 파티션/노드에 있는지”를 나타내는 메타데이터를 유지하고, 이를 기반으로 직접 올바른 노드로 요청을 보낸다.
- **중앙 라우터(코디네이터) 노드**: 클라이언트는 특정 코디네이터에만 요청을 보내고, 코디네이터가 실제 데이터 노드를 찾아서 요청을 전달한다. 클라이언트 구현은 단순하지만, 코디네이터가 병목/단일 장애점이 되지 않도록 복제와 수평 확장이 필요하다.
- **분산 해시/컨시스턴트 해싱 사용**: 클라이언트나 코디네이터가 동일한 해시 함수와 파티션 맵을 공유하면, 중앙 카탈로그 없이도 어떤 키가 어느 노드에 있을지 계산할 수 있다.
- **메타데이터 갱신과 캐싱**: 파티션 재균형화나 노드 추가/장애 등으로 파티션 맵이 바뀔 수 있으므로, 메타데이터를 캐싱하되 버전 관리나 주기적 갱신, 리다이렉트(“정답 노드를 알려주는 응답”) 메커니즘을 함께 사용해 점진적으로 최신 상태로 맞춘다.

