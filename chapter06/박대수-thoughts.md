## 해시값(hash value)이란 무엇인가
- **해시 함수(hash function)**: 임의 길이의 입력(키)을 고정 길이의 숫자/비트열로 바꿔 주는 함수. 예를 들어 사용자 ID 문자열을 64비트 정수로 변환하는 것.
- **해시값(hash value)**: 해시 함수를 통과한 결과 값. 보통 아주 큰 정수(예: 0 이상 \(2^{64}-1\) 이하)로, 키를 “균일하게” 숫자 공간에 흩뿌리는 것이 목표다.
- **특징**
  - 입력이 조금만 달라도 출력이 크게 달라져야 한다(눈사태 효과).
  - 키들이 전체 해시값 공간에 골고루 분포해야 파티션/버킷 간 부하가 균형 잡힌다.
  - 같은 입력에는 항상 같은 해시값이 나와야 한다(결정적이어야 함).

## 모드 N 연산(mod N)과 그 의미
- **정의**: 어떤 정수 \(h\)에 대해 \(h \bmod N\)은 \(0\) 이상 \(N-1\) 이하의 나머지를 돌려준다. 예) \(17 \bmod 4 = 1\).
- **파티셔닝/샤딩에서의 사용**:
  - 해시 기반 파티셔닝에서 보통 `partition = hash(key) % N` 같은 식으로 “어느 파티션에 갈지”를 정한다.
  - 여기서 **N**은 파티션 개수 또는 버킷 개수.
- **직관**:
  - 거대한 해시값 공간(예: 0 ~ \(2^{64}-1\))을 단순히 N개의 구간으로 접어서 붙이는 느낌.
  - 각 나머지 값(0~N-1)이 하나의 파티션 번호 역할을 한다.

## 왜 해시값에 단순히 모드 N 연산을 쓰면 문제가 되는가

### 1. 노드/파티션 개수가 바뀔 때 재배치 비용이 너무 크다
- **문제 상황**:
  - 초기에는 파티션이 4개여서 `hash(key) % 4`를 사용했다고 하자.
  - 시스템이 커져서 파티션을 5개로 늘리면, 공식이 `hash(key) % 5`로 바뀐다.
- **결과**:
  - 거의 **모든 키의 파티션 번호가 달라진다**.
  - 즉, 전체 데이터 대부분을 **새 파티션으로 재배치(리밸런싱)** 해야 한다.
  - 대규모 분산 시스템에서는 이 데이터 이동 비용(네트워크, 디스크 I/O, 캐시 붕괴)이 매우 크고 위험하다.
- **요지**: `hash(key) % N` 방식은 **N이 바뀌면 전체 키의 파티션 매핑이 거의 완전히 바뀌는** 구조라, 확장/축소가 자주 필요한 시스템에는 부적합하다.

### 2. N 선택에 따라 분포가 나빠질 수 있다
- **이론적으로** 좋은 해시 함수라면 `h % N`도 어느 정도 균일해야 하지만, 현실의 키 분포/해시 선택에 따라 다음 문제가 생길 수 있다.
  - N이 2의 거듭제곱일 때, 해시값의 하위 비트들이 충분히 랜덤하지 않으면 **특정 파티션에 쏠림(핫스팟)** 이 생긴다.
  - 특정 패턴의 키(예: 순차 ID, 비슷한 prefix)의 해시가 우연히 일부 나머지 값에 치우치면, 일부 파티션만 바빠진다.
- **실전에서는**:
  - N을 소수(prime)로 두거나,
  - 해시 함수를 더 강력하게 선택하거나,
  - 단순 `% N` 대신 **가상 노드 + 컨시스턴트 해싱** 등으로 문제를 완화한다.

### 3. 재균형화 전략과 궁합이 나쁘다
- **컨시스턴트 해싱(consistent hashing)** 같은 기법은:
  - 해시 값을 원형 링에 배치하고,
  - 각 노드를 해시 공간의 여러 지점(가상 노드)와 연결시켜,
  - 노드 추가/삭제 시 **일부 키만 다른 노드로 이동**하도록 설계한다.
- 반면 `hash(key) % N`은:
  - N이 바뀌면 전체 키에 대해 나머지가 거의 전부 달라지고,
  - **특정 노드만 추가/삭제**하는 상황에서도 전역적인 재배치가 발생한다.
- **즉**: 단순 모드 N 방식은 “조금만 구조가 변해도 전체 시스템에 큰 파동을 주는” 설계라, **온라인 확장성과 고가용성을 중시하는 분산 시스템과 맞지 않는다.**

## 정리 – 언제 모드 N이 괜찮고, 언제 피해야 하는가
- **괜찮은 경우**:
  - 파티션/버킷 개수가 거의 바뀌지 않는 단일 프로세스/단일 노드 내부 구조(ex: 해시맵 버킷).
  - 전체 데이터가 메모리 안에 있고, 재해시 비용을 감당할 수 있을 때.
- **피해야 할 경우**:
  - 노드/파티션을 **점진적으로 늘리거나 줄여야 하는 분산 시스템**.
  - 데이터 양이 크고, 재배치 비용이 치명적인 경우.
- 그래서 책과 실전 시스템에서는,
  - 해시값을 단순 `% N` 하기보다는,
  - **컨시스턴트 해싱, 가상 노드, 범위 파티셔닝 + 동적 분할** 등과 결합해서 “변화에 강한 파티셔닝 구조”를 설계한다는 점이 핵심 포인트다.

